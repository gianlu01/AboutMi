{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExtrudeMode = void 0;\n\nvar _bearing = _interopRequireDefault(require(\"@turf/bearing\"));\n\nvar _utils = require(\"../utils.js\");\n\nvar _modifyMode = require(\"./modify-mode.js\");\n\nvar _immutableFeatureCollection = require(\"./immutable-feature-collection.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar ExtrudeMode =\n/*#__PURE__*/\nfunction (_ModifyMode) {\n  _inherits(ExtrudeMode, _ModifyMode);\n\n  function ExtrudeMode() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, ExtrudeMode);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ExtrudeMode)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"isPointAdded\", false);\n\n    return _this;\n  }\n\n  _createClass(ExtrudeMode, [{\n    key: \"handleDragging\",\n    value: function handleDragging(event, props) {\n      var editHandle = (0, _utils.getPickedEditHandle)(event.pointerDownPicks);\n\n      if (editHandle) {\n        var featureIndex = editHandle.properties.featureIndex;\n        var positionIndexes = editHandle.properties.positionIndexes;\n        var size = this.coordinatesSize(positionIndexes, featureIndex, props.data);\n        positionIndexes = this.isPointAdded ? this.nextPositionIndexes(positionIndexes, size) : positionIndexes; // p1 and p1 are end points for edge\n\n        var p1 = this.getPointForPositionIndexes(this.prevPositionIndexes(positionIndexes, size), featureIndex, props.data);\n        var p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);\n\n        if (p1 && p2) {\n          // p3 and p4 are end points for moving (extruding) edge\n          var _generatePointsParall = (0, _utils.generatePointsParallelToLinePoints)(p1, p2, event.mapCoords),\n              _generatePointsParall2 = _slicedToArray(_generatePointsParall, 2),\n              p3 = _generatePointsParall2[0],\n              p4 = _generatePointsParall2[1];\n\n          var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replacePosition(featureIndex, this.prevPositionIndexes(positionIndexes, size), p4).replacePosition(featureIndex, positionIndexes, p3).getObject();\n          props.onEdit({\n            updatedData: updatedData,\n            editType: 'extruding',\n            editContext: {\n              featureIndexes: [featureIndex],\n              positionIndexes: this.nextPositionIndexes(positionIndexes, size),\n              position: p3\n            }\n          });\n          event.cancelPan();\n        }\n      }\n    }\n  }, {\n    key: \"handleStartDragging\",\n    value: function handleStartDragging(event, props) {\n      var selectedFeatureIndexes = props.selectedIndexes;\n      var editHandle = (0, _utils.getPickedIntermediateEditHandle)(event.picks);\n\n      if (selectedFeatureIndexes.length && editHandle) {\n        var _editHandle$propertie = editHandle.properties,\n            positionIndexes = _editHandle$propertie.positionIndexes,\n            featureIndex = _editHandle$propertie.featureIndex;\n        var size = this.coordinatesSize(positionIndexes, featureIndex, props.data); // p1 and p1 are end points for edge\n\n        var p1 = this.getPointForPositionIndexes(this.prevPositionIndexes(positionIndexes, size), featureIndex, props.data);\n        var p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);\n\n        if (p1 && p2) {\n          var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data);\n\n          if (!this.isOrthogonal(positionIndexes, featureIndex, size, props.data)) {\n            updatedData = updatedData.addPosition(featureIndex, positionIndexes, p2);\n          }\n\n          if (!this.isOrthogonal(this.prevPositionIndexes(positionIndexes, size), featureIndex, size, props.data)) {\n            updatedData = updatedData.addPosition(featureIndex, positionIndexes, p1);\n            this.isPointAdded = true;\n          }\n\n          props.onEdit({\n            updatedData: updatedData.getObject(),\n            editType: 'startExtruding',\n            editContext: {\n              featureIndexes: [featureIndex],\n              positionIndexes: positionIndexes,\n              position: p1\n            }\n          });\n        }\n      }\n    }\n  }, {\n    key: \"handleStopDragging\",\n    value: function handleStopDragging(event, props) {\n      var selectedFeatureIndexes = props.selectedIndexes;\n      var editHandle = (0, _utils.getPickedEditHandle)(event.pointerDownPicks);\n\n      if (selectedFeatureIndexes.length && editHandle) {\n        var featureIndex = editHandle.properties.featureIndex;\n        var positionIndexes = editHandle.properties.positionIndexes;\n        var size = this.coordinatesSize(positionIndexes, featureIndex, props.data);\n        positionIndexes = this.isPointAdded ? this.nextPositionIndexes(positionIndexes, size) : positionIndexes; // p1 and p1 are end points for edge\n\n        var p1 = this.getPointForPositionIndexes(this.prevPositionIndexes(positionIndexes, size), featureIndex, props.data);\n        var p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);\n\n        if (p1 && p2) {\n          // p3 and p4 are end points for new moved (extruded) edge\n          var _generatePointsParall3 = (0, _utils.generatePointsParallelToLinePoints)(p1, p2, event.mapCoords),\n              _generatePointsParall4 = _slicedToArray(_generatePointsParall3, 2),\n              p3 = _generatePointsParall4[0],\n              p4 = _generatePointsParall4[1];\n\n          var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replacePosition(featureIndex, this.prevPositionIndexes(positionIndexes, size), p4).replacePosition(featureIndex, positionIndexes, p3).getObject();\n          props.onEdit({\n            updatedData: updatedData,\n            editType: 'extruded',\n            editContext: {\n              featureIndexes: [featureIndex],\n              positionIndexes: positionIndexes,\n              position: p3\n            }\n          });\n        }\n      }\n\n      this.isPointAdded = false;\n    }\n  }, {\n    key: \"coordinatesSize\",\n    value: function coordinatesSize(positionIndexes, featureIndex, _ref) {\n      var features = _ref.features;\n      var size = 0;\n      var feature = features[featureIndex];\n      var coordinates = feature.geometry.coordinates; // for Multi polygons, length will be 3\n\n      if (positionIndexes.length === 3) {\n        var _positionIndexes = _slicedToArray(positionIndexes, 2),\n            a = _positionIndexes[0],\n            b = _positionIndexes[1];\n\n        if (coordinates.length && coordinates[a].length) {\n          size = coordinates[a][b].length;\n        }\n      } else {\n        var _positionIndexes2 = _slicedToArray(positionIndexes, 1),\n            _b = _positionIndexes2[0];\n\n        if (coordinates.length && coordinates[_b].length) {\n          size = coordinates[_b].length;\n        }\n      }\n\n      return size;\n    }\n  }, {\n    key: \"getBearing\",\n    value: function getBearing(p1, p2) {\n      var angle = (0, _bearing.default)(p1, p2);\n\n      if (angle < 0) {\n        return Math.floor(360 + angle);\n      }\n\n      return Math.floor(angle);\n    }\n  }, {\n    key: \"isOrthogonal\",\n    value: function isOrthogonal(positionIndexes, featureIndex, size, features) {\n      if (positionIndexes[positionIndexes.length - 1] === size - 1) {\n        positionIndexes[positionIndexes.length - 1] = 0;\n      }\n\n      var prevPoint = this.getPointForPositionIndexes(this.prevPositionIndexes(positionIndexes, size), featureIndex, features);\n      var nextPoint = this.getPointForPositionIndexes(this.nextPositionIndexes(positionIndexes, size), featureIndex, features);\n      var currentPoint = this.getPointForPositionIndexes(positionIndexes, featureIndex, features);\n      var prevAngle = this.getBearing(currentPoint, prevPoint);\n      var nextAngle = this.getBearing(currentPoint, nextPoint);\n      return [89, 90, 91, 269, 270, 271].includes(Math.abs(prevAngle - nextAngle));\n    }\n  }, {\n    key: \"nextPositionIndexes\",\n    value: function nextPositionIndexes(positionIndexes, size) {\n      var next = _toConsumableArray(positionIndexes);\n\n      if (next.length) {\n        next[next.length - 1] = next[next.length - 1] === size - 1 ? 0 : next[next.length - 1] + 1;\n      }\n\n      return next;\n    }\n  }, {\n    key: \"prevPositionIndexes\",\n    value: function prevPositionIndexes(positionIndexes, size) {\n      var prev = _toConsumableArray(positionIndexes);\n\n      if (prev.length) {\n        prev[prev.length - 1] = prev[prev.length - 1] === 0 ? size - 2 : prev[prev.length - 1] - 1;\n      }\n\n      return prev;\n    }\n  }, {\n    key: \"getPointForPositionIndexes\",\n    value: function getPointForPositionIndexes(positionIndexes, featureIndex, _ref2) {\n      var features = _ref2.features;\n      var p1;\n      var feature = features[featureIndex];\n      var coordinates = feature.geometry.coordinates; // for Multi polygons, length will be 3\n\n      if (positionIndexes.length === 3) {\n        var _positionIndexes3 = _slicedToArray(positionIndexes, 3),\n            a = _positionIndexes3[0],\n            b = _positionIndexes3[1],\n            c = _positionIndexes3[2];\n\n        if (coordinates.length && coordinates[a].length) {\n          p1 = coordinates[a][b][c];\n        }\n      } else {\n        var _positionIndexes4 = _slicedToArray(positionIndexes, 2),\n            _b2 = _positionIndexes4[0],\n            _c = _positionIndexes4[1];\n\n        if (coordinates.length && coordinates[_b2].length) {\n          p1 = coordinates[_b2][_c];\n        }\n      }\n\n      return p1;\n    }\n  }]);\n\n  return ExtrudeMode;\n}(_modifyMode.ModifyMode);\n\nexports.ExtrudeMode = ExtrudeMode;","map":null,"metadata":{},"sourceType":"script"}