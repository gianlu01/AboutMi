{"ast":null,"code":"'use strict';\n\nmodule.exports = Point;\n/**\r\n * A standalone point geometry with useful accessor, comparison, and\r\n * modification methods.\r\n *\r\n * @class Point\r\n * @param {Number} x the x-coordinate. this could be longitude or screen\r\n * pixels, or any other sort of unit.\r\n * @param {Number} y the y-coordinate. this could be latitude or screen\r\n * pixels, or any other sort of unit.\r\n * @example\r\n * var point = new Point(-77, 38);\r\n */\n\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype = {\n  /**\r\n   * Clone this point, returning a new point that can be modified\r\n   * without affecting the old one.\r\n   * @return {Point} the clone\r\n   */\n  clone: function () {\n    return new Point(this.x, this.y);\n  },\n\n  /**\r\n   * Add this point's x & y coordinates to another point,\r\n   * yielding a new point.\r\n   * @param {Point} p the other point\r\n   * @return {Point} output point\r\n   */\n  add: function (p) {\n    return this.clone()._add(p);\n  },\n\n  /**\r\n   * Subtract this point's x & y coordinates to from point,\r\n   * yielding a new point.\r\n   * @param {Point} p the other point\r\n   * @return {Point} output point\r\n   */\n  sub: function (p) {\n    return this.clone()._sub(p);\n  },\n\n  /**\r\n   * Multiply this point's x & y coordinates by point,\r\n   * yielding a new point.\r\n   * @param {Point} p the other point\r\n   * @return {Point} output point\r\n   */\n  multByPoint: function (p) {\n    return this.clone()._multByPoint(p);\n  },\n\n  /**\r\n   * Divide this point's x & y coordinates by point,\r\n   * yielding a new point.\r\n   * @param {Point} p the other point\r\n   * @return {Point} output point\r\n   */\n  divByPoint: function (p) {\n    return this.clone()._divByPoint(p);\n  },\n\n  /**\r\n   * Multiply this point's x & y coordinates by a factor,\r\n   * yielding a new point.\r\n   * @param {Point} k factor\r\n   * @return {Point} output point\r\n   */\n  mult: function (k) {\n    return this.clone()._mult(k);\n  },\n\n  /**\r\n   * Divide this point's x & y coordinates by a factor,\r\n   * yielding a new point.\r\n   * @param {Point} k factor\r\n   * @return {Point} output point\r\n   */\n  div: function (k) {\n    return this.clone()._div(k);\n  },\n\n  /**\r\n   * Rotate this point around the 0, 0 origin by an angle a,\r\n   * given in radians\r\n   * @param {Number} a angle to rotate around, in radians\r\n   * @return {Point} output point\r\n   */\n  rotate: function (a) {\n    return this.clone()._rotate(a);\n  },\n\n  /**\r\n   * Rotate this point around p point by an angle a,\r\n   * given in radians\r\n   * @param {Number} a angle to rotate around, in radians\r\n   * @param {Point} p Point to rotate around\r\n   * @return {Point} output point\r\n   */\n  rotateAround: function (a, p) {\n    return this.clone()._rotateAround(a, p);\n  },\n\n  /**\r\n   * Multiply this point by a 4x1 transformation matrix\r\n   * @param {Array<Number>} m transformation matrix\r\n   * @return {Point} output point\r\n   */\n  matMult: function (m) {\n    return this.clone()._matMult(m);\n  },\n\n  /**\r\n   * Calculate this point but as a unit vector from 0, 0, meaning\r\n   * that the distance from the resulting point to the 0, 0\r\n   * coordinate will be equal to 1 and the angle from the resulting\r\n   * point to the 0, 0 coordinate will be the same as before.\r\n   * @return {Point} unit vector point\r\n   */\n  unit: function () {\n    return this.clone()._unit();\n  },\n\n  /**\r\n   * Compute a perpendicular point, where the new y coordinate\r\n   * is the old x coordinate and the new x coordinate is the old y\r\n   * coordinate multiplied by -1\r\n   * @return {Point} perpendicular point\r\n   */\n  perp: function () {\n    return this.clone()._perp();\n  },\n\n  /**\r\n   * Return a version of this point with the x & y coordinates\r\n   * rounded to integers.\r\n   * @return {Point} rounded point\r\n   */\n  round: function () {\n    return this.clone()._round();\n  },\n\n  /**\r\n   * Return the magitude of this point: this is the Euclidean\r\n   * distance from the 0, 0 coordinate to this point's x and y\r\n   * coordinates.\r\n   * @return {Number} magnitude\r\n   */\n  mag: function () {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  },\n\n  /**\r\n   * Judge whether this point is equal to another point, returning\r\n   * true or false.\r\n   * @param {Point} other the other point\r\n   * @return {boolean} whether the points are equal\r\n   */\n  equals: function (other) {\n    return this.x === other.x && this.y === other.y;\n  },\n\n  /**\r\n   * Calculate the distance from this point to another point\r\n   * @param {Point} p the other point\r\n   * @return {Number} distance\r\n   */\n  dist: function (p) {\n    return Math.sqrt(this.distSqr(p));\n  },\n\n  /**\r\n   * Calculate the distance from this point to another point,\r\n   * without the square root step. Useful if you're comparing\r\n   * relative distances.\r\n   * @param {Point} p the other point\r\n   * @return {Number} distance\r\n   */\n  distSqr: function (p) {\n    var dx = p.x - this.x,\n        dy = p.y - this.y;\n    return dx * dx + dy * dy;\n  },\n\n  /**\r\n   * Get the angle from the 0, 0 coordinate to this point, in radians\r\n   * coordinates.\r\n   * @return {Number} angle\r\n   */\n  angle: function () {\n    return Math.atan2(this.y, this.x);\n  },\n\n  /**\r\n   * Get the angle from this point to another point, in radians\r\n   * @param {Point} b the other point\r\n   * @return {Number} angle\r\n   */\n  angleTo: function (b) {\n    return Math.atan2(this.y - b.y, this.x - b.x);\n  },\n\n  /**\r\n   * Get the angle between this point and another point, in radians\r\n   * @param {Point} b the other point\r\n   * @return {Number} angle\r\n   */\n  angleWith: function (b) {\n    return this.angleWithSep(b.x, b.y);\n  },\n\n  /*\r\n   * Find the angle of the two vectors, solving the formula for\r\n   * the cross product a x b = |a||b|sin(θ) for θ.\r\n   * @param {Number} x the x-coordinate\r\n   * @param {Number} y the y-coordinate\r\n   * @return {Number} the angle in radians\r\n   */\n  angleWithSep: function (x, y) {\n    return Math.atan2(this.x * y - this.y * x, this.x * x + this.y * y);\n  },\n  _matMult: function (m) {\n    var x = m[0] * this.x + m[1] * this.y,\n        y = m[2] * this.x + m[3] * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n  _add: function (p) {\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  },\n  _sub: function (p) {\n    this.x -= p.x;\n    this.y -= p.y;\n    return this;\n  },\n  _mult: function (k) {\n    this.x *= k;\n    this.y *= k;\n    return this;\n  },\n  _div: function (k) {\n    this.x /= k;\n    this.y /= k;\n    return this;\n  },\n  _multByPoint: function (p) {\n    this.x *= p.x;\n    this.y *= p.y;\n    return this;\n  },\n  _divByPoint: function (p) {\n    this.x /= p.x;\n    this.y /= p.y;\n    return this;\n  },\n  _unit: function () {\n    this._div(this.mag());\n\n    return this;\n  },\n  _perp: function () {\n    var y = this.y;\n    this.y = this.x;\n    this.x = -y;\n    return this;\n  },\n  _rotate: function (angle) {\n    var cos = Math.cos(angle),\n        sin = Math.sin(angle),\n        x = cos * this.x - sin * this.y,\n        y = sin * this.x + cos * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n  _rotateAround: function (angle, p) {\n    var cos = Math.cos(angle),\n        sin = Math.sin(angle),\n        x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),\n        y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n  _round: function () {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  }\n};\n/**\r\n * Construct a point from an array if necessary, otherwise if the input\r\n * is already a Point, or an unknown type, return it unchanged\r\n * @param {Array<Number>|Point|*} a any kind of input value\r\n * @return {Point} constructed point, or passed-through value.\r\n * @example\r\n * // this\r\n * var point = Point.convert([0, 1]);\r\n * // is equivalent to\r\n * var point = new Point(0, 1);\r\n */\n\nPoint.convert = function (a) {\n  if (a instanceof Point) {\n    return a;\n  }\n\n  if (Array.isArray(a)) {\n    return new Point(a[0], a[1]);\n  }\n\n  return a;\n};","map":null,"metadata":{},"sourceType":"script"}