{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\r\n * @module ol/PluggableMap\r\n */\n\n\nimport { getUid } from './util.js';\nimport Collection from './Collection.js';\nimport CollectionEventType from './CollectionEventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventHandler from './MapBrowserEventHandler.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport MapEvent from './MapEvent.js';\nimport MapEventType from './MapEventType.js';\nimport MapProperty from './MapProperty.js';\nimport RenderEventType from './render/EventType.js';\nimport BaseObject, { getChangeEventType } from './Object.js';\nimport ObjectEventType from './ObjectEventType.js';\nimport TileQueue from './TileQueue.js';\nimport View from './View.js';\nimport ViewHint from './ViewHint.js';\nimport { assert } from './asserts.js';\nimport { removeNode } from './dom.js';\nimport { listen, unlistenByKey } from './events.js';\nimport EventType from './events/EventType.js';\nimport { clone, createOrUpdateEmpty, equals, getForViewAndSize, isEmpty } from './extent.js';\nimport { TRUE } from './functions.js';\nimport { DEVICE_PIXEL_RATIO, IMAGE_DECODE } from './has.js';\nimport LayerGroup from './layer/Group.js';\nimport { hasArea } from './size.js';\nimport { DROP } from './structs/PriorityQueue.js';\nimport { create as createTransform, apply as applyTransform } from './transform.js';\nimport { toUserCoordinate, fromUserCoordinate } from './proj.js';\n/**\r\n * State of the current frame. Only `pixelRatio`, `time` and `viewState` should\r\n * be used in applications.\r\n * @typedef {Object} FrameState\r\n * @property {number} pixelRatio The pixel ratio of the frame.\r\n * @property {number} time The time when rendering of the frame was requested.\r\n * @property {import(\"./View.js\").State} viewState The state of the current view.\r\n * @property {boolean} animate\r\n * @property {import(\"./transform.js\").Transform} coordinateToPixelTransform\r\n * @property {null|import(\"./extent.js\").Extent} extent\r\n * @property {Array<DeclutterItems>} declutterItems\r\n * @property {number} index\r\n * @property {Array<import(\"./layer/Layer.js\").State>} layerStatesArray\r\n * @property {number} layerIndex\r\n * @property {import(\"./transform.js\").Transform} pixelToCoordinateTransform\r\n * @property {Array<PostRenderFunction>} postRenderFunctions\r\n * @property {import(\"./size.js\").Size} size\r\n * @property {TileQueue} tileQueue\r\n * @property {!Object<string, Object<string, boolean>>} usedTiles\r\n * @property {Array<number>} viewHints\r\n * @property {!Object<string, Object<string, boolean>>} wantedTiles\r\n */\n\n/**\r\n * @typedef {Object} DeclutterItems\r\n * @property {Array<*>} items Declutter items of an executor.\r\n * @property {number} opacity Layer opacity.\r\n */\n\n/**\r\n * @typedef {function(PluggableMap, ?FrameState): any} PostRenderFunction\r\n */\n\n/**\r\n * @typedef {Object} AtPixelOptions\r\n * @property {undefined|function(import(\"./layer/Layer.js\").default): boolean} [layerFilter] Layer filter\r\n * function. The filter function will receive one argument, the\r\n * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.\r\n * Only layers which are visible and for which this function returns `true`\r\n * will be tested for features. By default, all visible layers will be tested.\r\n * @property {number} [hitTolerance=0] Hit-detection tolerance in pixels. Pixels\r\n * inside the radius around the given position will be checked for features.\r\n * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for for wrapped geometries inside the range of\r\n *   +/- 1 world width. Works only if a projection is used that can be wrapped.\r\n */\n\n/**\r\n * @typedef {Object} MapOptionsInternal\r\n * @property {Collection<import(\"./control/Control.js\").default>} [controls]\r\n * @property {Collection<import(\"./interaction/Interaction.js\").default>} [interactions]\r\n * @property {HTMLElement|Document} keyboardEventTarget\r\n * @property {Collection<import(\"./Overlay.js\").default>} overlays\r\n * @property {Object<string, *>} values\r\n */\n\n/**\r\n * Object literal with config options for the map.\r\n * @typedef {Object} MapOptions\r\n * @property {Collection<import(\"./control/Control.js\").default>|Array<import(\"./control/Control.js\").default>} [controls]\r\n * Controls initially added to the map. If not specified,\r\n * {@link module:ol/control~defaults} is used.\r\n * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between\r\n * physical pixels and device-independent pixels (dips) on the device.\r\n * @property {Collection<import(\"./interaction/Interaction.js\").default>|Array<import(\"./interaction/Interaction.js\").default>} [interactions]\r\n * Interactions that are initially added to the map. If not specified,\r\n * {@link module:ol/interaction~defaults} is used.\r\n * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to\r\n * listen to keyboard events on. This determines when the `KeyboardPan` and\r\n * `KeyboardZoom` interactions trigger. For example, if this option is set to\r\n * `document` the keyboard interactions will always trigger. If this option is\r\n * not specified, the element the library listens to keyboard events on is the\r\n * map target (i.e. the user-provided div for the map). If this is not\r\n * `document`, the target element needs to be focused for key events to be\r\n * emitted, requiring that the target element has a `tabindex` attribute.\r\n * @property {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>|LayerGroup} [layers]\r\n * Layers. If this is not defined, a map with no layers will be rendered. Note\r\n * that layers are rendered in the order supplied, so if you want, for example,\r\n * a vector layer to appear on top of a tile layer, it must come after the tile\r\n * layer.\r\n * @property {number} [maxTilesLoading=16] Maximum number tiles to load\r\n * simultaneously.\r\n * @property {number} [moveTolerance=1] The minimum distance in pixels the\r\n * cursor must move to be detected as a map move event instead of a click.\r\n * Increasing this value can make it easier to click on the map.\r\n * @property {Collection<import(\"./Overlay.js\").default>|Array<import(\"./Overlay.js\").default>} [overlays]\r\n * Overlays initially added to the map. By default, no overlays are added.\r\n * @property {HTMLElement|string} [target] The container for the map, either the\r\n * element itself or the `id` of the element. If not specified at construction\r\n * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be\r\n * rendered.\r\n * @property {View} [view] The map's view.  No layer sources will be\r\n * fetched unless this is specified at construction time or through\r\n * {@link module:ol/Map~Map#setView}.\r\n */\n\n/**\r\n * @param {HTMLElement} element Element.\r\n * @param {string} touchAction Value for `touch-action'.\r\n */\n\nfunction setTouchAction(element, touchAction) {\n  element.style.msTouchAction = touchAction;\n  element.style.touchAction = touchAction;\n  element.setAttribute('touch-action', touchAction);\n}\n/**\r\n * @fires import(\"./MapBrowserEvent.js\").MapBrowserEvent\r\n * @fires import(\"./MapEvent.js\").MapEvent\r\n * @fires import(\"./render/Event.js\").default#precompose\r\n * @fires import(\"./render/Event.js\").default#postcompose\r\n * @fires import(\"./render/Event.js\").default#rendercomplete\r\n * @api\r\n */\n\n\nvar PluggableMap =\n/** @class */\nfunction (_super) {\n  __extends(PluggableMap, _super);\n  /**\r\n   * @param {MapOptions} options Map options.\r\n   */\n\n\n  function PluggableMap(options) {\n    var _this = _super.call(this) || this;\n\n    var optionsInternal = createOptionsInternal(options);\n    /** @private */\n\n    _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    _this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n\n    _this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : DEVICE_PIXEL_RATIO;\n    /**\r\n     * @private\r\n     * @type {*}\r\n     */\n\n    _this.postRenderTimeoutHandle_;\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\n\n    _this.animationDelayKey_;\n    /**\r\n     * @private\r\n     */\n\n    _this.animationDelay_ = function () {\n      this.animationDelayKey_ = undefined;\n      this.renderFrame_(Date.now());\n    }.bind(_this);\n    /**\r\n     * @private\r\n     * @type {import(\"./transform.js\").Transform}\r\n     */\n\n\n    _this.coordinateToPixelTransform_ = createTransform();\n    /**\r\n     * @private\r\n     * @type {import(\"./transform.js\").Transform}\r\n     */\n\n    _this.pixelToCoordinateTransform_ = createTransform();\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n\n    _this.frameIndex_ = 0;\n    /**\r\n     * @private\r\n     * @type {?FrameState}\r\n     */\n\n    _this.frameState_ = null;\n    /**\r\n     * The extent at the previous 'moveend' event.\r\n     * @private\r\n     * @type {import(\"./extent.js\").Extent}\r\n     */\n\n    _this.previousExtent_ = null;\n    /**\r\n     * @private\r\n     * @type {?import(\"./events.js\").EventsKey}\r\n     */\n\n    _this.viewPropertyListenerKey_ = null;\n    /**\r\n     * @private\r\n     * @type {?import(\"./events.js\").EventsKey}\r\n     */\n\n    _this.viewChangeListenerKey_ = null;\n    /**\r\n     * @private\r\n     * @type {?Array<import(\"./events.js\").EventsKey>}\r\n     */\n\n    _this.layerGroupPropertyListenerKeys_ = null;\n    /**\r\n     * @private\r\n     * @type {!HTMLElement}\r\n     */\n\n    _this.viewport_ = document.createElement('div');\n    _this.viewport_.className = 'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');\n    _this.viewport_.style.position = 'relative';\n    _this.viewport_.style.overflow = 'hidden';\n    _this.viewport_.style.width = '100%';\n    _this.viewport_.style.height = '100%';\n    /**\r\n     * @private\r\n     * @type {!HTMLElement}\r\n     */\n\n    _this.overlayContainer_ = document.createElement('div');\n    _this.overlayContainer_.style.position = 'absolute';\n    _this.overlayContainer_.style.zIndex = '0';\n    _this.overlayContainer_.style.width = '100%';\n    _this.overlayContainer_.style.height = '100%';\n    _this.overlayContainer_.className = 'ol-overlaycontainer';\n\n    _this.viewport_.appendChild(_this.overlayContainer_);\n    /**\r\n     * @private\r\n     * @type {!HTMLElement}\r\n     */\n\n\n    _this.overlayContainerStopEvent_ = document.createElement('div');\n    _this.overlayContainerStopEvent_.style.position = 'absolute';\n    _this.overlayContainerStopEvent_.style.zIndex = '0';\n    _this.overlayContainerStopEvent_.style.width = '100%';\n    _this.overlayContainerStopEvent_.style.height = '100%';\n    _this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\n\n    _this.viewport_.appendChild(_this.overlayContainerStopEvent_);\n    /**\r\n     * @private\r\n     * @type {MapBrowserEventHandler}\r\n     */\n\n\n    _this.mapBrowserEventHandler_ = new MapBrowserEventHandler(_this, options.moveTolerance);\n\n    var handleMapBrowserEvent = _this.handleMapBrowserEvent.bind(_this);\n\n    for (var key in MapBrowserEventType) {\n      _this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[key], handleMapBrowserEvent);\n    }\n    /**\r\n     * @private\r\n     * @type {HTMLElement|Document}\r\n     */\n\n\n    _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\n    /**\r\n     * @private\r\n     * @type {?Array<import(\"./events.js\").EventsKey>}\r\n     */\n\n    _this.keyHandlerKeys_ = null;\n    /**\r\n     * @private\r\n     * @type {?Array<import(\"./events.js\").EventsKey>}\r\n     */\n\n    _this.focusHandlerKeys_ = null;\n\n    var handleBrowserEvent = _this.handleBrowserEvent.bind(_this);\n\n    _this.viewport_.addEventListener(EventType.CONTEXTMENU, handleBrowserEvent, false);\n\n    _this.viewport_.addEventListener(EventType.WHEEL, handleBrowserEvent, false);\n    /**\r\n     * @type {Collection<import(\"./control/Control.js\").default>}\r\n     * @protected\r\n     */\n\n\n    _this.controls = optionsInternal.controls || new Collection();\n    /**\r\n     * @type {Collection<import(\"./interaction/Interaction.js\").default>}\r\n     * @protected\r\n     */\n\n    _this.interactions = optionsInternal.interactions || new Collection();\n    /**\r\n     * @type {Collection<import(\"./Overlay.js\").default>}\r\n     * @private\r\n     */\n\n    _this.overlays_ = optionsInternal.overlays;\n    /**\r\n     * A lookup of overlays by id.\r\n     * @private\r\n     * @type {Object<string, import(\"./Overlay.js\").default>}\r\n     */\n\n    _this.overlayIdIndex_ = {};\n    /**\r\n     * @type {import(\"./renderer/Map.js\").default}\r\n     * @private\r\n     */\n\n    _this.renderer_ = null;\n    /**\r\n     * @type {undefined|function(Event): void}\r\n     * @private\r\n     */\n\n    _this.handleResize_;\n    /**\r\n     * @private\r\n     * @type {!Array<PostRenderFunction>}\r\n     */\n\n    _this.postRenderFunctions_ = [];\n    /**\r\n     * @private\r\n     * @type {TileQueue}\r\n     */\n\n    _this.tileQueue_ = new TileQueue(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));\n\n    _this.addEventListener(getChangeEventType(MapProperty.LAYERGROUP), _this.handleLayerGroupChanged_);\n\n    _this.addEventListener(getChangeEventType(MapProperty.VIEW), _this.handleViewChanged_);\n\n    _this.addEventListener(getChangeEventType(MapProperty.SIZE), _this.handleSizeChanged_);\n\n    _this.addEventListener(getChangeEventType(MapProperty.TARGET), _this.handleTargetChanged_); // setProperties will trigger the rendering of the map if the map\n    // is \"defined\" already.\n\n\n    _this.setProperties(optionsInternal.values);\n\n    _this.controls.forEach(\n    /**\r\n     * @param {import(\"./control/Control.js\").default} control Control.\r\n     * @this {PluggableMap}\r\n     */\n    function (control) {\n      control.setMap(this);\n    }.bind(_this));\n\n    _this.controls.addEventListener(CollectionEventType.ADD,\n    /**\r\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\r\n     */\n    function (event) {\n      event.element.setMap(this);\n    }.bind(_this));\n\n    _this.controls.addEventListener(CollectionEventType.REMOVE,\n    /**\r\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\r\n     */\n    function (event) {\n      event.element.setMap(null);\n    }.bind(_this));\n\n    _this.interactions.forEach(\n    /**\r\n     * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction.\r\n     * @this {PluggableMap}\r\n     */\n    function (interaction) {\n      interaction.setMap(this);\n    }.bind(_this));\n\n    _this.interactions.addEventListener(CollectionEventType.ADD,\n    /**\r\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\r\n     */\n    function (event) {\n      event.element.setMap(this);\n    }.bind(_this));\n\n    _this.interactions.addEventListener(CollectionEventType.REMOVE,\n    /**\r\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\r\n     */\n    function (event) {\n      event.element.setMap(null);\n    }.bind(_this));\n\n    _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));\n\n    _this.overlays_.addEventListener(CollectionEventType.ADD,\n    /**\r\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\r\n     */\n    function (event) {\n      this.addOverlayInternal_(\n      /** @type {import(\"./Overlay.js\").default} */\n      event.element);\n    }.bind(_this));\n\n    _this.overlays_.addEventListener(CollectionEventType.REMOVE,\n    /**\r\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\r\n     */\n    function (event) {\n      var overlay =\n      /** @type {import(\"./Overlay.js\").default} */\n      event.element;\n      var id = overlay.getId();\n\n      if (id !== undefined) {\n        delete this.overlayIdIndex_[id.toString()];\n      }\n\n      event.element.setMap(null);\n    }.bind(_this));\n\n    return _this;\n  }\n  /**\r\n   * @abstract\r\n   * @return {import(\"./renderer/Map.js\").default} The map renderer\r\n   */\n\n\n  PluggableMap.prototype.createRenderer = function () {\n    throw new Error('Use a map type that has a createRenderer method');\n  };\n  /**\r\n   * Add the given control to the map.\r\n   * @param {import(\"./control/Control.js\").default} control Control.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.addControl = function (control) {\n    this.getControls().push(control);\n  };\n  /**\r\n   * Add the given interaction to the map. If you want to add an interaction\r\n   * at another point of the collection use `getInteraction()` and the methods\r\n   * available on {@link module:ol/Collection~Collection}. This can be used to\r\n   * stop the event propagation from the handleEvent function. The interactions\r\n   * get to handle the events in the reverse order of this collection.\r\n   * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to add.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.addInteraction = function (interaction) {\n    this.getInteractions().push(interaction);\n  };\n  /**\r\n   * Adds the given layer to the top of this map. If you want to add a layer\r\n   * elsewhere in the stack, use `getLayers()` and the methods available on\r\n   * {@link module:ol/Collection~Collection}.\r\n   * @param {import(\"./layer/Base.js\").default} layer Layer.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.addLayer = function (layer) {\n    var layers = this.getLayerGroup().getLayers();\n    layers.push(layer);\n  };\n  /**\r\n   * Add the given overlay to the map.\r\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.addOverlay = function (overlay) {\n    this.getOverlays().push(overlay);\n  };\n  /**\r\n   * This deals with map's overlay collection changes.\r\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\r\n   * @private\r\n   */\n\n\n  PluggableMap.prototype.addOverlayInternal_ = function (overlay) {\n    var id = overlay.getId();\n\n    if (id !== undefined) {\n      this.overlayIdIndex_[id.toString()] = overlay;\n    }\n\n    overlay.setMap(this);\n  };\n  /**\r\n   *\r\n   * @inheritDoc\r\n   */\n\n\n  PluggableMap.prototype.disposeInternal = function () {\n    this.mapBrowserEventHandler_.dispose();\n    this.viewport_.removeEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_);\n    this.viewport_.removeEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_);\n\n    if (this.handleResize_ !== undefined) {\n      removeEventListener(EventType.RESIZE, this.handleResize_, false);\n      this.handleResize_ = undefined;\n    }\n\n    this.setTarget(null);\n\n    _super.prototype.disposeInternal.call(this);\n  };\n  /**\r\n   * Detect features that intersect a pixel on the viewport, and execute a\r\n   * callback with each intersecting feature. Layers included in the detection can\r\n   * be configured through the `layerFilter` option in `opt_options`.\r\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\r\n   * @param {function(this: S, import(\"./Feature.js\").FeatureLike,\r\n   *     import(\"./layer/Layer.js\").default): T} callback Feature callback. The callback will be\r\n   *     called with two arguments. The first argument is one\r\n   *     {@link module:ol/Feature feature} or\r\n   *     {@link module:ol/render/Feature render feature} at the pixel, the second is\r\n   *     the {@link module:ol/layer/Layer layer} of the feature and will be null for\r\n   *     unmanaged layers. To stop detection, callback functions can return a\r\n   *     truthy value.\r\n   * @param {AtPixelOptions=} opt_options Optional options.\r\n   * @return {T|undefined} Callback result, i.e. the return value of last\r\n   * callback execution, or the first truthy callback return value.\r\n   * @template S,T\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.forEachFeatureAtPixel = function (pixel, callback, opt_options) {\n    if (!this.frameState_) {\n      return;\n    }\n\n    var coordinate = this.getCoordinateFromPixelInternal(pixel);\n    opt_options = opt_options !== undefined ? opt_options : {};\n    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n    var checkWrapped = opt_options.checkWrapped !== false;\n    return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);\n  };\n  /**\r\n   * Get all features that intersect a pixel on the viewport.\r\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\r\n   * @param {AtPixelOptions=} opt_options Optional options.\r\n   * @return {Array<import(\"./Feature.js\").FeatureLike>} The detected features or\r\n   * an empty array if none were found.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.getFeaturesAtPixel = function (pixel, opt_options) {\n    var features = [];\n    this.forEachFeatureAtPixel(pixel, function (feature) {\n      features.push(feature);\n    }, opt_options);\n    return features;\n  };\n  /**\r\n   * Detect layers that have a color value at a pixel on the viewport, and\r\n   * execute a callback with each matching layer. Layers included in the\r\n   * detection can be configured through `opt_layerFilter`.\r\n   *\r\n   * Note: this may give false positives unless the map layers have had different `className`\r\n   * properties assigned to them.\r\n   *\r\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\r\n   * @param {function(this: S, import(\"./layer/Layer.js\").default, (Uint8ClampedArray|Uint8Array)): T} callback\r\n   *     Layer callback. This callback will receive two arguments: first is the\r\n   *     {@link module:ol/layer/Layer layer}, second argument is an array representing\r\n   *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types\r\n   *     that do not currently support this argument. To stop detection, callback\r\n   *     functions can return a truthy value.\r\n   * @param {AtPixelOptions=} opt_options Configuration options.\r\n   * @return {T|undefined} Callback result, i.e. the return value of last\r\n   * callback execution, or the first truthy callback return value.\r\n   * @template S,T\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.forEachLayerAtPixel = function (pixel, callback, opt_options) {\n    if (!this.frameState_) {\n      return;\n    }\n\n    var options = opt_options || {};\n    var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance * this.frameState_.pixelRatio : 0;\n    var layerFilter = options.layerFilter || TRUE;\n    return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);\n  };\n  /**\r\n   * Detect if features intersect a pixel on the viewport. Layers included in the\r\n   * detection can be configured through `opt_layerFilter`.\r\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\r\n   * @param {AtPixelOptions=} opt_options Optional options.\r\n   * @return {boolean} Is there a feature at the given pixel?\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.hasFeatureAtPixel = function (pixel, opt_options) {\n    if (!this.frameState_) {\n      return false;\n    }\n\n    var coordinate = this.getCoordinateFromPixelInternal(pixel);\n    opt_options = opt_options !== undefined ? opt_options : {};\n    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    var checkWrapped = opt_options.checkWrapped !== false;\n    return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);\n  };\n  /**\r\n   * Returns the coordinate in user projection for a browser event.\r\n   * @param {Event} event Event.\r\n   * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.getEventCoordinate = function (event) {\n    return this.getCoordinateFromPixel(this.getEventPixel(event));\n  };\n  /**\r\n   * Returns the coordinate in view projection for a browser event.\r\n   * @param {Event} event Event.\r\n   * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\r\n   */\n\n\n  PluggableMap.prototype.getEventCoordinateInternal = function (event) {\n    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));\n  };\n  /**\r\n   * Returns the map pixel position for a browser event relative to the viewport.\r\n   * @param {Event|TouchEvent} event Event.\r\n   * @return {import(\"./pixel.js\").Pixel} Pixel.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.getEventPixel = function (event) {\n    var viewportPosition = this.viewport_.getBoundingClientRect();\n    var eventPosition = 'changedTouches' in event ?\n    /** @type {TouchEvent} */\n    event.changedTouches[0] :\n    /** @type {MouseEvent} */\n    event;\n    return [eventPosition.clientX - viewportPosition.left, eventPosition.clientY - viewportPosition.top];\n  };\n  /**\r\n   * Get the target in which this map is rendered.\r\n   * Note that this returns what is entered as an option or in setTarget:\r\n   * if that was an element, it returns an element; if a string, it returns that.\r\n   * @return {HTMLElement|string|undefined} The Element or id of the Element that the\r\n   *     map is rendered in.\r\n   * @observable\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.getTarget = function () {\n    return (\n      /** @type {HTMLElement|string|undefined} */\n      this.get(MapProperty.TARGET)\n    );\n  };\n  /**\r\n   * Get the DOM element into which this map is rendered. In contrast to\r\n   * `getTarget` this method always return an `Element`, or `null` if the\r\n   * map has no target.\r\n   * @return {HTMLElement} The element that the map is rendered in.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.getTargetElement = function () {\n    var target = this.getTarget();\n\n    if (target !== undefined) {\n      return typeof target === 'string' ? document.getElementById(target) : target;\n    } else {\n      return null;\n    }\n  };\n  /**\r\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\r\n   * user projection.\r\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\r\n   * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.getCoordinateFromPixel = function (pixel) {\n    return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());\n  };\n  /**\r\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\r\n   * map view projection.\r\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\r\n   * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\r\n   */\n\n\n  PluggableMap.prototype.getCoordinateFromPixelInternal = function (pixel) {\n    var frameState = this.frameState_;\n\n    if (!frameState) {\n      return null;\n    } else {\n      return applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    }\n  };\n  /**\r\n   * Get the map controls. Modifying this collection changes the controls\r\n   * associated with the map.\r\n   * @return {Collection<import(\"./control/Control.js\").default>} Controls.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.getControls = function () {\n    return this.controls;\n  };\n  /**\r\n   * Get the map overlays. Modifying this collection changes the overlays\r\n   * associated with the map.\r\n   * @return {Collection<import(\"./Overlay.js\").default>} Overlays.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.getOverlays = function () {\n    return this.overlays_;\n  };\n  /**\r\n   * Get an overlay by its identifier (the value returned by overlay.getId()).\r\n   * Note that the index treats string and numeric identifiers as the same. So\r\n   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.\r\n   * @param {string|number} id Overlay identifier.\r\n   * @return {import(\"./Overlay.js\").default} Overlay.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.getOverlayById = function (id) {\n    var overlay = this.overlayIdIndex_[id.toString()];\n    return overlay !== undefined ? overlay : null;\n  };\n  /**\r\n   * Get the map interactions. Modifying this collection changes the interactions\r\n   * associated with the map.\r\n   *\r\n   * Interactions are used for e.g. pan, zoom and rotate.\r\n   * @return {Collection<import(\"./interaction/Interaction.js\").default>} Interactions.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.getInteractions = function () {\n    return this.interactions;\n  };\n  /**\r\n   * Get the layergroup associated with this map.\r\n   * @return {LayerGroup} A layer group containing the layers in this map.\r\n   * @observable\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.getLayerGroup = function () {\n    return (\n      /** @type {LayerGroup} */\n      this.get(MapProperty.LAYERGROUP)\n    );\n  };\n  /**\r\n   * Get the collection of layers associated with this map.\r\n   * @return {!Collection<import(\"./layer/Base.js\").default>} Layers.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.getLayers = function () {\n    var layers = this.getLayerGroup().getLayers();\n    return layers;\n  };\n  /**\r\n   * @return {boolean} Layers have sources that are still loading.\r\n   */\n\n\n  PluggableMap.prototype.getLoading = function () {\n    var layerStatesArray = this.getLayerGroup().getLayerStatesArray();\n\n    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      var layer = layerStatesArray[i].layer;\n      var source =\n      /** @type {import(\"./layer/Layer.js\").default} */\n      layer.getSource();\n\n      if (source && source.loading) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Get the pixel for a coordinate.  This takes a coordinate in the user\r\n   * projection and returns the corresponding pixel.\r\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\r\n   * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.getPixelFromCoordinate = function (coordinate) {\n    var viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());\n    return this.getPixelFromCoordinateInternal(viewCoordinate);\n  };\n  /**\r\n   * Get the pixel for a coordinate.  This takes a coordinate in the map view\r\n   * projection and returns the corresponding pixel.\r\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\r\n   * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\r\n   */\n\n\n  PluggableMap.prototype.getPixelFromCoordinateInternal = function (coordinate) {\n    var frameState = this.frameState_;\n\n    if (!frameState) {\n      return null;\n    } else {\n      return applyTransform(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));\n    }\n  };\n  /**\r\n   * Get the map renderer.\r\n   * @return {import(\"./renderer/Map.js\").default} Renderer\r\n   */\n\n\n  PluggableMap.prototype.getRenderer = function () {\n    return this.renderer_;\n  };\n  /**\r\n   * Get the size of this map.\r\n   * @return {import(\"./size.js\").Size|undefined} The size in pixels of the map in the DOM.\r\n   * @observable\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.getSize = function () {\n    return (\n      /** @type {import(\"./size.js\").Size|undefined} */\n      this.get(MapProperty.SIZE)\n    );\n  };\n  /**\r\n   * Get the view associated with this map. A view manages properties such as\r\n   * center and resolution.\r\n   * @return {View} The view that controls this map.\r\n   * @observable\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.getView = function () {\n    return (\n      /** @type {View} */\n      this.get(MapProperty.VIEW)\n    );\n  };\n  /**\r\n   * Get the element that serves as the map viewport.\r\n   * @return {HTMLElement} Viewport.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.getViewport = function () {\n    return this.viewport_;\n  };\n  /**\r\n   * Get the element that serves as the container for overlays.  Elements added to\r\n   * this container will let mousedown and touchstart events through to the map,\r\n   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}\r\n   * events.\r\n   * @return {!HTMLElement} The map's overlay container.\r\n   */\n\n\n  PluggableMap.prototype.getOverlayContainer = function () {\n    return this.overlayContainer_;\n  };\n  /**\r\n   * Get the element that serves as a container for overlays that don't allow\r\n   * event propagation. Elements added to this container won't let mousedown and\r\n   * touchstart events through to the map, so clicks and gestures on an overlay\r\n   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\r\n   * @return {!HTMLElement} The map's overlay container that stops events.\r\n   */\n\n\n  PluggableMap.prototype.getOverlayContainerStopEvent = function () {\n    return this.overlayContainerStopEvent_;\n  };\n  /**\r\n   * @param {import(\"./Tile.js\").default} tile Tile.\r\n   * @param {string} tileSourceKey Tile source key.\r\n   * @param {import(\"./coordinate.js\").Coordinate} tileCenter Tile center.\r\n   * @param {number} tileResolution Tile resolution.\r\n   * @return {number} Tile priority.\r\n   */\n\n\n  PluggableMap.prototype.getTilePriority = function (tile, tileSourceKey, tileCenter, tileResolution) {\n    // Filter out tiles at higher zoom levels than the current zoom level, or that\n    // are outside the visible extent.\n    var frameState = this.frameState_;\n\n    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {\n      return DROP;\n    }\n\n    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {\n      return DROP;\n    } // Prioritize the highest zoom level tiles closest to the focus.\n    // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).\n    // Within a zoom level, tiles are prioritized by the distance in pixels between\n    // the center of the tile and the center of the viewport.  The factor of 65536\n    // means that the prioritization should behave as desired for tiles up to\n    // 65536 * Math.log(2) = 45426 pixels from the focus.\n\n\n    var center = frameState.viewState.center;\n    var deltaX = tileCenter[0] - center[0];\n    var deltaY = tileCenter[1] - center[1];\n    return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;\n  };\n  /**\r\n   * @param {Event} browserEvent Browser event.\r\n   * @param {string=} opt_type Type.\r\n   */\n\n\n  PluggableMap.prototype.handleBrowserEvent = function (browserEvent, opt_type) {\n    var type = opt_type || browserEvent.type;\n    var mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);\n    this.handleMapBrowserEvent(mapBrowserEvent);\n  };\n  /**\r\n   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.\r\n   */\n\n\n  PluggableMap.prototype.handleMapBrowserEvent = function (mapBrowserEvent) {\n    if (!this.frameState_) {\n      // With no view defined, we cannot translate pixels into geographical\n      // coordinates so interactions cannot be used.\n      return;\n    }\n\n    var target = mapBrowserEvent.originalEvent.target;\n\n    while (target instanceof HTMLElement) {\n      if (target.parentElement === this.overlayContainerStopEvent_) {\n        return;\n      }\n\n      target = target.parentElement;\n    }\n\n    mapBrowserEvent.frameState = this.frameState_;\n    var interactionsArray = this.getInteractions().getArray();\n\n    if (this.dispatchEvent(mapBrowserEvent) !== false) {\n      for (var i = interactionsArray.length - 1; i >= 0; i--) {\n        var interaction = interactionsArray[i];\n\n        if (!interaction.getActive()) {\n          continue;\n        }\n\n        var cont = interaction.handleEvent(mapBrowserEvent);\n\n        if (!cont) {\n          break;\n        }\n      }\n    }\n  };\n  /**\r\n   * @protected\r\n   */\n\n\n  PluggableMap.prototype.handlePostRender = function () {\n    var frameState = this.frameState_; // Manage the tile queue\n    // Image loads are expensive and a limited resource, so try to use them\n    // efficiently:\n    // * When the view is static we allow a large number of parallel tile loads\n    //   to complete the frame as quickly as possible.\n    // * When animating or interacting, image loads can cause janks, so we reduce\n    //   the maximum number of loads per frame and limit the number of parallel\n    //   tile loads to remain reactive to view changes and to reduce the chance of\n    //   loading tiles that will quickly disappear from view.\n\n    var tileQueue = this.tileQueue_;\n\n    if (!tileQueue.isEmpty()) {\n      var maxTotalLoading = this.maxTilesLoading_;\n      var maxNewLoads = maxTotalLoading;\n\n      if (frameState) {\n        var hints = frameState.viewHints;\n\n        if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {\n          var lowOnFrameBudget = !IMAGE_DECODE && Date.now() - frameState.time > 8;\n          maxTotalLoading = lowOnFrameBudget ? 0 : 8;\n          maxNewLoads = lowOnFrameBudget ? 0 : 2;\n        }\n      }\n\n      if (tileQueue.getTilesLoading() < maxTotalLoading) {\n        tileQueue.reprioritize(); // FIXME only call if view has changed\n\n        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\n      }\n    }\n\n    if (frameState && this.hasListener(RenderEventType.RENDERCOMPLETE) && !frameState.animate && !this.tileQueue_.getTilesLoading() && !this.getLoading()) {\n      this.renderer_.dispatchRenderEvent(RenderEventType.RENDERCOMPLETE, frameState);\n    }\n\n    var postRenderFunctions = this.postRenderFunctions_;\n\n    for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {\n      postRenderFunctions[i](this, frameState);\n    }\n\n    postRenderFunctions.length = 0;\n  };\n  /**\r\n   * @private\r\n   */\n\n\n  PluggableMap.prototype.handleSizeChanged_ = function () {\n    if (this.getView()) {\n      this.getView().resolveConstraints(0);\n    }\n\n    this.render();\n  };\n  /**\r\n   * @private\r\n   */\n\n\n  PluggableMap.prototype.handleTargetChanged_ = function () {\n    // target may be undefined, null, a string or an Element.\n    // If it's a string we convert it to an Element before proceeding.\n    // If it's not now an Element we remove the viewport from the DOM.\n    // If it's an Element we append the viewport element to it.\n    var targetElement;\n\n    if (this.getTarget()) {\n      targetElement = this.getTargetElement();\n    }\n\n    if (this.focusHandlerKeys_) {\n      for (var i = 0, ii = this.focusHandlerKeys_.length; i < ii; ++i) {\n        unlistenByKey(this.focusHandlerKeys_[i]);\n      }\n\n      this.focusHandlerKeys_ = null;\n    }\n\n    if (this.keyHandlerKeys_) {\n      for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {\n        unlistenByKey(this.keyHandlerKeys_[i]);\n      }\n\n      this.keyHandlerKeys_ = null;\n    }\n\n    if (!targetElement) {\n      if (this.renderer_) {\n        clearTimeout(this.postRenderTimeoutHandle_);\n        this.postRenderFunctions_.length = 0;\n        this.renderer_.dispose();\n        this.renderer_ = null;\n      }\n\n      if (this.animationDelayKey_) {\n        cancelAnimationFrame(this.animationDelayKey_);\n        this.animationDelayKey_ = undefined;\n      }\n\n      removeNode(this.viewport_);\n\n      if (this.handleResize_ !== undefined) {\n        removeEventListener(EventType.RESIZE, this.handleResize_, false);\n        this.handleResize_ = undefined;\n      }\n    } else {\n      targetElement.appendChild(this.viewport_);\n\n      if (!this.renderer_) {\n        this.renderer_ = this.createRenderer();\n      }\n\n      var hasFocus = true;\n\n      if (targetElement.hasAttribute('tabindex')) {\n        hasFocus = document.activeElement === targetElement;\n        this.focusHandlerKeys_ = [listen(targetElement, EventType.FOCUS, setTouchAction.bind(this, this.viewport_, 'none')), listen(targetElement, EventType.BLUR, setTouchAction.bind(this, this.viewport_, 'auto'))];\n      }\n\n      setTouchAction(this.viewport_, hasFocus ? 'none' : 'auto');\n      var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;\n      this.keyHandlerKeys_ = [listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this), listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this)];\n\n      if (!this.handleResize_) {\n        this.handleResize_ = this.updateSize.bind(this);\n        window.addEventListener(EventType.RESIZE, this.handleResize_, false);\n      }\n    }\n\n    this.updateSize(); // updateSize calls setSize, so no need to call this.render\n    // ourselves here.\n  };\n  /**\r\n   * @private\r\n   */\n\n\n  PluggableMap.prototype.handleTileChange_ = function () {\n    this.render();\n  };\n  /**\r\n   * @private\r\n   */\n\n\n  PluggableMap.prototype.handleViewPropertyChanged_ = function () {\n    this.render();\n  };\n  /**\r\n   * @private\r\n   */\n\n\n  PluggableMap.prototype.handleViewChanged_ = function () {\n    if (this.viewPropertyListenerKey_) {\n      unlistenByKey(this.viewPropertyListenerKey_);\n      this.viewPropertyListenerKey_ = null;\n    }\n\n    if (this.viewChangeListenerKey_) {\n      unlistenByKey(this.viewChangeListenerKey_);\n      this.viewChangeListenerKey_ = null;\n    }\n\n    var view = this.getView();\n\n    if (view) {\n      this.viewport_.setAttribute('data-view', getUid(view));\n      this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);\n      this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);\n      view.resolveConstraints(0);\n    }\n\n    this.render();\n  };\n  /**\r\n   * @private\r\n   */\n\n\n  PluggableMap.prototype.handleLayerGroupChanged_ = function () {\n    if (this.layerGroupPropertyListenerKeys_) {\n      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);\n      this.layerGroupPropertyListenerKeys_ = null;\n    }\n\n    var layerGroup = this.getLayerGroup();\n\n    if (layerGroup) {\n      this.layerGroupPropertyListenerKeys_ = [listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this), listen(layerGroup, EventType.CHANGE, this.render, this)];\n    }\n\n    this.render();\n  };\n  /**\r\n   * @return {boolean} Is rendered.\r\n   */\n\n\n  PluggableMap.prototype.isRendered = function () {\n    return !!this.frameState_;\n  };\n  /**\r\n   * Requests an immediate render in a synchronous manner.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.renderSync = function () {\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n    }\n\n    this.animationDelay_();\n  };\n  /**\r\n   * Redraws all text after new fonts have loaded\r\n   */\n\n\n  PluggableMap.prototype.redrawText = function () {\n    var layerStates = this.getLayerGroup().getLayerStatesArray();\n\n    for (var i = 0, ii = layerStates.length; i < ii; ++i) {\n      var layer = layerStates[i].layer;\n\n      if (layer.hasRenderer()) {\n        layer.getRenderer().handleFontsChanged();\n      }\n    }\n  };\n  /**\r\n   * Request a map rendering (at the next animation frame).\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.render = function () {\n    if (this.renderer_ && this.animationDelayKey_ === undefined) {\n      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);\n    }\n  };\n  /**\r\n   * Remove the given control from the map.\r\n   * @param {import(\"./control/Control.js\").default} control Control.\r\n   * @return {import(\"./control/Control.js\").default|undefined} The removed control (or undefined\r\n   *     if the control was not found).\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.removeControl = function (control) {\n    return this.getControls().remove(control);\n  };\n  /**\r\n   * Remove the given interaction from the map.\r\n   * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to remove.\r\n   * @return {import(\"./interaction/Interaction.js\").default|undefined} The removed interaction (or\r\n   *     undefined if the interaction was not found).\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.removeInteraction = function (interaction) {\n    return this.getInteractions().remove(interaction);\n  };\n  /**\r\n   * Removes the given layer from the map.\r\n   * @param {import(\"./layer/Base.js\").default} layer Layer.\r\n   * @return {import(\"./layer/Base.js\").default|undefined} The removed layer (or undefined if the\r\n   *     layer was not found).\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.removeLayer = function (layer) {\n    var layers = this.getLayerGroup().getLayers();\n    return layers.remove(layer);\n  };\n  /**\r\n   * Remove the given overlay from the map.\r\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\r\n   * @return {import(\"./Overlay.js\").default|undefined} The removed overlay (or undefined\r\n   *     if the overlay was not found).\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.removeOverlay = function (overlay) {\n    return this.getOverlays().remove(overlay);\n  };\n  /**\r\n   * @param {number} time Time.\r\n   * @private\r\n   */\n\n\n  PluggableMap.prototype.renderFrame_ = function (time) {\n    var size = this.getSize();\n    var view = this.getView();\n    var previousFrameState = this.frameState_;\n    /** @type {?FrameState} */\n\n    var frameState = null;\n\n    if (size !== undefined && hasArea(size) && view && view.isDef()) {\n      var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);\n      var viewState = view.getState();\n      frameState = {\n        animate: false,\n        coordinateToPixelTransform: this.coordinateToPixelTransform_,\n        declutterItems: previousFrameState ? previousFrameState.declutterItems : [],\n        extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),\n        index: this.frameIndex_++,\n        layerIndex: 0,\n        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),\n        pixelRatio: this.pixelRatio_,\n        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\n        postRenderFunctions: [],\n        size: size,\n        tileQueue: this.tileQueue_,\n        time: time,\n        usedTiles: {},\n        viewState: viewState,\n        viewHints: viewHints,\n        wantedTiles: {}\n      };\n    }\n\n    this.frameState_ = frameState;\n    this.renderer_.renderFrame(frameState);\n\n    if (frameState) {\n      if (frameState.animate) {\n        this.render();\n      }\n\n      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);\n\n      if (previousFrameState) {\n        var moveStart = !this.previousExtent_ || !isEmpty(this.previousExtent_) && !equals(frameState.extent, this.previousExtent_);\n\n        if (moveStart) {\n          this.dispatchEvent(new MapEvent(MapEventType.MOVESTART, this, previousFrameState));\n          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);\n        }\n      }\n\n      var idle = this.previousExtent_ && !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING] && !equals(frameState.extent, this.previousExtent_);\n\n      if (idle) {\n        this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));\n        clone(frameState.extent, this.previousExtent_);\n      }\n    }\n\n    this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));\n    this.postRenderTimeoutHandle_ = setTimeout(this.handlePostRender.bind(this), 0);\n  };\n  /**\r\n   * Sets the layergroup of this map.\r\n   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.\r\n   * @observable\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.setLayerGroup = function (layerGroup) {\n    this.set(MapProperty.LAYERGROUP, layerGroup);\n  };\n  /**\r\n   * Set the size of this map.\r\n   * @param {import(\"./size.js\").Size|undefined} size The size in pixels of the map in the DOM.\r\n   * @observable\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.setSize = function (size) {\n    this.set(MapProperty.SIZE, size);\n  };\n  /**\r\n   * Set the target element to render this map into.\r\n   * @param {HTMLElement|string|undefined} target The Element or id of the Element\r\n   *     that the map is rendered in.\r\n   * @observable\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.setTarget = function (target) {\n    this.set(MapProperty.TARGET, target);\n  };\n  /**\r\n   * Set the view for this map.\r\n   * @param {View} view The view that controls this map.\r\n   * @observable\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.setView = function (view) {\n    this.set(MapProperty.VIEW, view);\n  };\n  /**\r\n   * Force a recalculation of the map viewport size.  This should be called when\r\n   * third-party code changes the size of the map viewport.\r\n   * @api\r\n   */\n\n\n  PluggableMap.prototype.updateSize = function () {\n    var targetElement = this.getTargetElement();\n\n    if (!targetElement) {\n      this.setSize(undefined);\n    } else {\n      var computedStyle = getComputedStyle(targetElement);\n      this.setSize([targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']), targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth'])]);\n    }\n  };\n\n  return PluggableMap;\n}(BaseObject);\n/**\r\n * @param {MapOptions} options Map options.\r\n * @return {MapOptionsInternal} Internal map options.\r\n */\n\n\nfunction createOptionsInternal(options) {\n  /**\r\n   * @type {HTMLElement|Document}\r\n   */\n  var keyboardEventTarget = null;\n\n  if (options.keyboardEventTarget !== undefined) {\n    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;\n  }\n  /**\r\n   * @type {Object<string, *>}\r\n   */\n\n\n  var values = {};\n  var layerGroup = options.layers && typeof\n  /** @type {?} */\n  options.layers.getLayers === 'function' ?\n  /** @type {LayerGroup} */\n  options.layers : new LayerGroup({\n    layers:\n    /** @type {Collection} */\n    options.layers\n  });\n  values[MapProperty.LAYERGROUP] = layerGroup;\n  values[MapProperty.TARGET] = options.target;\n  values[MapProperty.VIEW] = options.view !== undefined ? options.view : new View();\n  var controls;\n\n  if (options.controls !== undefined) {\n    if (Array.isArray(options.controls)) {\n      controls = new Collection(options.controls.slice());\n    } else {\n      assert(typeof\n      /** @type {?} */\n      options.controls.getArray === 'function', 47); // Expected `controls` to be an array or an `import(\"./Collection.js\").Collection`\n\n      controls =\n      /** @type {Collection} */\n      options.controls;\n    }\n  }\n\n  var interactions;\n\n  if (options.interactions !== undefined) {\n    if (Array.isArray(options.interactions)) {\n      interactions = new Collection(options.interactions.slice());\n    } else {\n      assert(typeof\n      /** @type {?} */\n      options.interactions.getArray === 'function', 48); // Expected `interactions` to be an array or an `import(\"./Collection.js\").Collection`\n\n      interactions =\n      /** @type {Collection} */\n      options.interactions;\n    }\n  }\n\n  var overlays;\n\n  if (options.overlays !== undefined) {\n    if (Array.isArray(options.overlays)) {\n      overlays = new Collection(options.overlays.slice());\n    } else {\n      assert(typeof\n      /** @type {?} */\n      options.overlays.getArray === 'function', 49); // Expected `overlays` to be an array or an `import(\"./Collection.js\").Collection`\n\n      overlays = options.overlays;\n    }\n  } else {\n    overlays = new Collection();\n  }\n\n  return {\n    controls: controls,\n    interactions: interactions,\n    keyboardEventTarget: keyboardEventTarget,\n    overlays: overlays,\n    values: values\n  };\n}\n\nexport default PluggableMap;","map":null,"metadata":{},"sourceType":"module"}