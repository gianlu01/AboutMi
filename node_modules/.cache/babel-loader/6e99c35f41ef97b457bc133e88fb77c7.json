{"ast":null,"code":"import { degreesToRadians, isNumber, isObject, polygon } from '@turf/helpers';\nimport rhumbDestination from '@turf/rhumb-destination';\nimport transformRotate from '@turf/transform-rotate';\nimport { getCoord } from '@turf/invariant';\n/**\n * Takes a {@link Point} and calculates the ellipse polygon given two semi-axes expressed in variable units and steps for precision.\n *\n * @param {Coord} center center point\n * @param {number} xSemiAxis semi (major) axis of the ellipse along the x-axis\n * @param {number} ySemiAxis semi (minor) axis of the ellipse along the y-axis\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.angle=0] angle of rotation (along the vertical axis), from North in decimal degrees, negative clockwise\n * @param {Coord} [options.pivot='origin'] point around which the rotation will be performed\n * @param {number} [options.steps=64] number of steps\n * @param {string} [options.units='kilometers'] unit of measurement for axes\n * @param {Object} [options.properties={}] properties\n * @returns {Feature<Polygon>} ellipse polygon\n * @example\n * var center = [-75, 40];\n * var xSemiAxis = 5;\n * var ySemiAxis = 2;\n * var ellipse = turf.ellipse(center, xSemiAxis, ySemiAxis);\n *\n * //addToMap\n * var addToMap = [turf.point(center), ellipse]\n */\n\nfunction ellipse(center, xSemiAxis, ySemiAxis, options) {\n  // Optional params\n  options = options || {};\n  var steps = options.steps || 64;\n  var units = options.units || 'kilometers';\n  var angle = options.angle || 0;\n  var pivot = options.pivot || center;\n  var properties = options.properties || center.properties || {}; // validation\n\n  if (!center) throw new Error('center is required');\n  if (!xSemiAxis) throw new Error('xSemiAxis is required');\n  if (!ySemiAxis) throw new Error('ySemiAxis is required');\n  if (!isObject(options)) throw new Error('options must be an object');\n  if (!isNumber(steps)) throw new Error('steps must be a number');\n  if (!isNumber(angle)) throw new Error('angle must be a number');\n  var centerCoords = getCoord(center);\n\n  if (units === 'degrees') {\n    var angleRad = degreesToRadians(angle);\n  } else {\n    xSemiAxis = rhumbDestination(center, xSemiAxis, 90, {\n      units: units\n    });\n    ySemiAxis = rhumbDestination(center, ySemiAxis, 0, {\n      units: units\n    });\n    xSemiAxis = getCoord(xSemiAxis)[0] - centerCoords[0];\n    ySemiAxis = getCoord(ySemiAxis)[1] - centerCoords[1];\n  }\n\n  var coordinates = [];\n\n  for (var i = 0; i < steps; i += 1) {\n    var stepAngle = i * -360 / steps;\n    var x = xSemiAxis * ySemiAxis / Math.sqrt(Math.pow(ySemiAxis, 2) + Math.pow(xSemiAxis, 2) * Math.pow(getTanDeg(stepAngle), 2));\n    var y = xSemiAxis * ySemiAxis / Math.sqrt(Math.pow(xSemiAxis, 2) + Math.pow(ySemiAxis, 2) / Math.pow(getTanDeg(stepAngle), 2));\n    if (stepAngle < -90 && stepAngle >= -270) x = -x;\n    if (stepAngle < -180 && stepAngle >= -360) y = -y;\n\n    if (units === 'degrees') {\n      var newx = x * Math.cos(angleRad) + y * Math.sin(angleRad);\n      var newy = y * Math.cos(angleRad) - x * Math.sin(angleRad);\n      x = newx;\n      y = newy;\n    }\n\n    coordinates.push([x + centerCoords[0], y + centerCoords[1]]);\n  }\n\n  coordinates.push(coordinates[0]);\n\n  if (units === 'degrees') {\n    return polygon([coordinates], properties);\n  } else {\n    return transformRotate(polygon([coordinates], properties), angle, {\n      pivot: pivot\n    });\n  }\n}\n/**\n * Get Tan Degrees\n *\n * @private\n * @param {number} deg Degrees\n * @returns {number} Tan Degrees\n */\n\n\nfunction getTanDeg(deg) {\n  var rad = deg * Math.PI / 180;\n  return Math.tan(rad);\n}\n\nexport default ellipse;","map":null,"metadata":{},"sourceType":"module"}