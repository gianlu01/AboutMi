{"ast":null,"code":"var rightHandRule = require('./rhr');\n/**\n * @alias geojsonhint\n * @param {(string|object)} GeoJSON given as a string or as an object\n * @param {Object} options\n * @param {boolean} [options.noDuplicateMembers=true] forbid repeated\n * properties. This is only available for string input, becaused parsed\n * Objects cannot have duplicate properties.\n * @param {boolean} [options.precisionWarning=true] warn if GeoJSON contains\n * unnecessary coordinate precision.\n * @returns {Array<Object>} an array of errors\n */\n\n\nfunction hint(gj, options) {\n  var errors = [];\n  var precisionWarningCount = 0;\n  var maxPrecisionWarnings = 10;\n  var maxPrecision = 6;\n\n  function root(_) {\n    if ((!options || options.noDuplicateMembers !== false) && _.__duplicateProperties__) {\n      errors.push({\n        message: 'An object contained duplicate members, making parsing ambigous: ' + _.__duplicateProperties__.join(', '),\n        line: _.__line__\n      });\n    }\n\n    if (requiredProperty(_, 'type', 'string')) {\n      return;\n    }\n\n    if (!types[_.type]) {\n      var expectedType = typesLower[_.type.toLowerCase()];\n\n      if (expectedType !== undefined) {\n        errors.push({\n          message: 'Expected ' + expectedType + ' but got ' + _.type + ' (case sensitive)',\n          line: _.__line__\n        });\n      } else {\n        errors.push({\n          message: 'The type ' + _.type + ' is unknown',\n          line: _.__line__\n        });\n      }\n    } else if (_) {\n      types[_.type](_);\n    }\n  }\n\n  function everyIs(_, type) {\n    // make a single exception because typeof null === 'object'\n    return _.every(function (x) {\n      return x !== null && typeof x === type;\n    });\n  }\n\n  function requiredProperty(_, name, type) {\n    if (typeof _[name] === 'undefined') {\n      return errors.push({\n        message: '\"' + name + '\" member required',\n        line: _.__line__\n      });\n    } else if (type === 'array') {\n      if (!Array.isArray(_[name])) {\n        return errors.push({\n          message: '\"' + name + '\" member should be an array, but is an ' + typeof _[name] + ' instead',\n          line: _.__line__\n        });\n      }\n    } else if (type === 'object' && _[name] && _[name].constructor !== Object) {\n      return errors.push({\n        message: '\"' + name + '\" member should be ' + type + ', but is an ' + _[name].constructor.name + ' instead',\n        line: _.__line__\n      });\n    } else if (type && typeof _[name] !== type) {\n      return errors.push({\n        message: '\"' + name + '\" member should be ' + type + ', but is an ' + typeof _[name] + ' instead',\n        line: _.__line__\n      });\n    }\n  } // https://tools.ietf.org/html/rfc7946#section-3.3\n\n\n  function FeatureCollection(featureCollection) {\n    crs(featureCollection);\n    bbox(featureCollection);\n\n    if (featureCollection.properties !== undefined) {\n      errors.push({\n        message: 'FeatureCollection object cannot contain a \"properties\" member',\n        line: featureCollection.__line__\n      });\n    }\n\n    if (featureCollection.coordinates !== undefined) {\n      errors.push({\n        message: 'FeatureCollection object cannot contain a \"coordinates\" member',\n        line: featureCollection.__line__\n      });\n    }\n\n    if (!requiredProperty(featureCollection, 'features', 'array')) {\n      if (!everyIs(featureCollection.features, 'object')) {\n        return errors.push({\n          message: 'Every feature must be an object',\n          line: featureCollection.__line__\n        });\n      }\n\n      featureCollection.features.forEach(Feature);\n    }\n  } // https://tools.ietf.org/html/rfc7946#section-3.1.1\n\n\n  function position(_, line) {\n    if (!Array.isArray(_)) {\n      return errors.push({\n        message: 'position should be an array, is a ' + typeof _ + ' instead',\n        line: _.__line__ || line\n      });\n    }\n\n    if (_.length < 2) {\n      return errors.push({\n        message: 'position must have 2 or more elements',\n        line: _.__line__ || line\n      });\n    }\n\n    if (_.length > 3) {\n      return errors.push({\n        message: 'position should not have more than 3 elements',\n        level: 'message',\n        line: _.__line__ || line\n      });\n    }\n\n    if (!everyIs(_, 'number')) {\n      return errors.push({\n        message: 'each element in a position must be a number',\n        line: _.__line__ || line\n      });\n    }\n\n    if (options && options.precisionWarning) {\n      if (precisionWarningCount === maxPrecisionWarnings) {\n        precisionWarningCount += 1;\n        return errors.push({\n          message: 'truncated warnings: we\\'ve encountered coordinate precision warning ' + maxPrecisionWarnings + ' times, no more warnings will be reported',\n          level: 'message',\n          line: _.__line__ || line\n        });\n      } else if (precisionWarningCount < maxPrecisionWarnings) {\n        _.forEach(function (num) {\n          var precision = 0;\n          var decimalStr = String(num).split('.')[1];\n          if (decimalStr !== undefined) precision = decimalStr.length;\n\n          if (precision > maxPrecision) {\n            precisionWarningCount += 1;\n            return errors.push({\n              message: 'precision of coordinates should be reduced',\n              level: 'message',\n              line: _.__line__ || line\n            });\n          }\n        });\n      }\n    }\n  }\n\n  function positionArray(coords, type, depth, line) {\n    if (line === undefined && coords.__line__ !== undefined) {\n      line = coords.__line__;\n    }\n\n    if (depth === 0) {\n      return position(coords, line);\n    }\n\n    if (depth === 1 && type) {\n      if (type === 'LinearRing') {\n        if (!Array.isArray(coords[coords.length - 1])) {\n          errors.push({\n            message: 'a number was found where a coordinate array should have been found: this needs to be nested more deeply',\n            line: line\n          });\n          return true;\n        }\n\n        if (coords.length < 4) {\n          errors.push({\n            message: 'a LinearRing of coordinates needs to have four or more positions',\n            line: line\n          });\n        }\n\n        if (coords.length && (coords[coords.length - 1].length !== coords[0].length || !coords[coords.length - 1].every(function (pos, index) {\n          return coords[0][index] === pos;\n        }))) {\n          errors.push({\n            message: 'the first and last positions in a LinearRing of coordinates must be the same',\n            line: line\n          });\n          return true;\n        }\n      } else if (type === 'Line' && coords.length < 2) {\n        return errors.push({\n          message: 'a line needs to have two or more coordinates to be valid',\n          line: line\n        });\n      }\n    }\n\n    if (!Array.isArray(coords)) {\n      errors.push({\n        message: 'a number was found where a coordinate array should have been found: this needs to be nested more deeply',\n        line: line\n      });\n    } else {\n      var results = coords.map(function (c) {\n        return positionArray(c, type, depth - 1, c.__line__ || line);\n      });\n      return results.some(function (r) {\n        return r;\n      });\n    }\n  }\n\n  function crs(_) {\n    if (!_.crs) return;\n    var defaultCRSName = 'urn:ogc:def:crs:OGC:1.3:CRS84';\n\n    if (typeof _.crs === 'object' && _.crs.properties && _.crs.properties.name === defaultCRSName) {\n      errors.push({\n        message: 'old-style crs member is not recommended, this object is equivalent to the default and should be removed',\n        line: _.__line__\n      });\n    } else {\n      errors.push({\n        message: 'old-style crs member is not recommended',\n        line: _.__line__\n      });\n    }\n  }\n\n  function bbox(_) {\n    if (!_.bbox) {\n      return;\n    }\n\n    if (Array.isArray(_.bbox)) {\n      if (!everyIs(_.bbox, 'number')) {\n        errors.push({\n          message: 'each element in a bbox member must be a number',\n          line: _.bbox.__line__\n        });\n      }\n\n      if (!(_.bbox.length === 4 || _.bbox.length === 6)) {\n        errors.push({\n          message: 'bbox must contain 4 elements (for 2D) or 6 elements (for 3D)',\n          line: _.bbox.__line__\n        });\n      }\n\n      return errors.length;\n    }\n\n    errors.push({\n      message: 'bbox member must be an array of numbers, but is a ' + typeof _.bbox,\n      line: _.__line__\n    });\n  }\n\n  function geometrySemantics(geom) {\n    if (geom.properties !== undefined) {\n      errors.push({\n        message: 'geometry object cannot contain a \"properties\" member',\n        line: geom.__line__\n      });\n    }\n\n    if (geom.geometry !== undefined) {\n      errors.push({\n        message: 'geometry object cannot contain a \"geometry\" member',\n        line: geom.__line__\n      });\n    }\n\n    if (geom.features !== undefined) {\n      errors.push({\n        message: 'geometry object cannot contain a \"features\" member',\n        line: geom.__line__\n      });\n    }\n  } // https://tools.ietf.org/html/rfc7946#section-3.1.2\n\n\n  function Point(point) {\n    crs(point);\n    bbox(point);\n    geometrySemantics(point);\n\n    if (!requiredProperty(point, 'coordinates', 'array')) {\n      position(point.coordinates);\n    }\n  } // https://tools.ietf.org/html/rfc7946#section-3.1.6\n\n\n  function Polygon(polygon) {\n    crs(polygon);\n    bbox(polygon);\n\n    if (!requiredProperty(polygon, 'coordinates', 'array')) {\n      if (!positionArray(polygon.coordinates, 'LinearRing', 2)) {\n        rightHandRule(polygon, errors);\n      }\n    }\n  } // https://tools.ietf.org/html/rfc7946#section-3.1.7\n\n\n  function MultiPolygon(multiPolygon) {\n    crs(multiPolygon);\n    bbox(multiPolygon);\n\n    if (!requiredProperty(multiPolygon, 'coordinates', 'array')) {\n      if (!positionArray(multiPolygon.coordinates, 'LinearRing', 3)) {\n        rightHandRule(multiPolygon, errors);\n      }\n    }\n  } // https://tools.ietf.org/html/rfc7946#section-3.1.4\n\n\n  function LineString(lineString) {\n    crs(lineString);\n    bbox(lineString);\n\n    if (!requiredProperty(lineString, 'coordinates', 'array')) {\n      positionArray(lineString.coordinates, 'Line', 1);\n    }\n  } // https://tools.ietf.org/html/rfc7946#section-3.1.5\n\n\n  function MultiLineString(multiLineString) {\n    crs(multiLineString);\n    bbox(multiLineString);\n\n    if (!requiredProperty(multiLineString, 'coordinates', 'array')) {\n      positionArray(multiLineString.coordinates, 'Line', 2);\n    }\n  } // https://tools.ietf.org/html/rfc7946#section-3.1.3\n\n\n  function MultiPoint(multiPoint) {\n    crs(multiPoint);\n    bbox(multiPoint);\n\n    if (!requiredProperty(multiPoint, 'coordinates', 'array')) {\n      positionArray(multiPoint.coordinates, '', 1);\n    }\n  } // https://tools.ietf.org/html/rfc7946#section-3.1.8\n\n\n  function GeometryCollection(geometryCollection) {\n    crs(geometryCollection);\n    bbox(geometryCollection);\n\n    if (!requiredProperty(geometryCollection, 'geometries', 'array')) {\n      if (!everyIs(geometryCollection.geometries, 'object')) {\n        errors.push({\n          message: 'The geometries array in a GeometryCollection must contain only geometry objects',\n          line: geometryCollection.__line__\n        });\n      }\n\n      if (geometryCollection.geometries.length === 1) {\n        errors.push({\n          message: 'GeometryCollection with a single geometry should be avoided in favor of single part or a single object of multi-part type',\n          line: geometryCollection.geometries.__line__\n        });\n      }\n\n      geometryCollection.geometries.forEach(function (geometry) {\n        if (geometry) {\n          if (geometry.type === 'GeometryCollection') {\n            errors.push({\n              message: 'GeometryCollection should avoid nested geometry collections',\n              line: geometryCollection.geometries.__line__\n            });\n          }\n\n          root(geometry);\n        }\n      });\n    }\n  } // https://tools.ietf.org/html/rfc7946#section-3.2\n\n\n  function Feature(feature) {\n    crs(feature);\n    bbox(feature); // https://github.com/geojson/draft-geojson/blob/master/middle.mkd#feature-object\n\n    if (feature.id !== undefined && typeof feature.id !== 'string' && typeof feature.id !== 'number') {\n      errors.push({\n        message: 'Feature \"id\" member must have a string or number value',\n        line: feature.__line__\n      });\n    }\n\n    if (feature.features !== undefined) {\n      errors.push({\n        message: 'Feature object cannot contain a \"features\" member',\n        line: feature.__line__\n      });\n    }\n\n    if (feature.coordinates !== undefined) {\n      errors.push({\n        message: 'Feature object cannot contain a \"coordinates\" member',\n        line: feature.__line__\n      });\n    }\n\n    if (feature.type !== 'Feature') {\n      errors.push({\n        message: 'GeoJSON features must have a type=feature member',\n        line: feature.__line__\n      });\n    }\n\n    requiredProperty(feature, 'properties', 'object');\n\n    if (!requiredProperty(feature, 'geometry', 'object')) {\n      // https://tools.ietf.org/html/rfc7946#section-3.2\n      // tolerate null geometry\n      if (feature.geometry) root(feature.geometry);\n    }\n  }\n\n  var types = {\n    Point: Point,\n    Feature: Feature,\n    MultiPoint: MultiPoint,\n    LineString: LineString,\n    MultiLineString: MultiLineString,\n    FeatureCollection: FeatureCollection,\n    GeometryCollection: GeometryCollection,\n    Polygon: Polygon,\n    MultiPolygon: MultiPolygon\n  };\n  var typesLower = Object.keys(types).reduce(function (prev, curr) {\n    prev[curr.toLowerCase()] = curr;\n    return prev;\n  }, {});\n\n  if (typeof gj !== 'object' || gj === null || gj === undefined) {\n    errors.push({\n      message: 'The root of a GeoJSON object must be an object.',\n      line: 0\n    });\n    return errors;\n  }\n\n  root(gj);\n  errors.forEach(function (err) {\n    if ({}.hasOwnProperty.call(err, 'line') && err.line === undefined) {\n      delete err.line;\n    }\n  });\n  return errors;\n}\n\nmodule.exports.hint = hint;","map":null,"metadata":{},"sourceType":"script"}