{"ast":null,"code":"/**\r\n * @module ol/reproj/Triangulation\r\n */\nimport { boundingExtent, createEmpty, extendCoordinate, getBottomLeft, getBottomRight, getTopLeft, getTopRight, getWidth, intersects } from '../extent.js';\nimport { modulo } from '../math.js';\nimport { getTransform } from '../proj.js';\n/**\r\n * Single triangle; consists of 3 source points and 3 target points.\r\n * @typedef {Object} Triangle\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target\r\n */\n\n/**\r\n * Maximum number of subdivision steps during raster reprojection triangulation.\r\n * Prevents high memory usage and large number of proj4 calls (for certain\r\n * transformations and areas). At most `2*(2^this)` triangles are created for\r\n * each triangulated extent (tile/image).\r\n * @type {number}\r\n */\n\nvar MAX_SUBDIVISION = 10;\n/**\r\n * Maximum allowed size of triangle relative to world width. When transforming\r\n * corners of world extent between certain projections, the resulting\r\n * triangulation seems to have zero error and no subdivision is performed. If\r\n * the triangle width is more than this (relative to world width; 0-1),\r\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\r\n * @type {number}\r\n */\n\nvar MAX_TRIANGLE_WIDTH = 0.25;\n/**\r\n * @classdesc\r\n * Class containing triangulation of the given target extent.\r\n * Used for determining source data and the reprojection itself.\r\n */\n\nvar Triangulation =\n/** @class */\nfunction () {\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\r\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\r\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\r\n   * @param {number} errorThreshold Acceptable error (in source units).\r\n   */\n  function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     * @private\r\n     */\n    this.sourceProj_ = sourceProj;\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     * @private\r\n     */\n\n    this.targetProj_ = targetProj;\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n\n    var transformInvCache = {};\n    var transformInv = getTransform(this.targetProj_, this.sourceProj_);\n    /**\r\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\r\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\r\n     * @private\r\n     */\n\n    this.transformInv_ = function (c) {\n      var key = c[0] + '/' + c[1];\n\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n\n      return transformInvCache[key];\n    };\n    /**\r\n     * @type {import(\"../extent.js\").Extent}\r\n     * @private\r\n     */\n\n\n    this.maxSourceExtent_ = maxSourceExtent;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n    /**\r\n     * @type {Array<Triangle>}\r\n     * @private\r\n     */\n\n    this.triangles_ = [];\n    /**\r\n     * Indicates that the triangulation crosses edge of the source projection.\r\n     * @type {boolean}\r\n     * @private\r\n     */\n\n    this.wrapsXInSource_ = false;\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\n\n    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n    /**\r\n     * @type {?number}\r\n     * @private\r\n     */\n\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;\n    /**\r\n     * @type {?number}\r\n     * @private\r\n     */\n\n    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;\n    var destinationTopLeft = getTopLeft(targetExtent);\n    var destinationTopRight = getTopRight(targetExtent);\n    var destinationBottomRight = getBottomRight(targetExtent);\n    var destinationBottomLeft = getBottomLeft(targetExtent);\n    var sourceTopLeft = this.transformInv_(destinationTopLeft);\n    var sourceTopRight = this.transformInv_(destinationTopRight);\n    var sourceBottomRight = this.transformInv_(destinationBottomRight);\n    var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n    this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, MAX_SUBDIVISION);\n\n    if (this.wrapsXInSource_) {\n      var leftBound_1 = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n      }); // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n\n      this.triangles_.forEach(function (triangle) {\n        if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound_1 > this.sourceWorldWidth_ / 2) {\n          var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];\n\n          if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n\n          if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n\n          if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          } // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n\n\n          var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      }.bind(this));\n    }\n\n    transformInvCache = {};\n  }\n  /**\r\n   * Adds triangle to the triangulation.\r\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\r\n   * @private\r\n   */\n\n\n  Triangulation.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c]\n    });\n  };\n  /**\r\n   * Adds quad (points in clock-wise order) to the triangulation\r\n   * (and reprojects the vertices) if valid.\r\n   * Performs quad subdivision if needed to increase precision.\r\n   *\r\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\r\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\r\n   * @private\r\n   */\n\n\n  Triangulation.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    var sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n    var sourceWorldWidth =\n    /** @type {number} */\n    this.sourceWorldWidth_; // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n\n    var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;\n    var needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        var targetQuadExtent = boundingExtent([a, b, c, d]);\n        var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n        // whole quad outside source projection extent -> ignore\n        return;\n      }\n    }\n\n    if (!needsSubdivision) {\n      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          return;\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        var centerSrc = this.transformInv_(center);\n        var dx = void 0;\n\n        if (wrapsX) {\n          var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n\n        var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        var centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          var bcSrc = this.transformInv_(bc);\n          var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          var daSrc = this.transformInv_(da);\n          this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n          this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n        } else {\n          // split vertically (left & right)\n          var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          var abSrc = this.transformInv_(ab);\n          var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          var cdSrc = this.transformInv_(cd);\n          this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n          this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n        }\n\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n\n      this.wrapsXInSource_ = true;\n    }\n\n    this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);\n  };\n  /**\r\n   * Calculates extent of the 'source' coordinates from all the triangles.\r\n   *\r\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\r\n   */\n\n\n  Triangulation.prototype.calculateSourceExtent = function () {\n    var extent = createEmpty();\n    this.triangles_.forEach(function (triangle, i, arr) {\n      var src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n    return extent;\n  };\n  /**\r\n   * @return {Array<Triangle>} Array of the calculated triangles.\r\n   */\n\n\n  Triangulation.prototype.getTriangles = function () {\n    return this.triangles_;\n  };\n\n  return Triangulation;\n}();\n\nexport default Triangulation;","map":null,"metadata":{},"sourceType":"module"}