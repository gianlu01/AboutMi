{"ast":null,"code":"const throttle = require('./lib/throttle');\n\nconst toDenseArray = require('./lib/to_dense_array');\n\nconst StringSet = require('./lib/string_set');\n\nconst render = require('./render');\n\nconst interactions = require('./constants').interactions;\n\nconst Store = module.exports = function (ctx) {\n  this._features = {};\n  this._featureIds = new StringSet();\n  this._selectedFeatureIds = new StringSet();\n  this._selectedCoordinates = [];\n  this._changedFeatureIds = new StringSet();\n  this._deletedFeaturesToEmit = [];\n  this._emitSelectionChange = false;\n  this._mapInitialConfig = {};\n  this.ctx = ctx;\n  this.sources = {\n    hot: [],\n    cold: []\n  };\n  this.render = throttle(render, 16, this);\n  this.isDirty = false;\n};\n/**\n * Delays all rendering until the returned function is invoked\n * @return {Function} renderBatch\n */\n\n\nStore.prototype.createRenderBatch = function () {\n  const holdRender = this.render;\n  let numRenders = 0;\n\n  this.render = function () {\n    numRenders++;\n  };\n\n  return () => {\n    this.render = holdRender;\n\n    if (numRenders > 0) {\n      this.render();\n    }\n  };\n};\n/**\n * Sets the store's state to dirty.\n * @return {Store} this\n */\n\n\nStore.prototype.setDirty = function () {\n  this.isDirty = true;\n  return this;\n};\n/**\n * Sets a feature's state to changed.\n * @param {string} featureId\n * @return {Store} this\n */\n\n\nStore.prototype.featureChanged = function (featureId) {\n  this._changedFeatureIds.add(featureId);\n\n  return this;\n};\n/**\n * Gets the ids of all features currently in changed state.\n * @return {Store} this\n */\n\n\nStore.prototype.getChangedIds = function () {\n  return this._changedFeatureIds.values();\n};\n/**\n * Sets all features to unchanged state.\n * @return {Store} this\n */\n\n\nStore.prototype.clearChangedIds = function () {\n  this._changedFeatureIds.clear();\n\n  return this;\n};\n/**\n * Gets the ids of all features in the store.\n * @return {Store} this\n */\n\n\nStore.prototype.getAllIds = function () {\n  return this._featureIds.values();\n};\n/**\n * Adds a feature to the store.\n * @param {Object} feature\n *\n * @return {Store} this\n */\n\n\nStore.prototype.add = function (feature) {\n  this.featureChanged(feature.id);\n  this._features[feature.id] = feature;\n\n  this._featureIds.add(feature.id);\n\n  return this;\n};\n/**\n * Deletes a feature or array of features from the store.\n * Cleans up after the deletion by deselecting the features.\n * If changes were made, sets the state to the dirty\n * and fires an event.\n * @param {string | Array<string>} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\n\n\nStore.prototype.delete = function (featureIds, options = {}) {\n  toDenseArray(featureIds).forEach(id => {\n    if (!this._featureIds.has(id)) return;\n\n    this._featureIds.delete(id);\n\n    this._selectedFeatureIds.delete(id);\n\n    if (!options.silent) {\n      if (this._deletedFeaturesToEmit.indexOf(this._features[id]) === -1) {\n        this._deletedFeaturesToEmit.push(this._features[id]);\n      }\n    }\n\n    delete this._features[id];\n    this.isDirty = true;\n  });\n  refreshSelectedCoordinates.call(this, options);\n  return this;\n};\n/**\n * Returns a feature in the store matching the specified value.\n * @return {Object | undefined} feature\n */\n\n\nStore.prototype.get = function (id) {\n  return this._features[id];\n};\n/**\n * Returns all features in the store.\n * @return {Array<Object>}\n */\n\n\nStore.prototype.getAll = function () {\n  return Object.keys(this._features).map(id => this._features[id]);\n};\n/**\n * Adds features to the current selection.\n * @param {string | Array<string>} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\n\n\nStore.prototype.select = function (featureIds, options = {}) {\n  toDenseArray(featureIds).forEach(id => {\n    if (this._selectedFeatureIds.has(id)) return;\n\n    this._selectedFeatureIds.add(id);\n\n    this._changedFeatureIds.add(id);\n\n    if (!options.silent) {\n      this._emitSelectionChange = true;\n    }\n  });\n  return this;\n};\n/**\n * Deletes features from the current selection.\n * @param {string | Array<string>} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\n\n\nStore.prototype.deselect = function (featureIds, options = {}) {\n  toDenseArray(featureIds).forEach(id => {\n    if (!this._selectedFeatureIds.has(id)) return;\n\n    this._selectedFeatureIds.delete(id);\n\n    this._changedFeatureIds.add(id);\n\n    if (!options.silent) {\n      this._emitSelectionChange = true;\n    }\n  });\n  refreshSelectedCoordinates.call(this, options);\n  return this;\n};\n/**\n * Clears the current selection.\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\n\n\nStore.prototype.clearSelected = function (options = {}) {\n  this.deselect(this._selectedFeatureIds.values(), {\n    silent: options.silent\n  });\n  return this;\n};\n/**\n * Sets the store's selection, clearing any prior values.\n * If no feature ids are passed, the store is just cleared.\n * @param {string | Array<string> | undefined} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\n\n\nStore.prototype.setSelected = function (featureIds, options = {}) {\n  featureIds = toDenseArray(featureIds); // Deselect any features not in the new selection\n\n  this.deselect(this._selectedFeatureIds.values().filter(id => {\n    return featureIds.indexOf(id) === -1;\n  }), {\n    silent: options.silent\n  }); // Select any features in the new selection that were not already selected\n\n  this.select(featureIds.filter(id => {\n    return !this._selectedFeatureIds.has(id);\n  }), {\n    silent: options.silent\n  });\n  return this;\n};\n/**\n * Sets the store's coordinates selection, clearing any prior values.\n * @param {Array<Array<string>>} coordinates\n * @return {Store} this\n */\n\n\nStore.prototype.setSelectedCoordinates = function (coordinates) {\n  this._selectedCoordinates = coordinates;\n  this._emitSelectionChange = true;\n  return this;\n};\n/**\n * Clears the current coordinates selection.\n * @param {Object} [options]\n * @return {Store} this\n */\n\n\nStore.prototype.clearSelectedCoordinates = function () {\n  this._selectedCoordinates = [];\n  this._emitSelectionChange = true;\n  return this;\n};\n/**\n * Returns the ids of features in the current selection.\n * @return {Array<string>} Selected feature ids.\n */\n\n\nStore.prototype.getSelectedIds = function () {\n  return this._selectedFeatureIds.values();\n};\n/**\n * Returns features in the current selection.\n * @return {Array<Object>} Selected features.\n */\n\n\nStore.prototype.getSelected = function () {\n  return this._selectedFeatureIds.values().map(id => this.get(id));\n};\n/**\n * Returns selected coordinates in the currently selected feature.\n * @return {Array<Object>} Selected coordinates.\n */\n\n\nStore.prototype.getSelectedCoordinates = function () {\n  const selected = this._selectedCoordinates.map(coordinate => {\n    const feature = this.get(coordinate.feature_id);\n    return {\n      coordinates: feature.getCoordinate(coordinate.coord_path)\n    };\n  });\n\n  return selected;\n};\n/**\n * Indicates whether a feature is selected.\n * @param {string} featureId\n * @return {boolean} `true` if the feature is selected, `false` if not.\n */\n\n\nStore.prototype.isSelected = function (featureId) {\n  return this._selectedFeatureIds.has(featureId);\n};\n/**\n * Sets a property on the given feature\n * @param {string} featureId\n * @param {string} property property\n * @param {string} property value\n*/\n\n\nStore.prototype.setFeatureProperty = function (featureId, property, value) {\n  this.get(featureId).setProperty(property, value);\n  this.featureChanged(featureId);\n};\n\nfunction refreshSelectedCoordinates(options) {\n  const newSelectedCoordinates = this._selectedCoordinates.filter(point => this._selectedFeatureIds.has(point.feature_id));\n\n  if (this._selectedCoordinates.length !== newSelectedCoordinates.length && !options.silent) {\n    this._emitSelectionChange = true;\n  }\n\n  this._selectedCoordinates = newSelectedCoordinates;\n}\n/**\n * Stores the initial config for a map, so that we can set it again after we're done.\n*/\n\n\nStore.prototype.storeMapConfig = function () {\n  interactions.forEach(interaction => {\n    const interactionSet = this.ctx.map[interaction];\n\n    if (interactionSet) {\n      this._mapInitialConfig[interaction] = this.ctx.map[interaction].isEnabled();\n    }\n  });\n};\n/**\n * Restores the initial config for a map, ensuring all is well.\n*/\n\n\nStore.prototype.restoreMapConfig = function () {\n  Object.keys(this._mapInitialConfig).forEach(key => {\n    const value = this._mapInitialConfig[key];\n\n    if (value) {\n      this.ctx.map[key].enable();\n    } else {\n      this.ctx.map[key].disable();\n    }\n  });\n};\n/**\n * Returns the initial state of an interaction setting.\n * @param {string} interaction\n * @return {boolean} `true` if the interaction is enabled, `false` if not.\n * Defaults to `true`. (Todo: include defaults.)\n*/\n\n\nStore.prototype.getInitialConfigValue = function (interaction) {\n  if (this._mapInitialConfig[interaction] !== undefined) {\n    return this._mapInitialConfig[interaction];\n  } else {\n    // This needs to be set to whatever the default is for that interaction\n    // It seems to be true for all cases currently, so let's send back `true`.\n    return true;\n  }\n};","map":{"version":3,"sources":["C:/Users/Gianluca/Documents/Scuola/Informatica/AboutMi/Sito/AboutMi/node_modules/@mapbox/mapbox-gl-draw/src/store.js"],"names":["throttle","require","toDenseArray","StringSet","render","interactions","Store","module","exports","ctx","_features","_featureIds","_selectedFeatureIds","_selectedCoordinates","_changedFeatureIds","_deletedFeaturesToEmit","_emitSelectionChange","_mapInitialConfig","sources","hot","cold","isDirty","prototype","createRenderBatch","holdRender","numRenders","setDirty","featureChanged","featureId","add","getChangedIds","values","clearChangedIds","clear","getAllIds","feature","id","delete","featureIds","options","forEach","has","silent","indexOf","push","refreshSelectedCoordinates","call","get","getAll","Object","keys","map","select","deselect","clearSelected","setSelected","filter","setSelectedCoordinates","coordinates","clearSelectedCoordinates","getSelectedIds","getSelected","getSelectedCoordinates","selected","coordinate","feature_id","getCoordinate","coord_path","isSelected","setFeatureProperty","property","value","setProperty","newSelectedCoordinates","point","length","storeMapConfig","interaction","interactionSet","isEnabled","restoreMapConfig","key","enable","disable","getInitialConfigValue","undefined"],"mappings":"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","sourcesContent":["const throttle = require('./lib/throttle');\nconst toDenseArray = require('./lib/to_dense_array');\nconst StringSet = require('./lib/string_set');\nconst render = require('./render');\nconst interactions = require('./constants').interactions;\n\nconst Store = module.exports = function(ctx) {\n  this._features = {};\n  this._featureIds = new StringSet();\n  this._selectedFeatureIds = new StringSet();\n  this._selectedCoordinates = [];\n  this._changedFeatureIds = new StringSet();\n  this._deletedFeaturesToEmit = [];\n  this._emitSelectionChange = false;\n  this._mapInitialConfig = {};\n  this.ctx = ctx;\n  this.sources = {\n    hot: [],\n    cold: []\n  };\n  this.render = throttle(render, 16, this);\n  this.isDirty = false;\n};\n\n\n/**\n * Delays all rendering until the returned function is invoked\n * @return {Function} renderBatch\n */\nStore.prototype.createRenderBatch = function() {\n  const holdRender = this.render;\n  let numRenders = 0;\n  this.render = function() {\n    numRenders++;\n  };\n\n  return () => {\n    this.render = holdRender;\n    if (numRenders > 0) {\n      this.render();\n    }\n  };\n};\n\n/**\n * Sets the store's state to dirty.\n * @return {Store} this\n */\nStore.prototype.setDirty = function() {\n  this.isDirty = true;\n  return this;\n};\n\n/**\n * Sets a feature's state to changed.\n * @param {string} featureId\n * @return {Store} this\n */\nStore.prototype.featureChanged = function(featureId) {\n  this._changedFeatureIds.add(featureId);\n  return this;\n};\n\n/**\n * Gets the ids of all features currently in changed state.\n * @return {Store} this\n */\nStore.prototype.getChangedIds = function() {\n  return this._changedFeatureIds.values();\n};\n\n/**\n * Sets all features to unchanged state.\n * @return {Store} this\n */\nStore.prototype.clearChangedIds = function() {\n  this._changedFeatureIds.clear();\n  return this;\n};\n\n/**\n * Gets the ids of all features in the store.\n * @return {Store} this\n */\nStore.prototype.getAllIds = function() {\n  return this._featureIds.values();\n};\n\n/**\n * Adds a feature to the store.\n * @param {Object} feature\n *\n * @return {Store} this\n */\nStore.prototype.add = function(feature) {\n  this.featureChanged(feature.id);\n  this._features[feature.id] = feature;\n  this._featureIds.add(feature.id);\n  return this;\n};\n\n/**\n * Deletes a feature or array of features from the store.\n * Cleans up after the deletion by deselecting the features.\n * If changes were made, sets the state to the dirty\n * and fires an event.\n * @param {string | Array<string>} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\nStore.prototype.delete = function(featureIds, options = {}) {\n  toDenseArray(featureIds).forEach(id => {\n    if (!this._featureIds.has(id)) return;\n    this._featureIds.delete(id);\n    this._selectedFeatureIds.delete(id);\n    if (!options.silent) {\n      if (this._deletedFeaturesToEmit.indexOf(this._features[id]) === -1) {\n        this._deletedFeaturesToEmit.push(this._features[id]);\n      }\n    }\n    delete this._features[id];\n    this.isDirty = true;\n  });\n  refreshSelectedCoordinates.call(this, options);\n  return this;\n};\n\n/**\n * Returns a feature in the store matching the specified value.\n * @return {Object | undefined} feature\n */\nStore.prototype.get = function(id) {\n  return this._features[id];\n};\n\n/**\n * Returns all features in the store.\n * @return {Array<Object>}\n */\nStore.prototype.getAll = function() {\n  return Object.keys(this._features).map(id => this._features[id]);\n};\n\n/**\n * Adds features to the current selection.\n * @param {string | Array<string>} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\nStore.prototype.select = function(featureIds, options = {}) {\n  toDenseArray(featureIds).forEach(id => {\n    if (this._selectedFeatureIds.has(id)) return;\n    this._selectedFeatureIds.add(id);\n    this._changedFeatureIds.add(id);\n    if (!options.silent) {\n      this._emitSelectionChange = true;\n    }\n  });\n  return this;\n};\n\n/**\n * Deletes features from the current selection.\n * @param {string | Array<string>} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\nStore.prototype.deselect = function(featureIds, options = {}) {\n  toDenseArray(featureIds).forEach(id => {\n    if (!this._selectedFeatureIds.has(id)) return;\n    this._selectedFeatureIds.delete(id);\n    this._changedFeatureIds.add(id);\n    if (!options.silent) {\n      this._emitSelectionChange = true;\n    }\n  });\n  refreshSelectedCoordinates.call(this, options);\n  return this;\n};\n\n/**\n * Clears the current selection.\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\nStore.prototype.clearSelected = function(options = {}) {\n  this.deselect(this._selectedFeatureIds.values(), { silent: options.silent });\n  return this;\n};\n\n/**\n * Sets the store's selection, clearing any prior values.\n * If no feature ids are passed, the store is just cleared.\n * @param {string | Array<string> | undefined} featureIds\n * @param {Object} [options]\n * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.\n * @return {Store} this\n */\nStore.prototype.setSelected = function(featureIds, options = {}) {\n  featureIds = toDenseArray(featureIds);\n\n  // Deselect any features not in the new selection\n  this.deselect(this._selectedFeatureIds.values().filter(id => {\n    return featureIds.indexOf(id) === -1;\n  }), { silent: options.silent });\n\n  // Select any features in the new selection that were not already selected\n  this.select(featureIds.filter(id => {\n    return !this._selectedFeatureIds.has(id);\n  }), { silent: options.silent });\n\n  return this;\n};\n\n/**\n * Sets the store's coordinates selection, clearing any prior values.\n * @param {Array<Array<string>>} coordinates\n * @return {Store} this\n */\nStore.prototype.setSelectedCoordinates = function(coordinates) {\n  this._selectedCoordinates = coordinates;\n  this._emitSelectionChange = true;\n  return this;\n};\n\n/**\n * Clears the current coordinates selection.\n * @param {Object} [options]\n * @return {Store} this\n */\nStore.prototype.clearSelectedCoordinates = function() {\n  this._selectedCoordinates = [];\n  this._emitSelectionChange = true;\n  return this;\n};\n\n/**\n * Returns the ids of features in the current selection.\n * @return {Array<string>} Selected feature ids.\n */\nStore.prototype.getSelectedIds = function() {\n  return this._selectedFeatureIds.values();\n};\n\n/**\n * Returns features in the current selection.\n * @return {Array<Object>} Selected features.\n */\nStore.prototype.getSelected = function() {\n  return this._selectedFeatureIds.values().map(id => this.get(id));\n};\n\n/**\n * Returns selected coordinates in the currently selected feature.\n * @return {Array<Object>} Selected coordinates.\n */\nStore.prototype.getSelectedCoordinates = function() {\n  const selected = this._selectedCoordinates.map(coordinate => {\n    const feature = this.get(coordinate.feature_id);\n    return {\n      coordinates: feature.getCoordinate(coordinate.coord_path)\n    };\n  });\n  return selected;\n};\n\n/**\n * Indicates whether a feature is selected.\n * @param {string} featureId\n * @return {boolean} `true` if the feature is selected, `false` if not.\n */\nStore.prototype.isSelected = function(featureId) {\n  return this._selectedFeatureIds.has(featureId);\n};\n\n/**\n * Sets a property on the given feature\n * @param {string} featureId\n * @param {string} property property\n * @param {string} property value\n*/\nStore.prototype.setFeatureProperty = function(featureId, property, value) {\n  this.get(featureId).setProperty(property, value);\n  this.featureChanged(featureId);\n};\n\nfunction refreshSelectedCoordinates(options) {\n  const newSelectedCoordinates = this._selectedCoordinates.filter(point => this._selectedFeatureIds.has(point.feature_id));\n  if (this._selectedCoordinates.length !== newSelectedCoordinates.length && !options.silent) {\n    this._emitSelectionChange = true;\n  }\n  this._selectedCoordinates = newSelectedCoordinates;\n}\n\n/**\n * Stores the initial config for a map, so that we can set it again after we're done.\n*/\nStore.prototype.storeMapConfig = function() {\n  interactions.forEach((interaction) => {\n    const interactionSet = this.ctx.map[interaction];\n    if (interactionSet) {\n      this._mapInitialConfig[interaction] = this.ctx.map[interaction].isEnabled();\n    }\n  });\n};\n\n/**\n * Restores the initial config for a map, ensuring all is well.\n*/\nStore.prototype.restoreMapConfig = function() {\n  Object.keys(this._mapInitialConfig).forEach(key => {\n    const value = this._mapInitialConfig[key];\n    if (value) {\n      this.ctx.map[key].enable();\n    } else {\n      this.ctx.map[key].disable();\n    }\n  });\n};\n\n/**\n * Returns the initial state of an interaction setting.\n * @param {string} interaction\n * @return {boolean} `true` if the interaction is enabled, `false` if not.\n * Defaults to `true`. (Todo: include defaults.)\n*/\nStore.prototype.getInitialConfigValue = function(interaction) {\n  if (this._mapInitialConfig[interaction] !== undefined) {\n    return this._mapInitialConfig[interaction];\n  } else {\n    // This needs to be set to whatever the default is for that interaction\n    // It seems to be true for all cases currently, so let's send back `true`.\n    return true;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}