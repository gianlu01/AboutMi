{"ast":null,"code":"const extent = require('@mapbox/geojson-extent');\n\nconst Constants = require('../constants');\n\nconst {\n  LAT_MIN,\n  LAT_MAX,\n  LAT_RENDERED_MIN,\n  LAT_RENDERED_MAX,\n  LNG_MIN,\n  LNG_MAX\n} = Constants; // Ensure that we do not drag north-south far enough for\n// - any part of any feature to exceed the poles\n// - any feature to be completely lost in the space between the projection's\n//   edge and the poles, such that it couldn't be re-selected and moved back\n\nmodule.exports = function (geojsonFeatures, delta) {\n  // \"inner edge\" = a feature's latitude closest to the equator\n  let northInnerEdge = LAT_MIN;\n  let southInnerEdge = LAT_MAX; // \"outer edge\" = a feature's latitude furthest from the equator\n\n  let northOuterEdge = LAT_MIN;\n  let southOuterEdge = LAT_MAX;\n  let westEdge = LNG_MAX;\n  let eastEdge = LNG_MIN;\n  geojsonFeatures.forEach(feature => {\n    const bounds = extent(feature);\n    const featureSouthEdge = bounds[1];\n    const featureNorthEdge = bounds[3];\n    const featureWestEdge = bounds[0];\n    const featureEastEdge = bounds[2];\n    if (featureSouthEdge > northInnerEdge) northInnerEdge = featureSouthEdge;\n    if (featureNorthEdge < southInnerEdge) southInnerEdge = featureNorthEdge;\n    if (featureNorthEdge > northOuterEdge) northOuterEdge = featureNorthEdge;\n    if (featureSouthEdge < southOuterEdge) southOuterEdge = featureSouthEdge;\n    if (featureWestEdge < westEdge) westEdge = featureWestEdge;\n    if (featureEastEdge > eastEdge) eastEdge = featureEastEdge;\n  }); // These changes are not mutually exclusive: we might hit the inner\n  // edge but also have hit the outer edge and therefore need\n  // another readjustment\n\n  const constrainedDelta = delta;\n\n  if (northInnerEdge + constrainedDelta.lat > LAT_RENDERED_MAX) {\n    constrainedDelta.lat = LAT_RENDERED_MAX - northInnerEdge;\n  }\n\n  if (northOuterEdge + constrainedDelta.lat > LAT_MAX) {\n    constrainedDelta.lat = LAT_MAX - northOuterEdge;\n  }\n\n  if (southInnerEdge + constrainedDelta.lat < LAT_RENDERED_MIN) {\n    constrainedDelta.lat = LAT_RENDERED_MIN - southInnerEdge;\n  }\n\n  if (southOuterEdge + constrainedDelta.lat < LAT_MIN) {\n    constrainedDelta.lat = LAT_MIN - southOuterEdge;\n  }\n\n  if (westEdge + constrainedDelta.lng <= LNG_MIN) {\n    constrainedDelta.lng += Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;\n  }\n\n  if (eastEdge + constrainedDelta.lng >= LNG_MAX) {\n    constrainedDelta.lng -= Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;\n  }\n\n  return constrainedDelta;\n};","map":{"version":3,"sources":["C:/Users/Gianluca/Documents/Scuola/Informatica/AboutMi/Sito/AboutMi/node_modules/@mapbox/mapbox-gl-draw/src/lib/constrain_feature_movement.js"],"names":["extent","require","Constants","LAT_MIN","LAT_MAX","LAT_RENDERED_MIN","LAT_RENDERED_MAX","LNG_MIN","LNG_MAX","module","exports","geojsonFeatures","delta","northInnerEdge","southInnerEdge","northOuterEdge","southOuterEdge","westEdge","eastEdge","forEach","feature","bounds","featureSouthEdge","featureNorthEdge","featureWestEdge","featureEastEdge","constrainedDelta","lat","lng","Math","ceil","abs"],"mappings":"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","sourcesContent":["const extent = require('@mapbox/geojson-extent');\nconst Constants = require('../constants');\n\nconst {\n  LAT_MIN,\n  LAT_MAX,\n  LAT_RENDERED_MIN,\n  LAT_RENDERED_MAX,\n  LNG_MIN,\n  LNG_MAX\n} = Constants;\n\n// Ensure that we do not drag north-south far enough for\n// - any part of any feature to exceed the poles\n// - any feature to be completely lost in the space between the projection's\n//   edge and the poles, such that it couldn't be re-selected and moved back\nmodule.exports = function(geojsonFeatures, delta) {\n  // \"inner edge\" = a feature's latitude closest to the equator\n  let northInnerEdge = LAT_MIN;\n  let southInnerEdge = LAT_MAX;\n  // \"outer edge\" = a feature's latitude furthest from the equator\n  let northOuterEdge = LAT_MIN;\n  let southOuterEdge = LAT_MAX;\n\n  let westEdge = LNG_MAX;\n  let eastEdge = LNG_MIN;\n\n  geojsonFeatures.forEach(feature => {\n    const bounds = extent(feature);\n    const featureSouthEdge = bounds[1];\n    const featureNorthEdge = bounds[3];\n    const featureWestEdge = bounds[0];\n    const featureEastEdge = bounds[2];\n    if (featureSouthEdge > northInnerEdge) northInnerEdge = featureSouthEdge;\n    if (featureNorthEdge < southInnerEdge) southInnerEdge = featureNorthEdge;\n    if (featureNorthEdge > northOuterEdge) northOuterEdge = featureNorthEdge;\n    if (featureSouthEdge < southOuterEdge) southOuterEdge = featureSouthEdge;\n    if (featureWestEdge < westEdge) westEdge = featureWestEdge;\n    if (featureEastEdge > eastEdge) eastEdge = featureEastEdge;\n  });\n\n\n  // These changes are not mutually exclusive: we might hit the inner\n  // edge but also have hit the outer edge and therefore need\n  // another readjustment\n  const constrainedDelta = delta;\n  if (northInnerEdge + constrainedDelta.lat > LAT_RENDERED_MAX) {\n    constrainedDelta.lat = LAT_RENDERED_MAX - northInnerEdge;\n  }\n  if (northOuterEdge + constrainedDelta.lat > LAT_MAX) {\n    constrainedDelta.lat = LAT_MAX - northOuterEdge;\n  }\n  if (southInnerEdge + constrainedDelta.lat < LAT_RENDERED_MIN) {\n    constrainedDelta.lat = LAT_RENDERED_MIN - southInnerEdge;\n  }\n  if (southOuterEdge + constrainedDelta.lat < LAT_MIN) {\n    constrainedDelta.lat = LAT_MIN - southOuterEdge;\n  }\n  if (westEdge + constrainedDelta.lng <= LNG_MIN) {\n    constrainedDelta.lng += Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;\n  }\n  if (eastEdge + constrainedDelta.lng >= LNG_MAX) {\n    constrainedDelta.lng -= Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;\n  }\n\n  return constrainedDelta;\n};\n"]},"metadata":{},"sourceType":"script"}