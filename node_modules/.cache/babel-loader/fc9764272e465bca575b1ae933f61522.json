{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\r\n * @module ol/renderer/Layer\r\n */\n\n\nimport { abstract } from '../util.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport EventType from '../events/EventType.js';\nimport SourceState from '../source/State.js';\n/**\r\n * @template {import(\"../layer/Layer.js\").default} LayerType\r\n */\n\nvar LayerRenderer =\n/** @class */\nfunction (_super) {\n  __extends(LayerRenderer, _super);\n  /**\r\n   * @param {LayerType} layer Layer.\r\n   */\n\n\n  function LayerRenderer(layer) {\n    var _this = _super.call(this) || this;\n    /** @private */\n\n\n    _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);\n    /**\r\n     * @private\r\n     * @type {LayerType}\r\n     */\n\n    _this.layer_ = layer;\n    return _this;\n  }\n  /**\r\n   * Asynchronous layer level hit detection.\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Promise<Array<import(\"../Feature\").default>>} Promise that resolves with\r\n   * an array of features.\r\n   */\n\n\n  LayerRenderer.prototype.getFeatures = function (pixel) {\n    return abstract();\n  };\n  /**\r\n   * Determine whether render should be called.\r\n   * @abstract\r\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   */\n\n\n  LayerRenderer.prototype.prepareFrame = function (frameState) {\n    return abstract();\n  };\n  /**\r\n   * Render the layer.\r\n   * @abstract\r\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement} target Target that may be used to render content to.\r\n   * @return {HTMLElement} The rendered element.\r\n   */\n\n\n  LayerRenderer.prototype.renderFrame = function (frameState, target) {\n    return abstract();\n  };\n  /**\r\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\r\n   * @param {number} zoom Zoom level.\r\n   * @param {import(\"../Tile.js\").default} tile Tile.\r\n   */\n\n\n  LayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {\n    if (!tiles[zoom]) {\n      tiles[zoom] = {};\n    }\n\n    tiles[zoom][tile.tileCoord.toString()] = tile;\n  };\n  /**\r\n   * Create a function that adds loaded tiles to the tile lookup.\r\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\r\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\r\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\r\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\r\n   * @protected\r\n   */\n\n\n  LayerRenderer.prototype.createLoadedTileFinder = function (source, projection, tiles) {\n    return (\n      /**\r\n       * @param {number} zoom Zoom level.\r\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\r\n       * @return {boolean} The tile range is fully loaded.\r\n       * @this {LayerRenderer}\r\n       */\n      function (zoom, tileRange) {\n        var callback = this.loadedTileCallback.bind(this, tiles, zoom);\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }.bind(this)\n    );\n  };\n  /**\r\n   * @abstract\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\r\n   * @param {number} hitTolerance Hit tolerance in pixels.\r\n   * @param {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default): T} callback Feature callback.\r\n   * @param {Array<import(\"../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\r\n   * @return {T|void} Callback result.\r\n   * @template T\r\n   */\n\n\n  LayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, declutteredFeatures) {};\n  /**\r\n   * @abstract\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\r\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\r\n   * @param {number} hitTolerance Hit tolerance in pixels.\r\n   * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel\r\n   *    location, null will be returned.  If there is data, but pixel values cannot be\r\n   *    returned, and empty array will be returned.\r\n   */\n\n\n  LayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {\n    return abstract();\n  };\n  /**\r\n   * @return {LayerType} Layer.\r\n   */\n\n\n  LayerRenderer.prototype.getLayer = function () {\n    return this.layer_;\n  };\n  /**\r\n   * Perform action necessary to get the layer rendered after new fonts have loaded\r\n   * @abstract\r\n   */\n\n\n  LayerRenderer.prototype.handleFontsChanged = function () {};\n  /**\r\n   * Handle changes in image state.\r\n   * @param {import(\"../events/Event.js\").default} event Image change event.\r\n   * @private\r\n   */\n\n\n  LayerRenderer.prototype.handleImageChange_ = function (event) {\n    var image =\n    /** @type {import(\"../Image.js\").default} */\n    event.target;\n\n    if (image.getState() === ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  };\n  /**\r\n   * Load the image if not already loaded, and register the image change\r\n   * listener if needed.\r\n   * @param {import(\"../ImageBase.js\").default} image Image.\r\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\r\n   * @protected\r\n   */\n\n\n  LayerRenderer.prototype.loadImage = function (image) {\n    var imageState = image.getState();\n\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n\n    return imageState == ImageState.LOADED;\n  };\n  /**\r\n   * @protected\r\n   */\n\n\n  LayerRenderer.prototype.renderIfReadyAndVisible = function () {\n    var layer = this.getLayer();\n\n    if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {\n      layer.changed();\n    }\n  };\n\n  return LayerRenderer;\n}(Observable);\n\nexport default LayerRenderer;","map":null,"metadata":{},"sourceType":"module"}