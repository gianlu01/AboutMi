{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\r\n * @module ol/Observable\r\n */\n\n\nimport { listen, unlistenByKey, listenOnce } from './events.js';\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * An event target providing convenient methods for listener registration\r\n * and unregistration. A generic `change` event is always available through\r\n * {@link module:ol/Observable~Observable#changed}.\r\n *\r\n * @fires import(\"./events/Event.js\").default\r\n * @api\r\n */\n\nvar Observable =\n/** @class */\nfunction (_super) {\n  __extends(Observable, _super);\n\n  function Observable() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n\n\n    _this.revision_ = 0;\n    return _this;\n  }\n  /**\r\n   * Increases the revision counter and dispatches a 'change' event.\r\n   * @api\r\n   */\n\n\n  Observable.prototype.changed = function () {\n    ++this.revision_;\n    this.dispatchEvent(EventType.CHANGE);\n  };\n  /**\r\n   * Get the version number for this object.  Each time the object is modified,\r\n   * its version number will be incremented.\r\n   * @return {number} Revision.\r\n   * @api\r\n   */\n\n\n  Observable.prototype.getRevision = function () {\n    return this.revision_;\n  };\n  /**\r\n   * Listen for a certain type of event.\r\n   * @param {string|Array<string>} type The event type or array of event types.\r\n   * @param {function(?): ?} listener The listener function.\r\n   * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\r\n   *     called with an array of event types as the first argument, the return\r\n   *     will be an array of keys.\r\n   * @api\r\n   */\n\n\n  Observable.prototype.on = function (type, listener) {\n    if (Array.isArray(type)) {\n      var len = type.length;\n      var keys = new Array(len);\n\n      for (var i = 0; i < len; ++i) {\n        keys[i] = listen(this, type[i], listener);\n      }\n\n      return keys;\n    } else {\n      return listen(this,\n      /** @type {string} */\n      type, listener);\n    }\n  };\n  /**\r\n   * Listen once for a certain type of event.\r\n   * @param {string|Array<string>} type The event type or array of event types.\r\n   * @param {function(?): ?} listener The listener function.\r\n   * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\r\n   *     called with an array of event types as the first argument, the return\r\n   *     will be an array of keys.\r\n   * @api\r\n   */\n\n\n  Observable.prototype.once = function (type, listener) {\n    if (Array.isArray(type)) {\n      var len = type.length;\n      var keys = new Array(len);\n\n      for (var i = 0; i < len; ++i) {\n        keys[i] = listenOnce(this, type[i], listener);\n      }\n\n      return keys;\n    } else {\n      return listenOnce(this,\n      /** @type {string} */\n      type, listener);\n    }\n  };\n  /**\r\n   * Unlisten for a certain type of event.\r\n   * @param {string|Array<string>} type The event type or array of event types.\r\n   * @param {function(?): ?} listener The listener function.\r\n   * @api\r\n   */\n\n\n  Observable.prototype.un = function (type, listener) {\n    if (Array.isArray(type)) {\n      for (var i = 0, ii = type.length; i < ii; ++i) {\n        this.removeEventListener(type[i], listener);\n      }\n    } else {\n      this.removeEventListener(type, listener);\n    }\n  };\n\n  return Observable;\n}(EventTarget);\n/**\r\n * Removes an event listener using the key returned by `on()` or `once()`.\r\n * @param {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} key The key returned by `on()`\r\n *     or `once()` (or an array of keys).\r\n * @api\r\n */\n\n\nexport function unByKey(key) {\n  if (Array.isArray(key)) {\n    for (var i = 0, ii = key.length; i < ii; ++i) {\n      unlistenByKey(key[i]);\n    }\n  } else {\n    unlistenByKey(\n    /** @type {import(\"./events.js\").EventsKey} */\n    key);\n  }\n}\nexport default Observable;","map":null,"metadata":{},"sourceType":"module"}