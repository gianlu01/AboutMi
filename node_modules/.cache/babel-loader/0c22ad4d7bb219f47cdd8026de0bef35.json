{"ast":null,"code":"/**\n * martinez v0.4.3\n * Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor\n *\n * @author Alex Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.martinez = {});\n})(this, function (exports) {\n  'use strict';\n\n  function DEFAULT_COMPARE(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  var SplayTree = function SplayTree(compare, noDuplicates) {\n    if (compare === void 0) compare = DEFAULT_COMPARE;\n    if (noDuplicates === void 0) noDuplicates = false;\n    this._compare = compare;\n    this._root = null;\n    this._size = 0;\n    this._noDuplicates = !!noDuplicates;\n  };\n\n  var prototypeAccessors = {\n    size: {\n      configurable: true\n    }\n  };\n\n  SplayTree.prototype.rotateLeft = function rotateLeft(x) {\n    var y = x.right;\n\n    if (y) {\n      x.right = y.left;\n\n      if (y.left) {\n        y.left.parent = x;\n      }\n\n      y.parent = x.parent;\n    }\n\n    if (!x.parent) {\n      this._root = y;\n    } else if (x === x.parent.left) {\n      x.parent.left = y;\n    } else {\n      x.parent.right = y;\n    }\n\n    if (y) {\n      y.left = x;\n    }\n\n    x.parent = y;\n  };\n\n  SplayTree.prototype.rotateRight = function rotateRight(x) {\n    var y = x.left;\n\n    if (y) {\n      x.left = y.right;\n\n      if (y.right) {\n        y.right.parent = x;\n      }\n\n      y.parent = x.parent;\n    }\n\n    if (!x.parent) {\n      this._root = y;\n    } else if (x === x.parent.left) {\n      x.parent.left = y;\n    } else {\n      x.parent.right = y;\n    }\n\n    if (y) {\n      y.right = x;\n    }\n\n    x.parent = y;\n  };\n\n  SplayTree.prototype._splay = function _splay(x) {\n    var this$1 = this;\n\n    while (x.parent) {\n      var p = x.parent;\n\n      if (!p.parent) {\n        if (p.left === x) {\n          this$1.rotateRight(p);\n        } else {\n          this$1.rotateLeft(p);\n        }\n      } else if (p.left === x && p.parent.left === p) {\n        this$1.rotateRight(p.parent);\n        this$1.rotateRight(p);\n      } else if (p.right === x && p.parent.right === p) {\n        this$1.rotateLeft(p.parent);\n        this$1.rotateLeft(p);\n      } else if (p.left === x && p.parent.right === p) {\n        this$1.rotateRight(p);\n        this$1.rotateLeft(p);\n      } else {\n        this$1.rotateLeft(p);\n        this$1.rotateRight(p);\n      }\n    }\n  };\n\n  SplayTree.prototype.splay = function splay(x) {\n    var this$1 = this;\n    var p, gp, ggp, l, r;\n\n    while (x.parent) {\n      p = x.parent;\n      gp = p.parent;\n\n      if (gp && gp.parent) {\n        ggp = gp.parent;\n\n        if (ggp.left === gp) {\n          ggp.left = x;\n        } else {\n          ggp.right = x;\n        }\n\n        x.parent = ggp;\n      } else {\n        x.parent = null;\n        this$1._root = x;\n      }\n\n      l = x.left;\n      r = x.right;\n\n      if (x === p.left) {\n        // left\n        if (gp) {\n          if (gp.left === p) {\n            /* zig-zig */\n            if (p.right) {\n              gp.left = p.right;\n              gp.left.parent = gp;\n            } else {\n              gp.left = null;\n            }\n\n            p.right = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (l) {\n              gp.right = l;\n              l.parent = gp;\n            } else {\n              gp.right = null;\n            }\n\n            x.left = gp;\n            gp.parent = x;\n          }\n        }\n\n        if (r) {\n          p.left = r;\n          r.parent = p;\n        } else {\n          p.left = null;\n        }\n\n        x.right = p;\n        p.parent = x;\n      } else {\n        // right\n        if (gp) {\n          if (gp.right === p) {\n            /* zig-zig */\n            if (p.left) {\n              gp.right = p.left;\n              gp.right.parent = gp;\n            } else {\n              gp.right = null;\n            }\n\n            p.left = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (r) {\n              gp.left = r;\n              r.parent = gp;\n            } else {\n              gp.left = null;\n            }\n\n            x.right = gp;\n            gp.parent = x;\n          }\n        }\n\n        if (l) {\n          p.right = l;\n          l.parent = p;\n        } else {\n          p.right = null;\n        }\n\n        x.left = p;\n        p.parent = x;\n      }\n    }\n  };\n\n  SplayTree.prototype.replace = function replace(u, v) {\n    if (!u.parent) {\n      this._root = v;\n    } else if (u === u.parent.left) {\n      u.parent.left = v;\n    } else {\n      u.parent.right = v;\n    }\n\n    if (v) {\n      v.parent = u.parent;\n    }\n  };\n\n  SplayTree.prototype.minNode = function minNode(u) {\n    if (u === void 0) u = this._root;\n\n    if (u) {\n      while (u.left) {\n        u = u.left;\n      }\n    }\n\n    return u;\n  };\n\n  SplayTree.prototype.maxNode = function maxNode(u) {\n    if (u === void 0) u = this._root;\n\n    if (u) {\n      while (u.right) {\n        u = u.right;\n      }\n    }\n\n    return u;\n  };\n\n  SplayTree.prototype.insert = function insert(key, data) {\n    var z = this._root;\n    var p = null;\n    var comp = this._compare;\n    var cmp;\n\n    if (this._noDuplicates) {\n      while (z) {\n        p = z;\n        cmp = comp(z.key, key);\n\n        if (cmp === 0) {\n          return;\n        } else if (comp(z.key, key) < 0) {\n          z = z.right;\n        } else {\n          z = z.left;\n        }\n      }\n    } else {\n      while (z) {\n        p = z;\n\n        if (comp(z.key, key) < 0) {\n          z = z.right;\n        } else {\n          z = z.left;\n        }\n      }\n    }\n\n    z = {\n      key: key,\n      data: data,\n      left: null,\n      right: null,\n      parent: p\n    };\n\n    if (!p) {\n      this._root = z;\n    } else if (comp(p.key, z.key) < 0) {\n      p.right = z;\n    } else {\n      p.left = z;\n    }\n\n    this.splay(z);\n    this._size++;\n    return z;\n  };\n\n  SplayTree.prototype.find = function find(key) {\n    var z = this._root;\n    var comp = this._compare;\n\n    while (z) {\n      var cmp = comp(z.key, key);\n\n      if (cmp < 0) {\n        z = z.right;\n      } else if (cmp > 0) {\n        z = z.left;\n      } else {\n        return z;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Whether the tree contains a node with the given key\n   * @param{Key} key\n   * @return {boolean} true/false\n   */\n\n\n  SplayTree.prototype.contains = function contains(key) {\n    var node = this._root;\n    var comparator = this._compare;\n\n    while (node) {\n      var cmp = comparator(key, node.key);\n\n      if (cmp === 0) {\n        return true;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else {\n        node = node.right;\n      }\n    }\n\n    return false;\n  };\n\n  SplayTree.prototype.remove = function remove(key) {\n    var z = this.find(key);\n\n    if (!z) {\n      return false;\n    }\n\n    this.splay(z);\n\n    if (!z.left) {\n      this.replace(z, z.right);\n    } else if (!z.right) {\n      this.replace(z, z.left);\n    } else {\n      var y = this.minNode(z.right);\n\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  };\n\n  SplayTree.prototype.removeNode = function removeNode(z) {\n    if (!z) {\n      return false;\n    }\n\n    this.splay(z);\n\n    if (!z.left) {\n      this.replace(z, z.right);\n    } else if (!z.right) {\n      this.replace(z, z.left);\n    } else {\n      var y = this.minNode(z.right);\n\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  };\n\n  SplayTree.prototype.erase = function erase(key) {\n    var z = this.find(key);\n\n    if (!z) {\n      return;\n    }\n\n    this.splay(z);\n    var s = z.left;\n    var t = z.right;\n    var sMax = null;\n\n    if (s) {\n      s.parent = null;\n      sMax = this.maxNode(s);\n      this.splay(sMax);\n      this._root = sMax;\n    }\n\n    if (t) {\n      if (s) {\n        sMax.right = t;\n      } else {\n        this._root = t;\n      }\n\n      t.parent = sMax;\n    }\n\n    this._size--;\n  };\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n\n\n  SplayTree.prototype.pop = function pop() {\n    var node = this._root,\n        returnValue = null;\n\n    if (node) {\n      while (node.left) {\n        node = node.left;\n      }\n\n      returnValue = {\n        key: node.key,\n        data: node.data\n      };\n      this.remove(node.key);\n    }\n\n    return returnValue;\n  };\n  /* eslint-disable class-methods-use-this */\n\n  /**\n   * Successor node\n   * @param{Node} node\n   * @return {?Node}\n   */\n\n\n  SplayTree.prototype.next = function next(node) {\n    var successor = node;\n\n    if (successor) {\n      if (successor.right) {\n        successor = successor.right;\n\n        while (successor && successor.left) {\n          successor = successor.left;\n        }\n      } else {\n        successor = node.parent;\n\n        while (successor && successor.right === node) {\n          node = successor;\n          successor = successor.parent;\n        }\n      }\n    }\n\n    return successor;\n  };\n  /**\n   * Predecessor node\n   * @param{Node} node\n   * @return {?Node}\n   */\n\n\n  SplayTree.prototype.prev = function prev(node) {\n    var predecessor = node;\n\n    if (predecessor) {\n      if (predecessor.left) {\n        predecessor = predecessor.left;\n\n        while (predecessor && predecessor.right) {\n          predecessor = predecessor.right;\n        }\n      } else {\n        predecessor = node.parent;\n\n        while (predecessor && predecessor.left === node) {\n          node = predecessor;\n          predecessor = predecessor.parent;\n        }\n      }\n    }\n\n    return predecessor;\n  };\n  /* eslint-enable class-methods-use-this */\n\n  /**\n   * @param{forEachCallback} callback\n   * @return {SplayTree}\n   */\n\n\n  SplayTree.prototype.forEach = function forEach(callback) {\n    var current = this._root;\n    var s = [],\n        done = false,\n        i = 0;\n\n    while (!done) {\n      // Reach the left most Node of the current Node\n      if (current) {\n        // Place pointer to a tree node on the stack\n        // before traversing the node's left subtree\n        s.push(current);\n        current = current.left;\n      } else {\n        // BackTrack from the empty subtree and visit the Node\n        // at the top of the stack; however, if the stack is\n        // empty you are done\n        if (s.length > 0) {\n          current = s.pop();\n          callback(current, i++); // We have visited the node and its left\n          // subtree. Now, it's right subtree's turn\n\n          current = current.right;\n        } else {\n          done = true;\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param{Key}    low\n   * @param{Key}    high\n   * @param{Function} fn\n   * @param{*?}     ctx\n   * @return {SplayTree}\n   */\n\n\n  SplayTree.prototype.range = function range(low, high, fn, ctx) {\n    var this$1 = this;\n    var Q = [];\n    var compare = this._compare;\n    var node = this._root,\n        cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) {\n            return this$1;\n          } // stop if smth is returned\n\n        }\n\n        node = node.right;\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Returns all keys in order\n   * @return {Array<Key>}\n   */\n\n\n  SplayTree.prototype.keys = function keys() {\n    var current = this._root;\n    var s = [],\n        r = [],\n        done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.key);\n          current = current.right;\n        } else {\n          done = true;\n        }\n      }\n    }\n\n    return r;\n  };\n  /**\n   * Returns `data` fields of all nodes in order.\n   * @return {Array<Value>}\n   */\n\n\n  SplayTree.prototype.values = function values() {\n    var current = this._root;\n    var s = [],\n        r = [],\n        done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.data);\n          current = current.right;\n        } else {\n          done = true;\n        }\n      }\n    }\n\n    return r;\n  };\n  /**\n   * Returns node at given index\n   * @param{number} index\n   * @return {?Node}\n   */\n\n\n  SplayTree.prototype.at = function at(index) {\n    // removed after a consideration, more misleading than useful\n    // index = index % this.size;\n    // if (index < 0) index = this.size - index;\n    var current = this._root;\n    var s = [],\n        done = false,\n        i = 0;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n\n          if (i === index) {\n            return current;\n          }\n\n          i++;\n          current = current.right;\n        } else {\n          done = true;\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Bulk-load items. Both array have to be same size\n   * @param{Array<Key>}  keys\n   * @param{Array<Value>}[values]\n   * @param{Boolean}     [presort=false] Pre-sort keys and values, using\n   *                                       tree's comparator. Sorting is done\n   *                                       in-place\n   * @return {AVLTree}\n   */\n\n\n  SplayTree.prototype.load = function load(keys, values, presort) {\n    if (keys === void 0) keys = [];\n    if (values === void 0) values = [];\n    if (presort === void 0) presort = false;\n\n    if (this._size !== 0) {\n      throw new Error('bulk-load: tree is not empty');\n    }\n\n    var size = keys.length;\n\n    if (presort) {\n      sort(keys, values, 0, size - 1, this._compare);\n    }\n\n    this._root = loadRecursive(null, keys, values, 0, size);\n    this._size = size;\n    return this;\n  };\n\n  SplayTree.prototype.min = function min() {\n    var node = this.minNode(this._root);\n\n    if (node) {\n      return node.key;\n    } else {\n      return null;\n    }\n  };\n\n  SplayTree.prototype.max = function max() {\n    var node = this.maxNode(this._root);\n\n    if (node) {\n      return node.key;\n    } else {\n      return null;\n    }\n  };\n\n  SplayTree.prototype.isEmpty = function isEmpty() {\n    return this._root === null;\n  };\n\n  prototypeAccessors.size.get = function () {\n    return this._size;\n  };\n  /**\n   * Create a tree and load it with items\n   * @param{Array<Key>}        keys\n   * @param{Array<Value>?}      [values]\n    * @param{Function?}          [comparator]\n   * @param{Boolean?}           [presort=false] Pre-sort keys and values, using\n   *                                             tree's comparator. Sorting is done\n   *                                             in-place\n   * @param{Boolean?}           [noDuplicates=false] Allow duplicates\n   * @return {SplayTree}\n   */\n\n\n  SplayTree.createTree = function createTree(keys, values, comparator, presort, noDuplicates) {\n    return new SplayTree(comparator, noDuplicates).load(keys, values, presort);\n  };\n\n  Object.defineProperties(SplayTree.prototype, prototypeAccessors);\n\n  function loadRecursive(parent, keys, values, start, end) {\n    var size = end - start;\n\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var key = keys[middle];\n      var data = values[middle];\n      var node = {\n        key: key,\n        data: data,\n        parent: parent\n      };\n      node.left = loadRecursive(node, keys, values, start, middle);\n      node.right = loadRecursive(node, keys, values, middle + 1, end);\n      return node;\n    }\n\n    return null;\n  }\n\n  function sort(keys, values, left, right, compare) {\n    if (left >= right) {\n      return;\n    }\n\n    var pivot = keys[left + right >> 1];\n    var i = left - 1;\n    var j = right + 1;\n\n    while (true) {\n      do {\n        i++;\n      } while (compare(keys[i], pivot) < 0);\n\n      do {\n        j--;\n      } while (compare(keys[j], pivot) > 0);\n\n      if (i >= j) {\n        break;\n      }\n\n      var tmp = keys[i];\n      keys[i] = keys[j];\n      keys[j] = tmp;\n      tmp = values[i];\n      values[i] = values[j];\n      values[j] = tmp;\n    }\n\n    sort(keys, values, left, j, compare);\n    sort(keys, values, j + 1, right, compare);\n  }\n\n  var NORMAL = 0;\n  var NON_CONTRIBUTING = 1;\n  var SAME_TRANSITION = 2;\n  var DIFFERENT_TRANSITION = 3;\n  var INTERSECTION = 0;\n  var UNION = 1;\n  var DIFFERENCE = 2;\n  var XOR = 3;\n  /**\n   * @param  {SweepEvent} event\n   * @param  {SweepEvent} prev\n   * @param  {Operation} operation\n   */\n\n  function computeFields(event, prev, operation) {\n    // compute inOut and otherInOut fields\n    if (prev === null) {\n      event.inOut = false;\n      event.otherInOut = true; // previous line segment in sweepline belongs to the same polygon\n    } else {\n      if (event.isSubject === prev.isSubject) {\n        event.inOut = !prev.inOut;\n        event.otherInOut = prev.otherInOut; // previous line segment in sweepline belongs to the clipping polygon\n      } else {\n        event.inOut = !prev.otherInOut;\n        event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;\n      } // compute prevInResult field\n\n\n      if (prev) {\n        event.prevInResult = !inResult(prev, operation) || prev.isVertical() ? prev.prevInResult : prev;\n      }\n    } // check if the line segment belongs to the Boolean operation\n\n\n    event.inResult = inResult(event, operation);\n  }\n  /* eslint-disable indent */\n\n\n  function inResult(event, operation) {\n    switch (event.type) {\n      case NORMAL:\n        switch (operation) {\n          case INTERSECTION:\n            return !event.otherInOut;\n\n          case UNION:\n            return event.otherInOut;\n\n          case DIFFERENCE:\n            // return (event.isSubject && !event.otherInOut) ||\n            //         (!event.isSubject && event.otherInOut);\n            return event.isSubject && event.otherInOut || !event.isSubject && !event.otherInOut;\n\n          case XOR:\n            return true;\n        }\n\n        break;\n\n      case SAME_TRANSITION:\n        return operation === INTERSECTION || operation === UNION;\n\n      case DIFFERENT_TRANSITION:\n        return operation === DIFFERENCE;\n\n      case NON_CONTRIBUTING:\n        return false;\n    }\n\n    return false;\n  }\n  /* eslint-enable indent */\n\n\n  var SweepEvent = function SweepEvent(point, left, otherEvent, isSubject, edgeType) {\n    /**\n     * Is left endpoint?\n     * @type {Boolean}\n     */\n    this.left = left;\n    /**\n     * @type {Array.<Number>}\n     */\n\n    this.point = point;\n    /**\n     * Other edge reference\n     * @type {SweepEvent}\n     */\n\n    this.otherEvent = otherEvent;\n    /**\n     * Belongs to source or clipping polygon\n     * @type {Boolean}\n     */\n\n    this.isSubject = isSubject;\n    /**\n     * Edge contribution type\n     * @type {Number}\n     */\n\n    this.type = edgeType || NORMAL;\n    /**\n     * In-out transition for the sweepline crossing polygon\n     * @type {Boolean}\n     */\n\n    this.inOut = false;\n    /**\n     * @type {Boolean}\n     */\n\n    this.otherInOut = false;\n    /**\n     * Previous event in result?\n     * @type {SweepEvent}\n     */\n\n    this.prevInResult = null;\n    /**\n     * Does event belong to result?\n     * @type {Boolean}\n     */\n\n    this.inResult = false; // connection step\n\n    /**\n     * @type {Boolean}\n     */\n\n    this.resultInOut = false;\n    this.isExteriorRing = true;\n  };\n  /**\n   * @param{Array.<Number>}p\n   * @return {Boolean}\n   */\n\n\n  SweepEvent.prototype.isBelow = function isBelow(p) {\n    var p0 = this.point,\n        p1 = this.otherEvent.point;\n    return this.left ? (p0[0] - p[0]) * (p1[1] - p[1]) - (p1[0] - p[0]) * (p0[1] - p[1]) > 0 // signedArea(this.point, this.otherEvent.point, p) > 0 :\n    : (p1[0] - p[0]) * (p0[1] - p[1]) - (p0[0] - p[0]) * (p1[1] - p[1]) > 0; //signedArea(this.otherEvent.point, this.point, p) > 0;\n  };\n  /**\n   * @param{Array.<Number>}p\n   * @return {Boolean}\n   */\n\n\n  SweepEvent.prototype.isAbove = function isAbove(p) {\n    return !this.isBelow(p);\n  };\n  /**\n   * @return {Boolean}\n   */\n\n\n  SweepEvent.prototype.isVertical = function isVertical() {\n    return this.point[0] === this.otherEvent.point[0];\n  };\n\n  SweepEvent.prototype.clone = function clone() {\n    var copy = new SweepEvent(this.point, this.left, this.otherEvent, this.isSubject, this.type);\n    copy.inResult = this.inResult;\n    copy.prevInResult = this.prevInResult;\n    copy.isExteriorRing = this.isExteriorRing;\n    copy.inOut = this.inOut;\n    copy.otherInOut = this.otherInOut;\n    return copy;\n  };\n\n  function equals(p1, p2) {\n    if (p1[0] === p2[0]) {\n      if (p1[1] === p2[1]) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    return false;\n  } // const EPSILON = 1e-9;\n  // const abs = Math.abs;\n  // TODO https://github.com/w8r/martinez/issues/6#issuecomment-262847164\n  // Precision problem.\n  //\n  // module.exports = function equals(p1, p2) {\n  //   return abs(p1[0] - p2[0]) <= EPSILON && abs(p1[1] - p2[1]) <= EPSILON;\n  // };\n\n  /**\n   * Signed area of the triangle (p0, p1, p2)\n   * @param  {Array.<Number>} p0\n   * @param  {Array.<Number>} p1\n   * @param  {Array.<Number>} p2\n   * @return {Number}\n   */\n\n\n  function signedArea(p0, p1, p2) {\n    return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);\n  }\n  /**\n   * @param  {SweepEvent} e1\n   * @param  {SweepEvent} e2\n   * @return {Number}\n   */\n\n\n  function compareEvents(e1, e2) {\n    var p1 = e1.point;\n    var p2 = e2.point; // Different x-coordinate\n\n    if (p1[0] > p2[0]) {\n      return 1;\n    }\n\n    if (p1[0] < p2[0]) {\n      return -1;\n    } // Different points, but same x-coordinate\n    // Event with lower y-coordinate is processed first\n\n\n    if (p1[1] !== p2[1]) {\n      return p1[1] > p2[1] ? 1 : -1;\n    }\n\n    return specialCases(e1, e2, p1, p2);\n  }\n  /* eslint-disable no-unused-vars */\n\n\n  function specialCases(e1, e2, p1, p2) {\n    // Same coordinates, but one is a left endpoint and the other is\n    // a right endpoint. The right endpoint is processed first\n    if (e1.left !== e2.left) {\n      return e1.left ? 1 : -1;\n    } // const p2 = e1.otherEvent.point, p3 = e2.otherEvent.point;\n    // const sa = (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    // Same coordinates, both events\n    // are left endpoints or right endpoints.\n    // not collinear\n\n\n    if (signedArea(p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {\n      // the event associate to the bottom segment is processed first\n      return !e1.isBelow(e2.otherEvent.point) ? 1 : -1;\n    }\n\n    return !e1.isSubject && e2.isSubject ? 1 : -1;\n  }\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * @param  {SweepEvent} se\n   * @param  {Array.<Number>} p\n   * @param  {Queue} queue\n   * @return {Queue}\n   */\n\n\n  function divideSegment(se, p, queue) {\n    var r = new SweepEvent(p, false, se, se.isSubject);\n    var l = new SweepEvent(p, true, se.otherEvent, se.isSubject);\n    /* eslint-disable no-console */\n\n    if (equals(se.point, se.otherEvent.point)) {\n      console.warn('what is that, a collapsed segment?', se);\n    }\n    /* eslint-enable no-console */\n\n\n    r.contourId = l.contourId = se.contourId; // avoid a rounding error. The left event would be processed after the right event\n\n    if (compareEvents(l, se.otherEvent) > 0) {\n      se.otherEvent.left = true;\n      l.left = false;\n    } // avoid a rounding error. The left event would be processed after the right event\n    // if (compareEvents(se, r) > 0) {}\n\n\n    se.otherEvent.otherEvent = l;\n    se.otherEvent = r;\n    queue.push(l);\n    queue.push(r);\n    return queue;\n  } //const EPS = 1e-9;\n\n  /**\n   * Finds the magnitude of the cross product of two vectors (if we pretend\n   * they're in three dimensions)\n   *\n   * @param {Object} a First vector\n   * @param {Object} b Second vector\n   * @private\n   * @returns {Number} The magnitude of the cross product\n   */\n\n\n  function crossProduct(a, b) {\n    return a[0] * b[1] - a[1] * b[0];\n  }\n  /**\n   * Finds the dot product of two vectors.\n   *\n   * @param {Object} a First vector\n   * @param {Object} b Second vector\n   * @private\n   * @returns {Number} The dot product\n   */\n\n\n  function dotProduct(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n  }\n  /**\n   * Finds the intersection (if any) between two line segments a and b, given the\n   * line segments' end points a1, a2 and b1, b2.\n   *\n   * This algorithm is based on Schneider and Eberly.\n   * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf\n   * Page 244.\n   *\n   * @param {Array.<Number>} a1 point of first line\n   * @param {Array.<Number>} a2 point of first line\n   * @param {Array.<Number>} b1 point of second line\n   * @param {Array.<Number>} b2 point of second line\n   * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints\n   *                                         (meaning connected segments) as\n   *                                         intersections\n   * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of\n   * intersection. If they overlap, the two end points of the overlapping segment.\n   * Otherwise, null.\n   */\n\n\n  function intersection(a1, a2, b1, b2, noEndpointTouch) {\n    // The algorithm expects our lines in the form P + sd, where P is a point,\n    // s is on the interval [0, 1], and d is a vector.\n    // We are passed two points. P can be the first point of each pair. The\n    // vector, then, could be thought of as the distance (in x and y components)\n    // from the first point to the second point.\n    // So first, let's make our vectors:\n    var va = [a2[0] - a1[0], a2[1] - a1[1]];\n    var vb = [b2[0] - b1[0], b2[1] - b1[1]]; // We also define a function to convert back to regular point form:\n\n    /* eslint-disable arrow-body-style */\n\n    function toPoint(p, s, d) {\n      return [p[0] + s * d[0], p[1] + s * d[1]];\n    }\n    /* eslint-enable arrow-body-style */\n    // The rest is pretty much a straight port of the algorithm.\n\n\n    var e = [b1[0] - a1[0], b1[1] - a1[1]];\n    var kross = crossProduct(va, vb);\n    var sqrKross = kross * kross;\n    var sqrLenA = dotProduct(va, va); //const sqrLenB  = dotProduct(vb, vb);\n    // Check for line intersection. This works because of the properties of the\n    // cross product -- specifically, two vectors are parallel if and only if the\n    // cross product is the 0 vector. The full calculation involves relative error\n    // to account for possible very small line segments. See Schneider & Eberly\n    // for details.\n\n    if (sqrKross > 0\n    /* EPS * sqrLenB * sqLenA */\n    ) {\n        // If they're not parallel, then (because these are line segments) they\n        // still might not actually intersect. This code checks that the\n        // intersection point of the lines is actually on both line segments.\n        var s = crossProduct(e, vb) / kross;\n\n        if (s < 0 || s > 1) {\n          // not on line segment a\n          return null;\n        }\n\n        var t = crossProduct(e, va) / kross;\n\n        if (t < 0 || t > 1) {\n          // not on line segment b\n          return null;\n        }\n\n        if (s === 0 || s === 1) {\n          // on an endpoint of line segment a\n          return noEndpointTouch ? null : [toPoint(a1, s, va)];\n        }\n\n        if (t === 0 || t === 1) {\n          // on an endpoint of line segment b\n          return noEndpointTouch ? null : [toPoint(b1, t, vb)];\n        }\n\n        return [toPoint(a1, s, va)];\n      } // If we've reached this point, then the lines are either parallel or the\n    // same, but the segments could overlap partially or fully, or not at all.\n    // So we need to find the overlap, if any. To do that, we can use e, which is\n    // the (vector) difference between the two initial points. If this is parallel\n    // with the line itself, then the two lines are the same line, and there will\n    // be overlap.\n    //const sqrLenE = dotProduct(e, e);\n\n\n    kross = crossProduct(e, va);\n    sqrKross = kross * kross;\n\n    if (sqrKross > 0\n    /* EPS * sqLenB * sqLenE */\n    ) {\n        // Lines are just parallel, not the same. No overlap.\n        return null;\n      }\n\n    var sa = dotProduct(va, e) / sqrLenA;\n    var sb = sa + dotProduct(va, vb) / sqrLenA;\n    var smin = Math.min(sa, sb);\n    var smax = Math.max(sa, sb); // this is, essentially, the FindIntersection acting on floats from\n    // Schneider & Eberly, just inlined into this function.\n\n    if (smin <= 1 && smax >= 0) {\n      // overlap on an end point\n      if (smin === 1) {\n        return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];\n      }\n\n      if (smax === 0) {\n        return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];\n      }\n\n      if (noEndpointTouch && smin === 0 && smax === 1) {\n        return null;\n      } // There's overlap on a segment -- two points of intersection. Return both.\n\n\n      return [toPoint(a1, smin > 0 ? smin : 0, va), toPoint(a1, smax < 1 ? smax : 1, va)];\n    }\n\n    return null;\n  }\n  /**\n   * @param  {SweepEvent} se1\n   * @param  {SweepEvent} se2\n   * @param  {Queue}      queue\n   * @return {Number}\n   */\n\n\n  function possibleIntersection(se1, se2, queue) {\n    // that disallows self-intersecting polygons,\n    // did cost us half a day, so I'll leave it\n    // out of respect\n    // if (se1.isSubject === se2.isSubject) return;\n    var inter = intersection(se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n    var nintersections = inter ? inter.length : 0;\n\n    if (nintersections === 0) {\n      return 0;\n    } // no intersection\n    // the line segments intersect at an endpoint of both line segments\n\n\n    if (nintersections === 1 && (equals(se1.point, se2.point) || equals(se1.otherEvent.point, se2.otherEvent.point))) {\n      return 0;\n    }\n\n    if (nintersections === 2 && se1.isSubject === se2.isSubject) {\n      // if(se1.contourId === se2.contourId){\n      // console.warn('Edges of the same polygon overlap',\n      //   se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n      // }\n      //throw new Error('Edges of the same polygon overlap');\n      return 0;\n    } // The line segments associated to se1 and se2 intersect\n\n\n    if (nintersections === 1) {\n      // if the intersection point is not an endpoint of se1\n      if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {\n        divideSegment(se1, inter[0], queue);\n      } // if the intersection point is not an endpoint of se2\n\n\n      if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {\n        divideSegment(se2, inter[0], queue);\n      }\n\n      return 1;\n    } // The line segments associated to se1 and se2 overlap\n\n\n    var events = [];\n    var leftCoincide = false;\n    var rightCoincide = false;\n\n    if (equals(se1.point, se2.point)) {\n      leftCoincide = true; // linked\n    } else if (compareEvents(se1, se2) === 1) {\n      events.push(se2, se1);\n    } else {\n      events.push(se1, se2);\n    }\n\n    if (equals(se1.otherEvent.point, se2.otherEvent.point)) {\n      rightCoincide = true;\n    } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {\n      events.push(se2.otherEvent, se1.otherEvent);\n    } else {\n      events.push(se1.otherEvent, se2.otherEvent);\n    }\n\n    if (leftCoincide && rightCoincide || leftCoincide) {\n      // both line segments are equal or share the left endpoint\n      se2.type = NON_CONTRIBUTING;\n      se1.type = se2.inOut === se1.inOut ? SAME_TRANSITION : DIFFERENT_TRANSITION;\n\n      if (leftCoincide && !rightCoincide) {\n        // honestly no idea, but changing events selection from [2, 1]\n        // to [0, 1] fixes the overlapping self-intersecting polygons issue\n        divideSegment(events[1].otherEvent, events[0].point, queue);\n      }\n\n      return 2;\n    } // the line segments share the right endpoint\n\n\n    if (rightCoincide) {\n      divideSegment(events[0], events[1].point, queue);\n      return 3;\n    } // no line segment includes totally the other one\n\n\n    if (events[0] !== events[3].otherEvent) {\n      divideSegment(events[0], events[1].point, queue);\n      divideSegment(events[1], events[2].point, queue);\n      return 3;\n    } // one line segment includes the other one\n\n\n    divideSegment(events[0], events[1].point, queue);\n    divideSegment(events[3].otherEvent, events[2].point, queue);\n    return 3;\n  }\n  /**\n   * @param  {SweepEvent} le1\n   * @param  {SweepEvent} le2\n   * @return {Number}\n   */\n\n\n  function compareSegments(le1, le2) {\n    if (le1 === le2) {\n      return 0;\n    } // Segments are not collinear\n\n\n    if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 || signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {\n      // If they share their left endpoint use the right endpoint to sort\n      if (equals(le1.point, le2.point)) {\n        return le1.isBelow(le2.otherEvent.point) ? -1 : 1;\n      } // Different left endpoint: use the left endpoint to sort\n\n\n      if (le1.point[0] === le2.point[0]) {\n        return le1.point[1] < le2.point[1] ? -1 : 1;\n      } // has the line segment associated to e1 been inserted\n      // into S after the line segment associated to e2 ?\n\n\n      if (compareEvents(le1, le2) === 1) {\n        return le2.isAbove(le1.point) ? -1 : 1;\n      } // The line segment associated to e2 has been inserted\n      // into S after the line segment associated to e1\n\n\n      return le1.isBelow(le2.point) ? -1 : 1;\n    }\n\n    if (le1.isSubject === le2.isSubject) {\n      // same polygon\n      var p1 = le1.point,\n          p2 = le2.point;\n\n      if (p1[0] === p2[0] && p1[1] === p2[1]\n      /*equals(le1.point, le2.point)*/\n      ) {\n          p1 = le1.otherEvent.point;\n          p2 = le2.otherEvent.point;\n\n          if (p1[0] === p2[0] && p1[1] === p2[1]) {\n            return 0;\n          } else {\n            return le1.contourId > le2.contourId ? 1 : -1;\n          }\n        }\n    } else {\n      // Segments are collinear, but belong to separate polygons\n      return le1.isSubject ? -1 : 1;\n    }\n\n    return compareEvents(le1, le2) === 1 ? 1 : -1;\n  }\n\n  function subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation) {\n    var sweepLine = new SplayTree(compareSegments);\n    var sortedEvents = [];\n    var rightbound = Math.min(sbbox[2], cbbox[2]);\n    var prev, next, begin;\n\n    while (eventQueue.length !== 0) {\n      var event = eventQueue.pop();\n      sortedEvents.push(event); // optimization by bboxes for intersection and difference goes here\n\n      if (operation === INTERSECTION && event.point[0] > rightbound || operation === DIFFERENCE && event.point[0] > sbbox[2]) {\n        break;\n      }\n\n      if (event.left) {\n        next = prev = sweepLine.insert(event);\n        begin = sweepLine.minNode();\n\n        if (prev !== begin) {\n          prev = sweepLine.prev(prev);\n        } else {\n          prev = null;\n        }\n\n        next = sweepLine.next(next);\n        var prevEvent = prev ? prev.key : null;\n        var prevprevEvent = void 0;\n        computeFields(event, prevEvent, operation);\n\n        if (next) {\n          if (possibleIntersection(event, next.key, eventQueue) === 2) {\n            computeFields(event, prevEvent, operation);\n            computeFields(event, next.key, operation);\n          }\n        }\n\n        if (prev) {\n          if (possibleIntersection(prev.key, event, eventQueue) === 2) {\n            var prevprev = prev;\n\n            if (prevprev !== begin) {\n              prevprev = sweepLine.prev(prevprev);\n            } else {\n              prevprev = null;\n            }\n\n            prevprevEvent = prevprev ? prevprev.key : null;\n            computeFields(prevEvent, prevprevEvent, operation);\n            computeFields(event, prevEvent, operation);\n          }\n        }\n      } else {\n        event = event.otherEvent;\n        next = prev = sweepLine.find(event);\n\n        if (prev && next) {\n          if (prev !== begin) {\n            prev = sweepLine.prev(prev);\n          } else {\n            prev = null;\n          }\n\n          next = sweepLine.next(next);\n          sweepLine.remove(event);\n\n          if (next && prev) {\n            possibleIntersection(prev.key, next.key, eventQueue);\n          }\n        }\n      }\n    }\n\n    return sortedEvents;\n  }\n  /**\n   * @param  {Array.<SweepEvent>} sortedEvents\n   * @return {Array.<SweepEvent>}\n   */\n\n\n  function orderEvents(sortedEvents) {\n    var event, i, len, tmp;\n    var resultEvents = [];\n\n    for (i = 0, len = sortedEvents.length; i < len; i++) {\n      event = sortedEvents[i];\n\n      if (event.left && event.inResult || !event.left && event.otherEvent.inResult) {\n        resultEvents.push(event);\n      }\n    } // Due to overlapping edges the resultEvents array can be not wholly sorted\n\n\n    var sorted = false;\n\n    while (!sorted) {\n      sorted = true;\n\n      for (i = 0, len = resultEvents.length; i < len; i++) {\n        if (i + 1 < len && compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {\n          tmp = resultEvents[i];\n          resultEvents[i] = resultEvents[i + 1];\n          resultEvents[i + 1] = tmp;\n          sorted = false;\n        }\n      }\n    }\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      event = resultEvents[i];\n      event.pos = i;\n    } // imagine, the right event is found in the beginning of the queue,\n    // when his left counterpart is not marked yet\n\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      event = resultEvents[i];\n\n      if (!event.left) {\n        tmp = event.pos;\n        event.pos = event.otherEvent.pos;\n        event.otherEvent.pos = tmp;\n      }\n    }\n\n    return resultEvents;\n  }\n  /**\n   * @param  {Number} pos\n   * @param  {Array.<SweepEvent>} resultEvents\n   * @param  {Object>}    processed\n   * @return {Number}\n   */\n\n\n  function nextPos(pos, resultEvents, processed, origIndex) {\n    var newPos = pos + 1;\n    var length = resultEvents.length;\n\n    if (newPos > length - 1) {\n      return pos - 1;\n    }\n\n    var p = resultEvents[pos].point;\n    var p1 = resultEvents[newPos].point; // while in range and not the current one by value\n\n    while (newPos < length && p1[0] === p[0] && p1[1] === p[1]) {\n      if (!processed[newPos]) {\n        return newPos;\n      } else {\n        newPos++;\n      }\n\n      p1 = resultEvents[newPos].point;\n    }\n\n    newPos = pos - 1;\n\n    while (processed[newPos] && newPos >= origIndex) {\n      newPos--;\n    }\n\n    return newPos;\n  }\n  /**\n   * @param  {Array.<SweepEvent>} sortedEvents\n   * @return {Array.<*>} polygons\n   */\n\n\n  function connectEdges(sortedEvents, operation) {\n    var i, len;\n    var resultEvents = orderEvents(sortedEvents); // \"false\"-filled array\n\n    var processed = {};\n    var result = [];\n    var event;\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      if (processed[i]) {\n        continue;\n      }\n\n      var contour = [[]];\n\n      if (!resultEvents[i].isExteriorRing) {\n        if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length === 0) {\n          result.push(contour);\n        } else if (result.length === 0) {\n          result.push([[contour]]);\n        } else {\n          result[result.length - 1].push(contour[0]);\n        }\n      } else if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length > 1) {\n        result[result.length - 1].push(contour[0]);\n      } else {\n        result.push(contour);\n      }\n\n      var ringId = result.length - 1;\n      var pos = i;\n      var initial = resultEvents[i].point;\n      contour[0].push(initial);\n\n      while (pos >= i) {\n        event = resultEvents[pos];\n        processed[pos] = true;\n\n        if (event.left) {\n          event.resultInOut = false;\n          event.contourId = ringId;\n        } else {\n          event.otherEvent.resultInOut = true;\n          event.otherEvent.contourId = ringId;\n        }\n\n        pos = event.pos;\n        processed[pos] = true;\n        contour[0].push(resultEvents[pos].point);\n        pos = nextPos(pos, resultEvents, processed, i);\n      }\n\n      pos = pos === -1 ? i : pos;\n      event = resultEvents[pos];\n      processed[pos] = processed[event.pos] = true;\n      event.otherEvent.resultInOut = true;\n      event.otherEvent.contourId = ringId;\n    } // Handle if the result is a polygon (eg not multipoly)\n    // Commented it again, let's see what do we mean by that\n    // if (result.length === 1) result = result[0];\n\n\n    return result;\n  }\n\n  var tinyqueue = TinyQueue;\n  var default_1 = TinyQueue;\n\n  function TinyQueue(data, compare) {\n    var this$1 = this;\n\n    if (!(this instanceof TinyQueue)) {\n      return new TinyQueue(data, compare);\n    }\n\n    this.data = data || [];\n    this.length = this.data.length;\n    this.compare = compare || defaultCompare;\n\n    if (this.length > 0) {\n      for (var i = (this.length >> 1) - 1; i >= 0; i--) {\n        this$1._down(i);\n      }\n    }\n  }\n\n  function defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n  }\n\n  TinyQueue.prototype = {\n    push: function (item) {\n      this.data.push(item);\n      this.length++;\n\n      this._up(this.length - 1);\n    },\n    pop: function () {\n      if (this.length === 0) {\n        return undefined;\n      }\n\n      var top = this.data[0];\n      this.length--;\n\n      if (this.length > 0) {\n        this.data[0] = this.data[this.length];\n\n        this._down(0);\n      }\n\n      this.data.pop();\n      return top;\n    },\n    peek: function () {\n      return this.data[0];\n    },\n    _up: function (pos) {\n      var data = this.data;\n      var compare = this.compare;\n      var item = data[pos];\n\n      while (pos > 0) {\n        var parent = pos - 1 >> 1;\n        var current = data[parent];\n\n        if (compare(item, current) >= 0) {\n          break;\n        }\n\n        data[pos] = current;\n        pos = parent;\n      }\n\n      data[pos] = item;\n    },\n    _down: function (pos) {\n      var this$1 = this;\n      var data = this.data;\n      var compare = this.compare;\n      var halfLength = this.length >> 1;\n      var item = data[pos];\n\n      while (pos < halfLength) {\n        var left = (pos << 1) + 1;\n        var right = left + 1;\n        var best = data[left];\n\n        if (right < this$1.length && compare(data[right], best) < 0) {\n          left = right;\n          best = data[right];\n        }\n\n        if (compare(best, item) >= 0) {\n          break;\n        }\n\n        data[pos] = best;\n        pos = left;\n      }\n\n      data[pos] = item;\n    }\n  };\n  tinyqueue.default = default_1;\n  var max = Math.max;\n  var min = Math.min;\n  var contourId = 0;\n\n  function processPolygon(contourOrHole, isSubject, depth, Q, bbox, isExteriorRing) {\n    var i, len, s1, s2, e1, e2;\n\n    for (i = 0, len = contourOrHole.length - 1; i < len; i++) {\n      s1 = contourOrHole[i];\n      s2 = contourOrHole[i + 1];\n      e1 = new SweepEvent(s1, false, undefined, isSubject);\n      e2 = new SweepEvent(s2, false, e1, isSubject);\n      e1.otherEvent = e2;\n\n      if (s1[0] === s2[0] && s1[1] === s2[1]) {\n        continue; // skip collapsed edges, or it breaks\n      }\n\n      e1.contourId = e2.contourId = depth;\n\n      if (!isExteriorRing) {\n        e1.isExteriorRing = false;\n        e2.isExteriorRing = false;\n      }\n\n      if (compareEvents(e1, e2) > 0) {\n        e2.left = true;\n      } else {\n        e1.left = true;\n      }\n\n      var x = s1[0],\n          y = s1[1];\n      bbox[0] = min(bbox[0], x);\n      bbox[1] = min(bbox[1], y);\n      bbox[2] = max(bbox[2], x);\n      bbox[3] = max(bbox[3], y); // Pushing it so the queue is sorted from left to right,\n      // with object on the left having the highest priority.\n\n      Q.push(e1);\n      Q.push(e2);\n    }\n  }\n\n  function fillQueue(subject, clipping, sbbox, cbbox, operation) {\n    var eventQueue = new tinyqueue(null, compareEvents);\n    var polygonSet, isExteriorRing, i, ii, j, jj; //, k, kk;\n\n    for (i = 0, ii = subject.length; i < ii; i++) {\n      polygonSet = subject[i];\n\n      for (j = 0, jj = polygonSet.length; j < jj; j++) {\n        isExteriorRing = j === 0;\n\n        if (isExteriorRing) {\n          contourId++;\n        }\n\n        processPolygon(polygonSet[j], true, contourId, eventQueue, sbbox, isExteriorRing);\n      }\n    }\n\n    for (i = 0, ii = clipping.length; i < ii; i++) {\n      polygonSet = clipping[i];\n\n      for (j = 0, jj = polygonSet.length; j < jj; j++) {\n        isExteriorRing = j === 0;\n\n        if (operation === DIFFERENCE) {\n          isExteriorRing = false;\n        }\n\n        if (isExteriorRing) {\n          contourId++;\n        }\n\n        processPolygon(polygonSet[j], false, contourId, eventQueue, cbbox, isExteriorRing);\n      }\n    }\n\n    return eventQueue;\n  }\n\n  var EMPTY = [];\n\n  function trivialOperation(subject, clipping, operation) {\n    var result = null;\n\n    if (subject.length * clipping.length === 0) {\n      if (operation === INTERSECTION) {\n        result = EMPTY;\n      } else if (operation === DIFFERENCE) {\n        result = subject;\n      } else if (operation === UNION || operation === XOR) {\n        result = subject.length === 0 ? clipping : subject;\n      }\n    }\n\n    return result;\n  }\n\n  function compareBBoxes(subject, clipping, sbbox, cbbox, operation) {\n    var result = null;\n\n    if (sbbox[0] > cbbox[2] || cbbox[0] > sbbox[2] || sbbox[1] > cbbox[3] || cbbox[1] > sbbox[3]) {\n      if (operation === INTERSECTION) {\n        result = EMPTY;\n      } else if (operation === DIFFERENCE) {\n        result = subject;\n      } else if (operation === UNION || operation === XOR) {\n        result = subject.concat(clipping);\n      }\n    }\n\n    return result;\n  }\n\n  function boolean(subject, clipping, operation) {\n    if (typeof subject[0][0][0] === 'number') {\n      subject = [subject];\n    }\n\n    if (typeof clipping[0][0][0] === 'number') {\n      clipping = [clipping];\n    }\n\n    var trivial = trivialOperation(subject, clipping, operation);\n\n    if (trivial) {\n      return trivial === EMPTY ? null : trivial;\n    }\n\n    var sbbox = [Infinity, Infinity, -Infinity, -Infinity];\n    var cbbox = [Infinity, Infinity, -Infinity, -Infinity]; //console.time('fill queue');\n\n    var eventQueue = fillQueue(subject, clipping, sbbox, cbbox, operation); //console.timeEnd('fill queue');\n\n    trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);\n\n    if (trivial) {\n      return trivial === EMPTY ? null : trivial;\n    } //console.time('subdivide edges');\n\n\n    var sortedEvents = subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation); //console.timeEnd('subdivide edges');\n    //console.time('connect vertices');\n\n    var result = connectEdges(sortedEvents, operation); //console.timeEnd('connect vertices');\n\n    return result;\n  }\n\n  function union(subject, clipping) {\n    return boolean(subject, clipping, UNION);\n  }\n\n  function diff(subject, clipping) {\n    return boolean(subject, clipping, DIFFERENCE);\n  }\n\n  function xor(subject, clipping) {\n    return boolean(subject, clipping, XOR);\n  }\n\n  function intersection$1(subject, clipping) {\n    return boolean(subject, clipping, INTERSECTION);\n  }\n  /**\n   * @enum {Number}\n   */\n\n\n  var operations = {\n    UNION: UNION,\n    DIFFERENCE: DIFFERENCE,\n    INTERSECTION: INTERSECTION,\n    XOR: XOR\n  };\n  exports.union = union;\n  exports.diff = diff;\n  exports.xor = xor;\n  exports.intersection = intersection$1;\n  exports.operations = operations;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}