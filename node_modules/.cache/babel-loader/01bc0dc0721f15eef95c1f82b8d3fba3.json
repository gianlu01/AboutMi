{"ast":null,"code":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar helpers_1 = require(\"@turf/helpers\");\n\nvar invariant_1 = require(\"@turf/invariant\");\n\nvar martinez = __importStar(require(\"martinez-polygon-clipping\"));\n/**\r\n * Takes two {@link Polygon|polygon} or {@link MultiPolygon|multi-polygon} geometries and\r\n * finds their polygonal intersection. If they don't intersect, returns null.\r\n *\r\n * @name intersect\r\n * @param {Feature<Polygon | MultiPolygon>} poly1 the first polygon or multipolygon\r\n * @param {Feature<Polygon | MultiPolygon>} poly2 the second polygon or multipolygon\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Object} [options.properties={}] Translate GeoJSON Properties to Feature\r\n * @returns {Feature|null} returns a feature representing the area they share (either a {@link Polygon} or\r\n * {@link MultiPolygon}). If they do not share any area, returns `null`.\r\n * @example\r\n * var poly1 = turf.polygon([[\r\n *   [-122.801742, 45.48565],\r\n *   [-122.801742, 45.60491],\r\n *   [-122.584762, 45.60491],\r\n *   [-122.584762, 45.48565],\r\n *   [-122.801742, 45.48565]\r\n * ]]);\r\n *\r\n * var poly2 = turf.polygon([[\r\n *   [-122.520217, 45.535693],\r\n *   [-122.64038, 45.553967],\r\n *   [-122.720031, 45.526554],\r\n *   [-122.669906, 45.507309],\r\n *   [-122.723464, 45.446643],\r\n *   [-122.532577, 45.408574],\r\n *   [-122.487258, 45.477466],\r\n *   [-122.520217, 45.535693]\r\n * ]]);\r\n *\r\n * var intersection = turf.intersect(poly1, poly2);\r\n *\r\n * //addToMap\r\n * var addToMap = [poly1, poly2, intersection];\r\n */\n\n\nfunction intersect(poly1, poly2, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var geom1 = invariant_1.getGeom(poly1);\n  var geom2 = invariant_1.getGeom(poly2);\n\n  if (geom1.type === \"Polygon\" && geom2.type === \"Polygon\") {\n    var intersection = martinez.intersection(geom1.coordinates, geom2.coordinates);\n\n    if (intersection === null || intersection.length === 0) {\n      return null;\n    }\n\n    if (intersection.length === 1) {\n      var start = intersection[0][0][0];\n      var end = intersection[0][0][intersection[0][0].length - 1];\n\n      if (start[0] === end[0] && start[1] === end[1]) {\n        return helpers_1.polygon(intersection[0], options.properties);\n      }\n\n      return null;\n    }\n\n    return helpers_1.multiPolygon(intersection, options.properties);\n  } else if (geom1.type === \"MultiPolygon\") {\n    var resultCoords = []; // iterate through the polygon and run intersect with each part, adding to the resultCoords.\n\n    for (var _i = 0, _a = geom1.coordinates; _i < _a.length; _i++) {\n      var coords = _a[_i];\n      var subGeom = invariant_1.getGeom(helpers_1.polygon(coords));\n      var subIntersection = intersect(subGeom, geom2);\n\n      if (subIntersection) {\n        var subIntGeom = invariant_1.getGeom(subIntersection);\n\n        if (subIntGeom.type === \"Polygon\") {\n          resultCoords.push(subIntGeom.coordinates);\n        } else if (subIntGeom.type === \"MultiPolygon\") {\n          resultCoords = resultCoords.concat(subIntGeom.coordinates);\n        } else {\n          throw new Error(\"intersection is invalid\");\n        }\n      }\n    } // Make a polygon with the result\n\n\n    if (resultCoords.length === 0) {\n      return null;\n    }\n\n    if (resultCoords.length === 1) {\n      return helpers_1.polygon(resultCoords[0], options.properties);\n    } else {\n      return helpers_1.multiPolygon(resultCoords, options.properties);\n    }\n  } else if (geom2.type === \"MultiPolygon\") {\n    // geom1 is a polygon and geom2 a multiPolygon,\n    // put the multiPolygon first and fallback to the previous case.\n    return intersect(geom2, geom1);\n  } else {\n    // handle invalid geometry types\n    throw new Error(\"poly1 and poly2 must be either polygons or multiPolygons\");\n  }\n}\n\nexports.default = intersect;","map":null,"metadata":{},"sourceType":"script"}