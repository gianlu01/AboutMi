{"ast":null,"code":"import clone from '@turf/clone';\nimport center from '@turf/center';\nimport centroid from '@turf/centroid';\nimport turfBBox from '@turf/bbox';\nimport rhumbBearing from '@turf/rhumb-bearing';\nimport rhumbDistance from '@turf/rhumb-distance';\nimport rhumbDestination from '@turf/rhumb-destination';\nimport { coordEach, featureEach } from '@turf/meta';\nimport { isObject, point } from '@turf/helpers';\nimport { getCoord, getCoords, getType } from '@turf/invariant';\n/**\n * Scale a GeoJSON from a given point by a factor of scaling (ex: factor=2 would make the GeoJSON 200% larger).\n * If a FeatureCollection is provided, the origin point will be calculated based on each individual Feature.\n *\n * @name transformScale\n * @param {GeoJSON} geojson GeoJSON to be scaled\n * @param {number} factor of scaling, positive or negative values greater than 0\n * @param {Object} [options={}] Optional parameters\n * @param {string|Coord} [options.origin='centroid'] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} scaled GeoJSON\n * @example\n * var poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);\n * var scaledPoly = turf.transformScale(poly, 3);\n *\n * //addToMap\n * var addToMap = [poly, scaledPoly];\n * scaledPoly.properties = {stroke: '#F00', 'stroke-width': 4};\n */\n\nfunction transformScale(geojson, factor, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error('options is invalid');\n  var origin = options.origin;\n  var mutate = options.mutate; // Input validation\n\n  if (!geojson) throw new Error('geojson required');\n  if (typeof factor !== 'number' || factor === 0) throw new Error('invalid factor');\n  var originIsPoint = Array.isArray(origin) || typeof origin === 'object'; // Clone geojson to avoid side effects\n\n  if (mutate !== true) geojson = clone(geojson); // Scale each Feature separately\n\n  if (geojson.type === 'FeatureCollection' && !originIsPoint) {\n    featureEach(geojson, function (feature, index) {\n      geojson.features[index] = scale(feature, factor, origin);\n    });\n    return geojson;\n  } // Scale Feature/Geometry\n\n\n  return scale(geojson, factor, origin);\n}\n/**\n * Scale Feature/Geometry\n *\n * @private\n * @param {Feature|Geometry} feature GeoJSON Feature/Geometry\n * @param {number} factor of scaling, positive or negative values greater than 0\n * @param {string|Coord} [origin=\"centroid\"] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)\n * @returns {Feature|Geometry} scaled GeoJSON Feature/Geometry\n */\n\n\nfunction scale(feature, factor, origin) {\n  // Default params\n  var isPoint = getType(feature) === 'Point';\n  origin = defineOrigin(feature, origin); // Shortcut no-scaling\n\n  if (factor === 1 || isPoint) return feature; // Scale each coordinate\n\n  coordEach(feature, function (coord) {\n    var originalDistance = rhumbDistance(origin, coord);\n    var bearing = rhumbBearing(origin, coord);\n    var newDistance = originalDistance * factor;\n    var newCoord = getCoords(rhumbDestination(origin, newDistance, bearing));\n    coord[0] = newCoord[0];\n    coord[1] = newCoord[1];\n    if (coord.length === 3) coord[2] *= factor;\n  });\n  return feature;\n}\n/**\n * Define Origin\n *\n * @private\n * @param {GeoJSON} geojson GeoJSON\n * @param {string|Coord} origin sw/se/nw/ne/center/centroid\n * @returns {Feature<Point>} Point origin\n */\n\n\nfunction defineOrigin(geojson, origin) {\n  // Default params\n  if (origin === undefined || origin === null) origin = 'centroid'; // Input Coord\n\n  if (Array.isArray(origin) || typeof origin === 'object') return getCoord(origin); // Define BBox\n\n  var bbox = geojson.bbox ? geojson.bbox : turfBBox(geojson);\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n\n  switch (origin) {\n    case 'sw':\n    case 'southwest':\n    case 'westsouth':\n    case 'bottomleft':\n      return point([west, south]);\n\n    case 'se':\n    case 'southeast':\n    case 'eastsouth':\n    case 'bottomright':\n      return point([east, south]);\n\n    case 'nw':\n    case 'northwest':\n    case 'westnorth':\n    case 'topleft':\n      return point([west, north]);\n\n    case 'ne':\n    case 'northeast':\n    case 'eastnorth':\n    case 'topright':\n      return point([east, north]);\n\n    case 'center':\n      return center(geojson);\n\n    case undefined:\n    case null:\n    case 'centroid':\n      return centroid(geojson);\n\n    default:\n      throw new Error('invalid origin');\n  }\n}\n\nexport default transformScale;","map":null,"metadata":{},"sourceType":"module"}