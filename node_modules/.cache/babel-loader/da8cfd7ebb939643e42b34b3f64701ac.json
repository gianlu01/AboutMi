{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], e) : e(t.jsts = {});\n}(this, function (t) {\n  \"use strict\";\n\n  function e() {}\n\n  function n(t) {\n    this.message = t || \"\";\n  }\n\n  function i(t) {\n    this.message = t || \"\";\n  }\n\n  function r(t) {\n    this.message = t || \"\";\n  }\n\n  function o() {}\n\n  function s(t) {\n    return null === t ? Mt : t.color;\n  }\n\n  function a(t) {\n    return null === t ? null : t.parent;\n  }\n\n  function u(t, e) {\n    null !== t && (t.color = e);\n  }\n\n  function l(t) {\n    return null === t ? null : t.left;\n  }\n\n  function c(t) {\n    return null === t ? null : t.right;\n  }\n\n  function p() {\n    this.root_ = null, this.size_ = 0;\n  }\n\n  function h() {}\n\n  function f() {\n    this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);\n  }\n\n  function g() {}\n\n  function d(t) {\n    this.message = t || \"\";\n  }\n\n  function y() {\n    this.array_ = [];\n  }\n\n  \"fill\" in Array.prototype || Object.defineProperty(Array.prototype, \"fill\", {\n    configurable: !0,\n    value: function (t) {\n      if (void 0 === this || null === this) throw new TypeError(this + \" is not an object\");\n      var e = Object(this),\n          n = Math.max(Math.min(e.length, 9007199254740991), 0) || 0,\n          i = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;\n      i = i < 0 ? Math.max(n + i, 0) : Math.min(i, n);\n      var r = 2 in arguments && void 0 !== arguments[2] ? parseInt(Number(arguments[2]), 10) || 0 : n;\n\n      for (r = r < 0 ? Math.max(n + arguments[2], 0) : Math.min(r, n); i < r;) e[i] = t, ++i;\n\n      return e;\n    },\n    writable: !0\n  }), Number.isFinite = Number.isFinite || function (t) {\n    return \"number\" == typeof t && isFinite(t);\n  }, Number.isInteger = Number.isInteger || function (t) {\n    return \"number\" == typeof t && isFinite(t) && Math.floor(t) === t;\n  }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function (t) {\n    return t != t;\n  }, Math.trunc = Math.trunc || function (t) {\n    return t < 0 ? Math.ceil(t) : Math.floor(t);\n  };\n\n  var _ = function () {};\n\n  _.prototype.interfaces_ = function () {\n    return [];\n  }, _.prototype.getClass = function () {\n    return _;\n  }, _.prototype.equalsWithTolerance = function (t, e, n) {\n    return Math.abs(t - e) <= n;\n  };\n\n  var m = function (t) {\n    function e(e) {\n      t.call(this, e), this.name = \"IllegalArgumentException\", this.message = e, this.stack = new t().stack;\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e;\n  }(Error),\n      v = function () {},\n      I = {\n    MAX_VALUE: {\n      configurable: !0\n    }\n  };\n\n  v.isNaN = function (t) {\n    return Number.isNaN(t);\n  }, v.doubleToLongBits = function (t) {\n    return t;\n  }, v.longBitsToDouble = function (t) {\n    return t;\n  }, v.isInfinite = function (t) {\n    return !Number.isFinite(t);\n  }, I.MAX_VALUE.get = function () {\n    return Number.MAX_VALUE;\n  }, Object.defineProperties(v, I);\n\n  var E = function () {},\n      x = function () {},\n      N = function () {},\n      C = function t() {\n    if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) this.x = 0, this.y = 0, this.z = t.NULL_ORDINATE;else if (1 === arguments.length) {\n      var e = arguments[0];\n      this.x = e.x, this.y = e.y, this.z = e.z;\n    } else 2 === arguments.length ? (this.x = arguments[0], this.y = arguments[1], this.z = t.NULL_ORDINATE) : 3 === arguments.length && (this.x = arguments[0], this.y = arguments[1], this.z = arguments[2]);\n  },\n      S = {\n    DimensionalComparator: {\n      configurable: !0\n    },\n    serialVersionUID: {\n      configurable: !0\n    },\n    NULL_ORDINATE: {\n      configurable: !0\n    },\n    X: {\n      configurable: !0\n    },\n    Y: {\n      configurable: !0\n    },\n    Z: {\n      configurable: !0\n    }\n  };\n\n  C.prototype.setOrdinate = function (t, e) {\n    switch (t) {\n      case C.X:\n        this.x = e;\n        break;\n\n      case C.Y:\n        this.y = e;\n        break;\n\n      case C.Z:\n        this.z = e;\n        break;\n\n      default:\n        throw new m(\"Invalid ordinate index: \" + t);\n    }\n  }, C.prototype.equals2D = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return this.x === t.x && this.y === t.y;\n    }\n\n    if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      return !!_.equalsWithTolerance(this.x, e.x, n) && !!_.equalsWithTolerance(this.y, e.y, n);\n    }\n  }, C.prototype.getOrdinate = function (t) {\n    switch (t) {\n      case C.X:\n        return this.x;\n\n      case C.Y:\n        return this.y;\n\n      case C.Z:\n        return this.z;\n    }\n\n    throw new m(\"Invalid ordinate index: \" + t);\n  }, C.prototype.equals3D = function (t) {\n    return this.x === t.x && this.y === t.y && (this.z === t.z || v.isNaN(this.z)) && v.isNaN(t.z);\n  }, C.prototype.equals = function (t) {\n    return t instanceof C && this.equals2D(t);\n  }, C.prototype.equalInZ = function (t, e) {\n    return _.equalsWithTolerance(this.z, t.z, e);\n  }, C.prototype.compareTo = function (t) {\n    var e = t;\n    return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0;\n  }, C.prototype.clone = function () {}, C.prototype.copy = function () {\n    return new C(this);\n  }, C.prototype.toString = function () {\n    return \"(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\n  }, C.prototype.distance3D = function (t) {\n    var e = this.x - t.x,\n        n = this.y - t.y,\n        i = this.z - t.z;\n    return Math.sqrt(e * e + n * n + i * i);\n  }, C.prototype.distance = function (t) {\n    var e = this.x - t.x,\n        n = this.y - t.y;\n    return Math.sqrt(e * e + n * n);\n  }, C.prototype.hashCode = function () {\n    var t = 17;\n    return t = 37 * t + C.hashCode(this.x), t = 37 * t + C.hashCode(this.y);\n  }, C.prototype.setCoordinate = function (t) {\n    this.x = t.x, this.y = t.y, this.z = t.z;\n  }, C.prototype.interfaces_ = function () {\n    return [E, x, e];\n  }, C.prototype.getClass = function () {\n    return C;\n  }, C.hashCode = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n          e = v.doubleToLongBits(t);\n      return Math.trunc((e ^ e) >>> 32);\n    }\n  }, S.DimensionalComparator.get = function () {\n    return L;\n  }, S.serialVersionUID.get = function () {\n    return 0x5cbf2c235c7e5800;\n  }, S.NULL_ORDINATE.get = function () {\n    return v.NaN;\n  }, S.X.get = function () {\n    return 0;\n  }, S.Y.get = function () {\n    return 1;\n  }, S.Z.get = function () {\n    return 2;\n  }, Object.defineProperties(C, S);\n\n  var L = function (t) {\n    if (this._dimensionsToTest = 2, 0 === arguments.length) ;else if (1 === arguments.length) {\n      var e = arguments[0];\n      if (2 !== e && 3 !== e) throw new m(\"only 2 or 3 dimensions may be specified\");\n      this._dimensionsToTest = e;\n    }\n  };\n\n  L.prototype.compare = function (t, e) {\n    var n = t,\n        i = e,\n        r = L.compare(n.x, i.x);\n    if (0 !== r) return r;\n    var o = L.compare(n.y, i.y);\n    if (0 !== o) return o;\n    if (this._dimensionsToTest <= 2) return 0;\n    return L.compare(n.z, i.z);\n  }, L.prototype.interfaces_ = function () {\n    return [N];\n  }, L.prototype.getClass = function () {\n    return L;\n  }, L.compare = function (t, e) {\n    return t < e ? -1 : t > e ? 1 : v.isNaN(t) ? v.isNaN(e) ? 0 : -1 : v.isNaN(e) ? 1 : 0;\n  };\n\n  var b = function () {};\n\n  b.prototype.create = function () {}, b.prototype.interfaces_ = function () {\n    return [];\n  }, b.prototype.getClass = function () {\n    return b;\n  };\n\n  var w = function () {},\n      O = {\n    INTERIOR: {\n      configurable: !0\n    },\n    BOUNDARY: {\n      configurable: !0\n    },\n    EXTERIOR: {\n      configurable: !0\n    },\n    NONE: {\n      configurable: !0\n    }\n  };\n\n  w.prototype.interfaces_ = function () {\n    return [];\n  }, w.prototype.getClass = function () {\n    return w;\n  }, w.toLocationSymbol = function (t) {\n    switch (t) {\n      case w.EXTERIOR:\n        return \"e\";\n\n      case w.BOUNDARY:\n        return \"b\";\n\n      case w.INTERIOR:\n        return \"i\";\n\n      case w.NONE:\n        return \"-\";\n    }\n\n    throw new m(\"Unknown location value: \" + t);\n  }, O.INTERIOR.get = function () {\n    return 0;\n  }, O.BOUNDARY.get = function () {\n    return 1;\n  }, O.EXTERIOR.get = function () {\n    return 2;\n  }, O.NONE.get = function () {\n    return -1;\n  }, Object.defineProperties(w, O);\n\n  var T = function (t, e) {\n    return t.interfaces_ && t.interfaces_().indexOf(e) > -1;\n  },\n      R = function () {},\n      P = {\n    LOG_10: {\n      configurable: !0\n    }\n  };\n\n  R.prototype.interfaces_ = function () {\n    return [];\n  }, R.prototype.getClass = function () {\n    return R;\n  }, R.log10 = function (t) {\n    var e = Math.log(t);\n    return v.isInfinite(e) ? e : v.isNaN(e) ? e : e / R.LOG_10;\n  }, R.min = function (t, e, n, i) {\n    var r = t;\n    return e < r && (r = e), n < r && (r = n), i < r && (r = i), r;\n  }, R.clamp = function () {\n    if (\"number\" == typeof arguments[2] && \"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n      var t = arguments[0],\n          e = arguments[1],\n          n = arguments[2];\n      return t < e ? e : t > n ? n : t;\n    }\n\n    if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n      var i = arguments[0],\n          r = arguments[1],\n          o = arguments[2];\n      return i < r ? r : i > o ? o : i;\n    }\n  }, R.wrap = function (t, e) {\n    return t < 0 ? e - -t % e : t % e;\n  }, R.max = function () {\n    if (3 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1],\n          n = arguments[2],\n          i = t;\n      return e > i && (i = e), n > i && (i = n), i;\n    }\n\n    if (4 === arguments.length) {\n      var r = arguments[0],\n          o = arguments[1],\n          s = arguments[2],\n          a = arguments[3],\n          u = r;\n      return o > u && (u = o), s > u && (u = s), a > u && (u = a), u;\n    }\n  }, R.average = function (t, e) {\n    return (t + e) / 2;\n  }, P.LOG_10.get = function () {\n    return Math.log(10);\n  }, Object.defineProperties(R, P);\n\n  var D = function (t) {\n    this.str = t;\n  };\n\n  D.prototype.append = function (t) {\n    this.str += t;\n  }, D.prototype.setCharAt = function (t, e) {\n    this.str = this.str.substr(0, t) + e + this.str.substr(t + 1);\n  }, D.prototype.toString = function (t) {\n    return this.str;\n  };\n\n  var M = function (t) {\n    this.value = t;\n  };\n\n  M.prototype.intValue = function () {\n    return this.value;\n  }, M.prototype.compareTo = function (t) {\n    return this.value < t ? -1 : this.value > t ? 1 : 0;\n  }, M.isNaN = function (t) {\n    return Number.isNaN(t);\n  };\n\n  var A = function () {};\n\n  A.isWhitespace = function (t) {\n    return t <= 32 && t >= 0 || 127 === t;\n  }, A.toUpperCase = function (t) {\n    return t.toUpperCase();\n  };\n\n  var F = function t() {\n    if (this._hi = 0, this._lo = 0, 0 === arguments.length) this.init(0);else if (1 === arguments.length) {\n      if (\"number\" == typeof arguments[0]) {\n        var e = arguments[0];\n        this.init(e);\n      } else if (arguments[0] instanceof t) {\n        var n = arguments[0];\n        this.init(n);\n      } else if (\"string\" == typeof arguments[0]) {\n        var i = arguments[0];\n        t.call(this, t.parse(i));\n      }\n    } else if (2 === arguments.length) {\n      var r = arguments[0],\n          o = arguments[1];\n      this.init(r, o);\n    }\n  },\n      G = {\n    PI: {\n      configurable: !0\n    },\n    TWO_PI: {\n      configurable: !0\n    },\n    PI_2: {\n      configurable: !0\n    },\n    E: {\n      configurable: !0\n    },\n    NaN: {\n      configurable: !0\n    },\n    EPS: {\n      configurable: !0\n    },\n    SPLIT: {\n      configurable: !0\n    },\n    MAX_PRINT_DIGITS: {\n      configurable: !0\n    },\n    TEN: {\n      configurable: !0\n    },\n    ONE: {\n      configurable: !0\n    },\n    SCI_NOT_EXPONENT_CHAR: {\n      configurable: !0\n    },\n    SCI_NOT_ZERO: {\n      configurable: !0\n    }\n  };\n\n  F.prototype.le = function (t) {\n    return (this._hi < t._hi || this._hi === t._hi) && this._lo <= t._lo;\n  }, F.prototype.extractSignificantDigits = function (t, e) {\n    var n = this.abs(),\n        i = F.magnitude(n._hi),\n        r = F.TEN.pow(i);\n    (n = n.divide(r)).gt(F.TEN) ? (n = n.divide(F.TEN), i += 1) : n.lt(F.ONE) && (n = n.multiply(F.TEN), i -= 1);\n\n    for (var o = i + 1, s = new D(), a = F.MAX_PRINT_DIGITS - 1, u = 0; u <= a; u++) {\n      t && u === o && s.append(\".\");\n      var l = Math.trunc(n._hi);\n      if (l < 0) break;\n      var c = !1,\n          p = 0;\n      l > 9 ? (c = !0, p = \"9\") : p = \"0\" + l, s.append(p), n = n.subtract(F.valueOf(l)).multiply(F.TEN), c && n.selfAdd(F.TEN);\n      var h = !0,\n          f = F.magnitude(n._hi);\n      if (f < 0 && Math.abs(f) >= a - u && (h = !1), !h) break;\n    }\n\n    return e[0] = i, s.toString();\n  }, F.prototype.sqr = function () {\n    return this.multiply(this);\n  }, F.prototype.doubleValue = function () {\n    return this._hi + this._lo;\n  }, F.prototype.subtract = function () {\n    if (arguments[0] instanceof F) {\n      var t = arguments[0];\n      return this.add(t.negate());\n    }\n\n    if (\"number\" == typeof arguments[0]) {\n      var e = arguments[0];\n      return this.add(-e);\n    }\n  }, F.prototype.equals = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return this._hi === t._hi && this._lo === t._lo;\n    }\n  }, F.prototype.isZero = function () {\n    return 0 === this._hi && 0 === this._lo;\n  }, F.prototype.selfSubtract = function () {\n    if (arguments[0] instanceof F) {\n      var t = arguments[0];\n      return this.isNaN() ? this : this.selfAdd(-t._hi, -t._lo);\n    }\n\n    if (\"number\" == typeof arguments[0]) {\n      var e = arguments[0];\n      return this.isNaN() ? this : this.selfAdd(-e, 0);\n    }\n  }, F.prototype.getSpecialNumberString = function () {\n    return this.isZero() ? \"0.0\" : this.isNaN() ? \"NaN \" : null;\n  }, F.prototype.min = function (t) {\n    return this.le(t) ? this : t;\n  }, F.prototype.selfDivide = function () {\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof F) {\n        var t = arguments[0];\n        return this.selfDivide(t._hi, t._lo);\n      }\n\n      if (\"number\" == typeof arguments[0]) {\n        var e = arguments[0];\n        return this.selfDivide(e, 0);\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = null,\n          o = null,\n          s = null,\n          a = null,\n          u = null,\n          l = null,\n          c = null,\n          p = null;\n      return u = this._hi / n, l = F.SPLIT * u, r = l - u, p = F.SPLIT * n, r = l - r, o = u - r, s = p - n, c = u * n, s = p - s, a = n - s, p = r * s - c + r * a + o * s + o * a, l = (this._hi - c - p + this._lo - u * i) / n, p = u + l, this._hi = p, this._lo = u - p + l, this;\n    }\n  }, F.prototype.dump = function () {\n    return \"DD<\" + this._hi + \", \" + this._lo + \">\";\n  }, F.prototype.divide = function () {\n    if (arguments[0] instanceof F) {\n      var t = arguments[0],\n          e = null,\n          n = null,\n          i = null,\n          r = null,\n          o = null,\n          s = null,\n          a = null,\n          u = null;\n      n = (o = this._hi / t._hi) - (e = (s = F.SPLIT * o) - (e = s - o)), u = e * (i = (u = F.SPLIT * t._hi) - (i = u - t._hi)) - (a = o * t._hi) + e * (r = t._hi - i) + n * i + n * r, s = (this._hi - a - u + this._lo - o * t._lo) / t._hi;\n      return new F(u = o + s, o - u + s);\n    }\n\n    if (\"number\" == typeof arguments[0]) {\n      var l = arguments[0];\n      return v.isNaN(l) ? F.createNaN() : F.copy(this).selfDivide(l, 0);\n    }\n  }, F.prototype.ge = function (t) {\n    return (this._hi > t._hi || this._hi === t._hi) && this._lo >= t._lo;\n  }, F.prototype.pow = function (t) {\n    if (0 === t) return F.valueOf(1);\n    var e = new F(this),\n        n = F.valueOf(1),\n        i = Math.abs(t);\n    if (i > 1) for (; i > 0;) i % 2 == 1 && n.selfMultiply(e), (i /= 2) > 0 && (e = e.sqr());else n = e;\n    return t < 0 ? n.reciprocal() : n;\n  }, F.prototype.ceil = function () {\n    if (this.isNaN()) return F.NaN;\n    var t = Math.ceil(this._hi),\n        e = 0;\n    return t === this._hi && (e = Math.ceil(this._lo)), new F(t, e);\n  }, F.prototype.compareTo = function (t) {\n    var e = t;\n    return this._hi < e._hi ? -1 : this._hi > e._hi ? 1 : this._lo < e._lo ? -1 : this._lo > e._lo ? 1 : 0;\n  }, F.prototype.rint = function () {\n    if (this.isNaN()) return this;\n    return this.add(.5).floor();\n  }, F.prototype.setValue = function () {\n    if (arguments[0] instanceof F) {\n      var t = arguments[0];\n      return this.init(t), this;\n    }\n\n    if (\"number\" == typeof arguments[0]) {\n      var e = arguments[0];\n      return this.init(e), this;\n    }\n  }, F.prototype.max = function (t) {\n    return this.ge(t) ? this : t;\n  }, F.prototype.sqrt = function () {\n    if (this.isZero()) return F.valueOf(0);\n    if (this.isNegative()) return F.NaN;\n    var t = 1 / Math.sqrt(this._hi),\n        e = this._hi * t,\n        n = F.valueOf(e),\n        i = this.subtract(n.sqr())._hi * (.5 * t);\n    return n.add(i);\n  }, F.prototype.selfAdd = function () {\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof F) {\n        var t = arguments[0];\n        return this.selfAdd(t._hi, t._lo);\n      }\n\n      if (\"number\" == typeof arguments[0]) {\n        var e = arguments[0],\n            n = null,\n            i = null,\n            r = null,\n            o = null,\n            s = null,\n            a = null;\n        return r = this._hi + e, s = r - this._hi, o = r - s, o = e - s + (this._hi - o), a = o + this._lo, n = r + a, i = a + (r - n), this._hi = n + i, this._lo = i + (n - this._hi), this;\n      }\n    } else if (2 === arguments.length) {\n      var u = arguments[0],\n          l = arguments[1],\n          c = null,\n          p = null,\n          h = null,\n          f = null,\n          g = null,\n          d = null,\n          y = null;\n      f = this._hi + u, p = this._lo + l, g = f - (d = f - this._hi), h = p - (y = p - this._lo);\n\n      var _ = (c = f + (d = (g = u - d + (this._hi - g)) + p)) + (d = (h = l - y + (this._lo - h)) + (d + (f - c))),\n          m = d + (c - _);\n\n      return this._hi = _, this._lo = m, this;\n    }\n  }, F.prototype.selfMultiply = function () {\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof F) {\n        var t = arguments[0];\n        return this.selfMultiply(t._hi, t._lo);\n      }\n\n      if (\"number\" == typeof arguments[0]) {\n        var e = arguments[0];\n        return this.selfMultiply(e, 0);\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = null,\n          o = null,\n          s = null,\n          a = null,\n          u = null,\n          l = null;\n      r = (u = F.SPLIT * this._hi) - this._hi, l = F.SPLIT * n, r = u - r, o = this._hi - r, s = l - n;\n      var c = (u = this._hi * n) + (l = r * (s = l - s) - u + r * (a = n - s) + o * s + o * a + (this._hi * i + this._lo * n)),\n          p = l + (r = u - c);\n      return this._hi = c, this._lo = p, this;\n    }\n  }, F.prototype.selfSqr = function () {\n    return this.selfMultiply(this);\n  }, F.prototype.floor = function () {\n    if (this.isNaN()) return F.NaN;\n    var t = Math.floor(this._hi),\n        e = 0;\n    return t === this._hi && (e = Math.floor(this._lo)), new F(t, e);\n  }, F.prototype.negate = function () {\n    return this.isNaN() ? this : new F(-this._hi, -this._lo);\n  }, F.prototype.clone = function () {}, F.prototype.multiply = function () {\n    if (arguments[0] instanceof F) {\n      var t = arguments[0];\n      return t.isNaN() ? F.createNaN() : F.copy(this).selfMultiply(t);\n    }\n\n    if (\"number\" == typeof arguments[0]) {\n      var e = arguments[0];\n      return v.isNaN(e) ? F.createNaN() : F.copy(this).selfMultiply(e, 0);\n    }\n  }, F.prototype.isNaN = function () {\n    return v.isNaN(this._hi);\n  }, F.prototype.intValue = function () {\n    return Math.trunc(this._hi);\n  }, F.prototype.toString = function () {\n    var t = F.magnitude(this._hi);\n    return t >= -3 && t <= 20 ? this.toStandardNotation() : this.toSciNotation();\n  }, F.prototype.toStandardNotation = function () {\n    var t = this.getSpecialNumberString();\n    if (null !== t) return t;\n    var e = new Array(1).fill(null),\n        n = this.extractSignificantDigits(!0, e),\n        i = e[0] + 1,\n        r = n;\n    if (\".\" === n.charAt(0)) r = \"0\" + n;else if (i < 0) r = \"0.\" + F.stringOfChar(\"0\", -i) + n;else if (-1 === n.indexOf(\".\")) {\n      var o = i - n.length;\n      r = n + F.stringOfChar(\"0\", o) + \".0\";\n    }\n    return this.isNegative() ? \"-\" + r : r;\n  }, F.prototype.reciprocal = function () {\n    var t = null,\n        e = null,\n        n = null,\n        i = null,\n        r = null,\n        o = null,\n        s = null,\n        a = null;\n    e = (r = 1 / this._hi) - (t = (o = F.SPLIT * r) - (t = o - r)), n = (a = F.SPLIT * this._hi) - this._hi;\n    var u = r + (o = (1 - (s = r * this._hi) - (a = t * (n = a - n) - s + t * (i = this._hi - n) + e * n + e * i) - r * this._lo) / this._hi);\n    return new F(u, r - u + o);\n  }, F.prototype.toSciNotation = function () {\n    if (this.isZero()) return F.SCI_NOT_ZERO;\n    var t = this.getSpecialNumberString();\n    if (null !== t) return t;\n    var e = new Array(1).fill(null),\n        n = this.extractSignificantDigits(!1, e),\n        i = F.SCI_NOT_EXPONENT_CHAR + e[0];\n    if (\"0\" === n.charAt(0)) throw new Error(\"Found leading zero: \" + n);\n    var r = \"\";\n    n.length > 1 && (r = n.substring(1));\n    var o = n.charAt(0) + \".\" + r;\n    return this.isNegative() ? \"-\" + o + i : o + i;\n  }, F.prototype.abs = function () {\n    return this.isNaN() ? F.NaN : this.isNegative() ? this.negate() : new F(this);\n  }, F.prototype.isPositive = function () {\n    return (this._hi > 0 || 0 === this._hi) && this._lo > 0;\n  }, F.prototype.lt = function (t) {\n    return (this._hi < t._hi || this._hi === t._hi) && this._lo < t._lo;\n  }, F.prototype.add = function () {\n    if (arguments[0] instanceof F) {\n      var t = arguments[0];\n      return F.copy(this).selfAdd(t);\n    }\n\n    if (\"number\" == typeof arguments[0]) {\n      var e = arguments[0];\n      return F.copy(this).selfAdd(e);\n    }\n  }, F.prototype.init = function () {\n    if (1 === arguments.length) {\n      if (\"number\" == typeof arguments[0]) {\n        var t = arguments[0];\n        this._hi = t, this._lo = 0;\n      } else if (arguments[0] instanceof F) {\n        var e = arguments[0];\n        this._hi = e._hi, this._lo = e._lo;\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1];\n      this._hi = n, this._lo = i;\n    }\n  }, F.prototype.gt = function (t) {\n    return (this._hi > t._hi || this._hi === t._hi) && this._lo > t._lo;\n  }, F.prototype.isNegative = function () {\n    return (this._hi < 0 || 0 === this._hi) && this._lo < 0;\n  }, F.prototype.trunc = function () {\n    return this.isNaN() ? F.NaN : this.isPositive() ? this.floor() : this.ceil();\n  }, F.prototype.signum = function () {\n    return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;\n  }, F.prototype.interfaces_ = function () {\n    return [e, E, x];\n  }, F.prototype.getClass = function () {\n    return F;\n  }, F.sqr = function (t) {\n    return F.valueOf(t).selfMultiply(t);\n  }, F.valueOf = function () {\n    if (\"string\" == typeof arguments[0]) {\n      var t = arguments[0];\n      return F.parse(t);\n    }\n\n    if (\"number\" == typeof arguments[0]) {\n      var e = arguments[0];\n      return new F(e);\n    }\n  }, F.sqrt = function (t) {\n    return F.valueOf(t).sqrt();\n  }, F.parse = function (t) {\n    for (var e = 0, n = t.length; A.isWhitespace(t.charAt(e));) e++;\n\n    var i = !1;\n\n    if (e < n) {\n      var r = t.charAt(e);\n      \"-\" !== r && \"+\" !== r || (e++, \"-\" === r && (i = !0));\n    }\n\n    for (var o = new F(), s = 0, a = 0, u = 0; !(e >= n);) {\n      var l = t.charAt(e);\n\n      if (e++, A.isDigit(l)) {\n        var c = l - \"0\";\n        o.selfMultiply(F.TEN), o.selfAdd(c), s++;\n      } else {\n        if (\".\" !== l) {\n          if (\"e\" === l || \"E\" === l) {\n            var p = t.substring(e);\n\n            try {\n              u = M.parseInt(p);\n            } catch (e) {\n              throw e instanceof Error ? new Error(\"Invalid exponent \" + p + \" in string \" + t) : e;\n            }\n\n            break;\n          }\n\n          throw new Error(\"Unexpected character '\" + l + \"' at position \" + e + \" in string \" + t);\n        }\n\n        a = s;\n      }\n    }\n\n    var h = o,\n        f = s - a - u;\n    if (0 === f) h = o;else if (f > 0) {\n      var g = F.TEN.pow(f);\n      h = o.divide(g);\n    } else if (f < 0) {\n      var d = F.TEN.pow(-f);\n      h = o.multiply(d);\n    }\n    return i ? h.negate() : h;\n  }, F.createNaN = function () {\n    return new F(v.NaN, v.NaN);\n  }, F.copy = function (t) {\n    return new F(t);\n  }, F.magnitude = function (t) {\n    var e = Math.abs(t),\n        n = Math.log(e) / Math.log(10),\n        i = Math.trunc(Math.floor(n));\n    return 10 * Math.pow(10, i) <= e && (i += 1), i;\n  }, F.stringOfChar = function (t, e) {\n    for (var n = new D(), i = 0; i < e; i++) n.append(t);\n\n    return n.toString();\n  }, G.PI.get = function () {\n    return new F(3.141592653589793, 1.2246467991473532e-16);\n  }, G.TWO_PI.get = function () {\n    return new F(6.283185307179586, 2.4492935982947064e-16);\n  }, G.PI_2.get = function () {\n    return new F(1.5707963267948966, 6.123233995736766e-17);\n  }, G.E.get = function () {\n    return new F(2.718281828459045, 1.4456468917292502e-16);\n  }, G.NaN.get = function () {\n    return new F(v.NaN, v.NaN);\n  }, G.EPS.get = function () {\n    return 1.23259516440783e-32;\n  }, G.SPLIT.get = function () {\n    return 134217729;\n  }, G.MAX_PRINT_DIGITS.get = function () {\n    return 32;\n  }, G.TEN.get = function () {\n    return F.valueOf(10);\n  }, G.ONE.get = function () {\n    return F.valueOf(1);\n  }, G.SCI_NOT_EXPONENT_CHAR.get = function () {\n    return \"E\";\n  }, G.SCI_NOT_ZERO.get = function () {\n    return \"0.0E0\";\n  }, Object.defineProperties(F, G);\n\n  var q = function () {},\n      B = {\n    DP_SAFE_EPSILON: {\n      configurable: !0\n    }\n  };\n\n  q.prototype.interfaces_ = function () {\n    return [];\n  }, q.prototype.getClass = function () {\n    return q;\n  }, q.orientationIndex = function (t, e, n) {\n    var i = q.orientationIndexFilter(t, e, n);\n    if (i <= 1) return i;\n    var r = F.valueOf(e.x).selfAdd(-t.x),\n        o = F.valueOf(e.y).selfAdd(-t.y),\n        s = F.valueOf(n.x).selfAdd(-e.x),\n        a = F.valueOf(n.y).selfAdd(-e.y);\n    return r.selfMultiply(a).selfSubtract(o.selfMultiply(s)).signum();\n  }, q.signOfDet2x2 = function (t, e, n, i) {\n    return t.multiply(i).selfSubtract(e.multiply(n)).signum();\n  }, q.intersection = function (t, e, n, i) {\n    var r = F.valueOf(i.y).selfSubtract(n.y).selfMultiply(F.valueOf(e.x).selfSubtract(t.x)),\n        o = F.valueOf(i.x).selfSubtract(n.x).selfMultiply(F.valueOf(e.y).selfSubtract(t.y)),\n        s = r.subtract(o),\n        a = F.valueOf(i.x).selfSubtract(n.x).selfMultiply(F.valueOf(t.y).selfSubtract(n.y)),\n        u = F.valueOf(i.y).selfSubtract(n.y).selfMultiply(F.valueOf(t.x).selfSubtract(n.x)),\n        l = a.subtract(u).selfDivide(s).doubleValue(),\n        c = F.valueOf(t.x).selfAdd(F.valueOf(e.x).selfSubtract(t.x).selfMultiply(l)).doubleValue(),\n        p = F.valueOf(e.x).selfSubtract(t.x).selfMultiply(F.valueOf(t.y).selfSubtract(n.y)),\n        h = F.valueOf(e.y).selfSubtract(t.y).selfMultiply(F.valueOf(t.x).selfSubtract(n.x)),\n        f = p.subtract(h).selfDivide(s).doubleValue(),\n        g = F.valueOf(n.y).selfAdd(F.valueOf(i.y).selfSubtract(n.y).selfMultiply(f)).doubleValue();\n    return new C(c, g);\n  }, q.orientationIndexFilter = function (t, e, n) {\n    var i = null,\n        r = (t.x - n.x) * (e.y - n.y),\n        o = (t.y - n.y) * (e.x - n.x),\n        s = r - o;\n\n    if (r > 0) {\n      if (o <= 0) return q.signum(s);\n      i = r + o;\n    } else {\n      if (!(r < 0)) return q.signum(s);\n      if (o >= 0) return q.signum(s);\n      i = -r - o;\n    }\n\n    var a = q.DP_SAFE_EPSILON * i;\n    return s >= a || -s >= a ? q.signum(s) : 2;\n  }, q.signum = function (t) {\n    return t > 0 ? 1 : t < 0 ? -1 : 0;\n  }, B.DP_SAFE_EPSILON.get = function () {\n    return 1e-15;\n  }, Object.defineProperties(q, B);\n\n  var V = function () {},\n      U = {\n    X: {\n      configurable: !0\n    },\n    Y: {\n      configurable: !0\n    },\n    Z: {\n      configurable: !0\n    },\n    M: {\n      configurable: !0\n    }\n  };\n\n  U.X.get = function () {\n    return 0;\n  }, U.Y.get = function () {\n    return 1;\n  }, U.Z.get = function () {\n    return 2;\n  }, U.M.get = function () {\n    return 3;\n  }, V.prototype.setOrdinate = function (t, e, n) {}, V.prototype.size = function () {}, V.prototype.getOrdinate = function (t, e) {}, V.prototype.getCoordinate = function () {}, V.prototype.getCoordinateCopy = function (t) {}, V.prototype.getDimension = function () {}, V.prototype.getX = function (t) {}, V.prototype.clone = function () {}, V.prototype.expandEnvelope = function (t) {}, V.prototype.copy = function () {}, V.prototype.getY = function (t) {}, V.prototype.toCoordinateArray = function () {}, V.prototype.interfaces_ = function () {\n    return [x];\n  }, V.prototype.getClass = function () {\n    return V;\n  }, Object.defineProperties(V, U);\n\n  var z = function () {},\n      X = function (t) {\n    function e() {\n      t.call(this, \"Projective point not representable on the Cartesian plane.\");\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e;\n  }(z),\n      Y = function () {};\n\n  Y.arraycopy = function (t, e, n, i, r) {\n    for (var o = 0, s = e; s < e + r; s++) n[i + o] = t[s], o++;\n  }, Y.getProperty = function (t) {\n    return {\n      \"line.separator\": \"\\n\"\n    }[t];\n  };\n\n  var k = function t() {\n    if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1;else if (1 === arguments.length) {\n      var e = arguments[0];\n      this.x = e.x, this.y = e.y, this.w = 1;\n    } else if (2 === arguments.length) {\n      if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n        var n = arguments[0],\n            i = arguments[1];\n        this.x = n, this.y = i, this.w = 1;\n      } else if (arguments[0] instanceof t && arguments[1] instanceof t) {\n        var r = arguments[0],\n            o = arguments[1];\n        this.x = r.y * o.w - o.y * r.w, this.y = o.x * r.w - r.x * o.w, this.w = r.x * o.y - o.x * r.y;\n      } else if (arguments[0] instanceof C && arguments[1] instanceof C) {\n        var s = arguments[0],\n            a = arguments[1];\n        this.x = s.y - a.y, this.y = a.x - s.x, this.w = s.x * a.y - a.x * s.y;\n      }\n    } else if (3 === arguments.length) {\n      var u = arguments[0],\n          l = arguments[1],\n          c = arguments[2];\n      this.x = u, this.y = l, this.w = c;\n    } else if (4 === arguments.length) {\n      var p = arguments[0],\n          h = arguments[1],\n          f = arguments[2],\n          g = arguments[3],\n          d = p.y - h.y,\n          y = h.x - p.x,\n          _ = p.x * h.y - h.x * p.y,\n          m = f.y - g.y,\n          v = g.x - f.x,\n          I = f.x * g.y - g.x * f.y;\n\n      this.x = y * I - v * _, this.y = m * _ - d * I, this.w = d * v - m * y;\n    }\n  };\n\n  k.prototype.getY = function () {\n    var t = this.y / this.w;\n    if (v.isNaN(t) || v.isInfinite(t)) throw new X();\n    return t;\n  }, k.prototype.getX = function () {\n    var t = this.x / this.w;\n    if (v.isNaN(t) || v.isInfinite(t)) throw new X();\n    return t;\n  }, k.prototype.getCoordinate = function () {\n    var t = new C();\n    return t.x = this.getX(), t.y = this.getY(), t;\n  }, k.prototype.interfaces_ = function () {\n    return [];\n  }, k.prototype.getClass = function () {\n    return k;\n  }, k.intersection = function (t, e, n, i) {\n    var r = t.y - e.y,\n        o = e.x - t.x,\n        s = t.x * e.y - e.x * t.y,\n        a = n.y - i.y,\n        u = i.x - n.x,\n        l = n.x * i.y - i.x * n.y,\n        c = r * u - a * o,\n        p = (o * l - u * s) / c,\n        h = (a * s - r * l) / c;\n    if (v.isNaN(p) || v.isInfinite(p) || v.isNaN(h) || v.isInfinite(h)) throw new X();\n    return new C(p, h);\n  };\n\n  var j = function t() {\n    if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length) this.init();else if (1 === arguments.length) {\n      if (arguments[0] instanceof C) {\n        var e = arguments[0];\n        this.init(e.x, e.x, e.y, e.y);\n      } else if (arguments[0] instanceof t) {\n        var n = arguments[0];\n        this.init(n);\n      }\n    } else if (2 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1];\n      this.init(i.x, r.x, i.y, r.y);\n    } else if (4 === arguments.length) {\n      var o = arguments[0],\n          s = arguments[1],\n          a = arguments[2],\n          u = arguments[3];\n      this.init(o, s, a, u);\n    }\n  },\n      H = {\n    serialVersionUID: {\n      configurable: !0\n    }\n  };\n\n  j.prototype.getArea = function () {\n    return this.getWidth() * this.getHeight();\n  }, j.prototype.equals = function (t) {\n    if (!(t instanceof j)) return !1;\n    var e = t;\n    return this.isNull() ? e.isNull() : this._maxx === e.getMaxX() && this._maxy === e.getMaxY() && this._minx === e.getMinX() && this._miny === e.getMinY();\n  }, j.prototype.intersection = function (t) {\n    if (this.isNull() || t.isNull() || !this.intersects(t)) return new j();\n    var e = this._minx > t._minx ? this._minx : t._minx,\n        n = this._miny > t._miny ? this._miny : t._miny,\n        i = this._maxx < t._maxx ? this._maxx : t._maxx,\n        r = this._maxy < t._maxy ? this._maxy : t._maxy;\n    return new j(e, i, n, r);\n  }, j.prototype.isNull = function () {\n    return this._maxx < this._minx;\n  }, j.prototype.getMaxX = function () {\n    return this._maxx;\n  }, j.prototype.covers = function () {\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof C) {\n        var t = arguments[0];\n        return this.covers(t.x, t.y);\n      }\n\n      if (arguments[0] instanceof j) {\n        var e = arguments[0];\n        return !this.isNull() && !e.isNull() && e.getMinX() >= this._minx && e.getMaxX() <= this._maxx && e.getMinY() >= this._miny && e.getMaxY() <= this._maxy;\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1];\n      return !this.isNull() && n >= this._minx && n <= this._maxx && i >= this._miny && i <= this._maxy;\n    }\n  }, j.prototype.intersects = function () {\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof j) {\n        var t = arguments[0];\n        return !this.isNull() && !t.isNull() && !(t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny);\n      }\n\n      if (arguments[0] instanceof C) {\n        var e = arguments[0];\n        return this.intersects(e.x, e.y);\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1];\n      return !this.isNull() && !(n > this._maxx || n < this._minx || i > this._maxy || i < this._miny);\n    }\n  }, j.prototype.getMinY = function () {\n    return this._miny;\n  }, j.prototype.getMinX = function () {\n    return this._minx;\n  }, j.prototype.expandToInclude = function () {\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof C) {\n        var t = arguments[0];\n        this.expandToInclude(t.x, t.y);\n      } else if (arguments[0] instanceof j) {\n        var e = arguments[0];\n        if (e.isNull()) return null;\n        this.isNull() ? (this._minx = e.getMinX(), this._maxx = e.getMaxX(), this._miny = e.getMinY(), this._maxy = e.getMaxY()) : (e._minx < this._minx && (this._minx = e._minx), e._maxx > this._maxx && (this._maxx = e._maxx), e._miny < this._miny && (this._miny = e._miny), e._maxy > this._maxy && (this._maxy = e._maxy));\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1];\n      this.isNull() ? (this._minx = n, this._maxx = n, this._miny = i, this._maxy = i) : (n < this._minx && (this._minx = n), n > this._maxx && (this._maxx = n), i < this._miny && (this._miny = i), i > this._maxy && (this._maxy = i));\n    }\n  }, j.prototype.minExtent = function () {\n    if (this.isNull()) return 0;\n    var t = this.getWidth(),\n        e = this.getHeight();\n    return t < e ? t : e;\n  }, j.prototype.getWidth = function () {\n    return this.isNull() ? 0 : this._maxx - this._minx;\n  }, j.prototype.compareTo = function (t) {\n    var e = t;\n    return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this._minx < e._minx ? -1 : this._minx > e._minx ? 1 : this._miny < e._miny ? -1 : this._miny > e._miny ? 1 : this._maxx < e._maxx ? -1 : this._maxx > e._maxx ? 1 : this._maxy < e._maxy ? -1 : this._maxy > e._maxy ? 1 : 0;\n  }, j.prototype.translate = function (t, e) {\n    if (this.isNull()) return null;\n    this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e);\n  }, j.prototype.toString = function () {\n    return \"Env[\" + this._minx + \" : \" + this._maxx + \", \" + this._miny + \" : \" + this._maxy + \"]\";\n  }, j.prototype.setToNull = function () {\n    this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;\n  }, j.prototype.getHeight = function () {\n    return this.isNull() ? 0 : this._maxy - this._miny;\n  }, j.prototype.maxExtent = function () {\n    if (this.isNull()) return 0;\n    var t = this.getWidth(),\n        e = this.getHeight();\n    return t > e ? t : e;\n  }, j.prototype.expandBy = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.expandBy(t, t);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      if (this.isNull()) return null;\n      this._minx -= e, this._maxx += e, this._miny -= n, this._maxy += n, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();\n    }\n  }, j.prototype.contains = function () {\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof j) {\n        var t = arguments[0];\n        return this.covers(t);\n      }\n\n      if (arguments[0] instanceof C) {\n        var e = arguments[0];\n        return this.covers(e);\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1];\n      return this.covers(n, i);\n    }\n  }, j.prototype.centre = function () {\n    return this.isNull() ? null : new C((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);\n  }, j.prototype.init = function () {\n    if (0 === arguments.length) this.setToNull();else if (1 === arguments.length) {\n      if (arguments[0] instanceof C) {\n        var t = arguments[0];\n        this.init(t.x, t.x, t.y, t.y);\n      } else if (arguments[0] instanceof j) {\n        var e = arguments[0];\n        this._minx = e._minx, this._maxx = e._maxx, this._miny = e._miny, this._maxy = e._maxy;\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1];\n      this.init(n.x, i.x, n.y, i.y);\n    } else if (4 === arguments.length) {\n      var r = arguments[0],\n          o = arguments[1],\n          s = arguments[2],\n          a = arguments[3];\n      r < o ? (this._minx = r, this._maxx = o) : (this._minx = o, this._maxx = r), s < a ? (this._miny = s, this._maxy = a) : (this._miny = a, this._maxy = s);\n    }\n  }, j.prototype.getMaxY = function () {\n    return this._maxy;\n  }, j.prototype.distance = function (t) {\n    if (this.intersects(t)) return 0;\n    var e = 0;\n    this._maxx < t._minx ? e = t._minx - this._maxx : this._minx > t._maxx && (e = this._minx - t._maxx);\n    var n = 0;\n    return this._maxy < t._miny ? n = t._miny - this._maxy : this._miny > t._maxy && (n = this._miny - t._maxy), 0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n);\n  }, j.prototype.hashCode = function () {\n    var t = 17;\n    return t = 37 * t + C.hashCode(this._minx), t = 37 * t + C.hashCode(this._maxx), t = 37 * t + C.hashCode(this._miny), t = 37 * t + C.hashCode(this._maxy);\n  }, j.prototype.interfaces_ = function () {\n    return [E, e];\n  }, j.prototype.getClass = function () {\n    return j;\n  }, j.intersects = function () {\n    if (3 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1],\n          n = arguments[2];\n      return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y);\n    }\n\n    if (4 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1],\n          o = arguments[2],\n          s = arguments[3],\n          a = Math.min(o.x, s.x),\n          u = Math.max(o.x, s.x),\n          l = Math.min(i.x, r.x),\n          c = Math.max(i.x, r.x);\n      return !(l > u) && !(c < a) && (a = Math.min(o.y, s.y), u = Math.max(o.y, s.y), l = Math.min(i.y, r.y), c = Math.max(i.y, r.y), !(l > u) && !(c < a));\n    }\n  }, H.serialVersionUID.get = function () {\n    return 0x51845cd552189800;\n  }, Object.defineProperties(j, H);\n\n  var W = {\n    typeStr: /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n    emptyTypeStr: /^\\s*(\\w+)\\s*EMPTY\\s*$/,\n    spaces: /\\s+/,\n    parenComma: /\\)\\s*,\\s*\\(/,\n    doubleParenComma: /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/,\n    trimParens: /^\\s*\\(?(.*?)\\)?\\s*$/\n  },\n      K = function (t) {\n    this.geometryFactory = t || new _e();\n  };\n\n  K.prototype.read = function (t) {\n    var e, n, i;\n    t = t.replace(/[\\n\\r]/g, \" \");\n    var r = W.typeStr.exec(t);\n    if (-1 !== t.search(\"EMPTY\") && ((r = W.emptyTypeStr.exec(t))[2] = void 0), r && (n = r[1].toLowerCase(), i = r[2], Q[n] && (e = Q[n].apply(this, [i]))), void 0 === e) throw new Error(\"Could not parse WKT \" + t);\n    return e;\n  }, K.prototype.write = function (t) {\n    return this.extractGeometry(t);\n  }, K.prototype.extractGeometry = function (t) {\n    var e = t.getGeometryType().toLowerCase();\n    if (!J[e]) return null;\n    var n = e.toUpperCase();\n    return t.isEmpty() ? n + \" EMPTY\" : n + \"(\" + J[e].apply(this, [t]) + \")\";\n  };\n\n  var J = {\n    coordinate: function (t) {\n      return t.x + \" \" + t.y;\n    },\n    point: function (t) {\n      return J.coordinate.call(this, t._coordinates._coordinates[0]);\n    },\n    multipoint: function (t) {\n      for (var e = [], n = 0, i = t._geometries.length; n < i; ++n) e.push(\"(\" + J.point.apply(this, [t._geometries[n]]) + \")\");\n\n      return e.join(\",\");\n    },\n    linestring: function (t) {\n      for (var e = [], n = 0, i = t._points._coordinates.length; n < i; ++n) e.push(J.coordinate.apply(this, [t._points._coordinates[n]]));\n\n      return e.join(\",\");\n    },\n    linearring: function (t) {\n      for (var e = [], n = 0, i = t._points._coordinates.length; n < i; ++n) e.push(J.coordinate.apply(this, [t._points._coordinates[n]]));\n\n      return e.join(\",\");\n    },\n    multilinestring: function (t) {\n      for (var e = [], n = 0, i = t._geometries.length; n < i; ++n) e.push(\"(\" + J.linestring.apply(this, [t._geometries[n]]) + \")\");\n\n      return e.join(\",\");\n    },\n    polygon: function (t) {\n      var e = [];\n      e.push(\"(\" + J.linestring.apply(this, [t._shell]) + \")\");\n\n      for (var n = 0, i = t._holes.length; n < i; ++n) e.push(\"(\" + J.linestring.apply(this, [t._holes[n]]) + \")\");\n\n      return e.join(\",\");\n    },\n    multipolygon: function (t) {\n      for (var e = [], n = 0, i = t._geometries.length; n < i; ++n) e.push(\"(\" + J.polygon.apply(this, [t._geometries[n]]) + \")\");\n\n      return e.join(\",\");\n    },\n    geometrycollection: function (t) {\n      for (var e = [], n = 0, i = t._geometries.length; n < i; ++n) e.push(this.extractGeometry(t._geometries[n]));\n\n      return e.join(\",\");\n    }\n  },\n      Q = {\n    point: function (t) {\n      if (void 0 === t) return this.geometryFactory.createPoint();\n      var e = t.trim().split(W.spaces);\n      return this.geometryFactory.createPoint(new C(Number.parseFloat(e[0]), Number.parseFloat(e[1])));\n    },\n    multipoint: function (t) {\n      if (void 0 === t) return this.geometryFactory.createMultiPoint();\n\n      for (var e, n = t.trim().split(\",\"), i = [], r = 0, o = n.length; r < o; ++r) e = n[r].replace(W.trimParens, \"$1\"), i.push(Q.point.apply(this, [e]));\n\n      return this.geometryFactory.createMultiPoint(i);\n    },\n    linestring: function (t) {\n      if (void 0 === t) return this.geometryFactory.createLineString();\n\n      for (var e, n = t.trim().split(\",\"), i = [], r = 0, o = n.length; r < o; ++r) e = n[r].trim().split(W.spaces), i.push(new C(Number.parseFloat(e[0]), Number.parseFloat(e[1])));\n\n      return this.geometryFactory.createLineString(i);\n    },\n    linearring: function (t) {\n      if (void 0 === t) return this.geometryFactory.createLinearRing();\n\n      for (var e, n = t.trim().split(\",\"), i = [], r = 0, o = n.length; r < o; ++r) e = n[r].trim().split(W.spaces), i.push(new C(Number.parseFloat(e[0]), Number.parseFloat(e[1])));\n\n      return this.geometryFactory.createLinearRing(i);\n    },\n    multilinestring: function (t) {\n      if (void 0 === t) return this.geometryFactory.createMultiLineString();\n\n      for (var e, n = t.trim().split(W.parenComma), i = [], r = 0, o = n.length; r < o; ++r) e = n[r].replace(W.trimParens, \"$1\"), i.push(Q.linestring.apply(this, [e]));\n\n      return this.geometryFactory.createMultiLineString(i);\n    },\n    polygon: function (t) {\n      if (void 0 === t) return this.geometryFactory.createPolygon();\n\n      for (var e, n, i, r, o = t.trim().split(W.parenComma), s = [], a = 0, u = o.length; a < u; ++a) e = o[a].replace(W.trimParens, \"$1\"), n = Q.linestring.apply(this, [e]), i = this.geometryFactory.createLinearRing(n._points), 0 === a ? r = i : s.push(i);\n\n      return this.geometryFactory.createPolygon(r, s);\n    },\n    multipolygon: function (t) {\n      if (void 0 === t) return this.geometryFactory.createMultiPolygon();\n\n      for (var e, n = t.trim().split(W.doubleParenComma), i = [], r = 0, o = n.length; r < o; ++r) e = n[r].replace(W.trimParens, \"$1\"), i.push(Q.polygon.apply(this, [e]));\n\n      return this.geometryFactory.createMultiPolygon(i);\n    },\n    geometrycollection: function (t) {\n      if (void 0 === t) return this.geometryFactory.createGeometryCollection();\n\n      for (var e = (t = t.replace(/,\\s*([A-Za-z])/g, \"|$1\")).trim().split(\"|\"), n = [], i = 0, r = e.length; i < r; ++i) n.push(this.read(e[i]));\n\n      return this.geometryFactory.createGeometryCollection(n);\n    }\n  },\n      Z = function (t) {\n    this.parser = new K(t);\n  };\n\n  Z.prototype.write = function (t) {\n    return this.parser.write(t);\n  }, Z.toLineString = function (t, e) {\n    if (2 !== arguments.length) throw new Error(\"Not implemented\");\n    return \"LINESTRING ( \" + t.x + \" \" + t.y + \", \" + e.x + \" \" + e.y + \" )\";\n  };\n\n  var $ = function (t) {\n    function e(e) {\n      t.call(this, e), this.name = \"RuntimeException\", this.message = e, this.stack = new t().stack;\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e;\n  }(Error),\n      tt = function (t) {\n    function e() {\n      if (t.call(this), 0 === arguments.length) t.call(this);else if (1 === arguments.length) {\n        var e = arguments[0];\n        t.call(this, e);\n      }\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e;\n  }($),\n      et = function () {};\n\n  et.prototype.interfaces_ = function () {\n    return [];\n  }, et.prototype.getClass = function () {\n    return et;\n  }, et.shouldNeverReachHere = function () {\n    if (0 === arguments.length) et.shouldNeverReachHere(null);else if (1 === arguments.length) {\n      var t = arguments[0];\n      throw new tt(\"Should never reach here\" + (null !== t ? \": \" + t : \"\"));\n    }\n  }, et.isTrue = function () {\n    var t, e;\n    if (1 === arguments.length) t = arguments[0], et.isTrue(t, null);else if (2 === arguments.length && (t = arguments[0], e = arguments[1], !t)) throw null === e ? new tt() : new tt(e);\n  }, et.equals = function () {\n    var t, e, n;\n    if (2 === arguments.length) t = arguments[0], e = arguments[1], et.equals(t, e, null);else if (3 === arguments.length && (t = arguments[0], e = arguments[1], n = arguments[2], !e.equals(t))) throw new tt(\"Expected \" + t + \" but encountered \" + e + (null !== n ? \": \" + n : \"\"));\n  };\n\n  var nt = function () {\n    this._result = null, this._inputLines = Array(2).fill().map(function () {\n      return Array(2);\n    }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new C(), this._intPt[1] = new C(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;\n  },\n      it = {\n    DONT_INTERSECT: {\n      configurable: !0\n    },\n    DO_INTERSECT: {\n      configurable: !0\n    },\n    COLLINEAR: {\n      configurable: !0\n    },\n    NO_INTERSECTION: {\n      configurable: !0\n    },\n    POINT_INTERSECTION: {\n      configurable: !0\n    },\n    COLLINEAR_INTERSECTION: {\n      configurable: !0\n    }\n  };\n\n  nt.prototype.getIndexAlongSegment = function (t, e) {\n    return this.computeIntLineIndex(), this._intLineIndex[t][e];\n  }, nt.prototype.getTopologySummary = function () {\n    var t = new D();\n    return this.isEndPoint() && t.append(\" endpoint\"), this._isProper && t.append(\" proper\"), this.isCollinear() && t.append(\" collinear\"), t.toString();\n  }, nt.prototype.computeIntersection = function (t, e, n, i) {\n    this._inputLines[0][0] = t, this._inputLines[0][1] = e, this._inputLines[1][0] = n, this._inputLines[1][1] = i, this._result = this.computeIntersect(t, e, n, i);\n  }, nt.prototype.getIntersectionNum = function () {\n    return this._result;\n  }, nt.prototype.computeIntLineIndex = function () {\n    if (0 === arguments.length) null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map(function () {\n      return Array(2);\n    }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));else if (1 === arguments.length) {\n      var t = arguments[0];\n      this.getEdgeDistance(t, 0) > this.getEdgeDistance(t, 1) ? (this._intLineIndex[t][0] = 0, this._intLineIndex[t][1] = 1) : (this._intLineIndex[t][0] = 1, this._intLineIndex[t][1] = 0);\n    }\n  }, nt.prototype.isProper = function () {\n    return this.hasIntersection() && this._isProper;\n  }, nt.prototype.setPrecisionModel = function (t) {\n    this._precisionModel = t;\n  }, nt.prototype.isInteriorIntersection = function () {\n    if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);\n\n    if (1 === arguments.length) {\n      for (var t = arguments[0], e = 0; e < this._result; e++) if (!this._intPt[e].equals2D(this._inputLines[t][0]) && !this._intPt[e].equals2D(this._inputLines[t][1])) return !0;\n\n      return !1;\n    }\n  }, nt.prototype.getIntersection = function (t) {\n    return this._intPt[t];\n  }, nt.prototype.isEndPoint = function () {\n    return this.hasIntersection() && !this._isProper;\n  }, nt.prototype.hasIntersection = function () {\n    return this._result !== nt.NO_INTERSECTION;\n  }, nt.prototype.getEdgeDistance = function (t, e) {\n    return nt.computeEdgeDistance(this._intPt[e], this._inputLines[t][0], this._inputLines[t][1]);\n  }, nt.prototype.isCollinear = function () {\n    return this._result === nt.COLLINEAR_INTERSECTION;\n  }, nt.prototype.toString = function () {\n    return Z.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + \" - \" + Z.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();\n  }, nt.prototype.getEndpoint = function (t, e) {\n    return this._inputLines[t][e];\n  }, nt.prototype.isIntersection = function (t) {\n    for (var e = 0; e < this._result; e++) if (this._intPt[e].equals2D(t)) return !0;\n\n    return !1;\n  }, nt.prototype.getIntersectionAlongSegment = function (t, e) {\n    return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]];\n  }, nt.prototype.interfaces_ = function () {\n    return [];\n  }, nt.prototype.getClass = function () {\n    return nt;\n  }, nt.computeEdgeDistance = function (t, e, n) {\n    var i = Math.abs(n.x - e.x),\n        r = Math.abs(n.y - e.y),\n        o = -1;\n    if (t.equals(e)) o = 0;else if (t.equals(n)) o = i > r ? i : r;else {\n      var s = Math.abs(t.x - e.x),\n          a = Math.abs(t.y - e.y);\n      0 !== (o = i > r ? s : a) || t.equals(e) || (o = Math.max(s, a));\n    }\n    return et.isTrue(!(0 === o && !t.equals(e)), \"Bad distance calculation\"), o;\n  }, nt.nonRobustComputeEdgeDistance = function (t, e, n) {\n    var i = t.x - e.x,\n        r = t.y - e.y,\n        o = Math.sqrt(i * i + r * r);\n    return et.isTrue(!(0 === o && !t.equals(e)), \"Invalid distance calculation\"), o;\n  }, it.DONT_INTERSECT.get = function () {\n    return 0;\n  }, it.DO_INTERSECT.get = function () {\n    return 1;\n  }, it.COLLINEAR.get = function () {\n    return 2;\n  }, it.NO_INTERSECTION.get = function () {\n    return 0;\n  }, it.POINT_INTERSECTION.get = function () {\n    return 1;\n  }, it.COLLINEAR_INTERSECTION.get = function () {\n    return 2;\n  }, Object.defineProperties(nt, it);\n\n  var rt = function (t) {\n    function e() {\n      t.apply(this, arguments);\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isInSegmentEnvelopes = function (t) {\n      var e = new j(this._inputLines[0][0], this._inputLines[0][1]),\n          n = new j(this._inputLines[1][0], this._inputLines[1][1]);\n      return e.contains(t) && n.contains(t);\n    }, e.prototype.computeIntersection = function () {\n      if (3 !== arguments.length) return t.prototype.computeIntersection.apply(this, arguments);\n      var e = arguments[0],\n          n = arguments[1],\n          i = arguments[2];\n      if (this._isProper = !1, j.intersects(n, i, e) && 0 === at.orientationIndex(n, i, e) && 0 === at.orientationIndex(i, n, e)) return this._isProper = !0, (e.equals(n) || e.equals(i)) && (this._isProper = !1), this._result = t.POINT_INTERSECTION, null;\n      this._result = t.NO_INTERSECTION;\n    }, e.prototype.normalizeToMinimum = function (t, e, n, i, r) {\n      r.x = this.smallestInAbsValue(t.x, e.x, n.x, i.x), r.y = this.smallestInAbsValue(t.y, e.y, n.y, i.y), t.x -= r.x, t.y -= r.y, e.x -= r.x, e.y -= r.y, n.x -= r.x, n.y -= r.y, i.x -= r.x, i.y -= r.y;\n    }, e.prototype.safeHCoordinateIntersection = function (t, n, i, r) {\n      var o = null;\n\n      try {\n        o = k.intersection(t, n, i, r);\n      } catch (s) {\n        if (!(s instanceof X)) throw s;\n        o = e.nearestEndpoint(t, n, i, r);\n      }\n\n      return o;\n    }, e.prototype.intersection = function (t, n, i, r) {\n      var o = this.intersectionWithNormalization(t, n, i, r);\n      return this.isInSegmentEnvelopes(o) || (o = new C(e.nearestEndpoint(t, n, i, r))), null !== this._precisionModel && this._precisionModel.makePrecise(o), o;\n    }, e.prototype.smallestInAbsValue = function (t, e, n, i) {\n      var r = t,\n          o = Math.abs(r);\n      return Math.abs(e) < o && (r = e, o = Math.abs(e)), Math.abs(n) < o && (r = n, o = Math.abs(n)), Math.abs(i) < o && (r = i), r;\n    }, e.prototype.checkDD = function (t, e, n, i, r) {\n      var o = q.intersection(t, e, n, i),\n          s = this.isInSegmentEnvelopes(o);\n      Y.out.println(\"DD in env = \" + s + \"  --------------------- \" + o), r.distance(o) > 1e-4 && Y.out.println(\"Distance = \" + r.distance(o));\n    }, e.prototype.intersectionWithNormalization = function (t, e, n, i) {\n      var r = new C(t),\n          o = new C(e),\n          s = new C(n),\n          a = new C(i),\n          u = new C();\n      this.normalizeToEnvCentre(r, o, s, a, u);\n      var l = this.safeHCoordinateIntersection(r, o, s, a);\n      return l.x += u.x, l.y += u.y, l;\n    }, e.prototype.computeCollinearIntersection = function (e, n, i, r) {\n      var o = j.intersects(e, n, i),\n          s = j.intersects(e, n, r),\n          a = j.intersects(i, r, e),\n          u = j.intersects(i, r, n);\n      return o && s ? (this._intPt[0] = i, this._intPt[1] = r, t.COLLINEAR_INTERSECTION) : a && u ? (this._intPt[0] = e, this._intPt[1] = n, t.COLLINEAR_INTERSECTION) : o && a ? (this._intPt[0] = i, this._intPt[1] = e, !i.equals(e) || s || u ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : o && u ? (this._intPt[0] = i, this._intPt[1] = n, !i.equals(n) || s || a ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : s && a ? (this._intPt[0] = r, this._intPt[1] = e, !r.equals(e) || o || u ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : s && u ? (this._intPt[0] = r, this._intPt[1] = n, !r.equals(n) || o || a ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : t.NO_INTERSECTION;\n    }, e.prototype.normalizeToEnvCentre = function (t, e, n, i, r) {\n      var o = t.x < e.x ? t.x : e.x,\n          s = t.y < e.y ? t.y : e.y,\n          a = t.x > e.x ? t.x : e.x,\n          u = t.y > e.y ? t.y : e.y,\n          l = n.x < i.x ? n.x : i.x,\n          c = n.y < i.y ? n.y : i.y,\n          p = n.x > i.x ? n.x : i.x,\n          h = n.y > i.y ? n.y : i.y,\n          f = ((o > l ? o : l) + (a < p ? a : p)) / 2,\n          g = ((s > c ? s : c) + (u < h ? u : h)) / 2;\n      r.x = f, r.y = g, t.x -= r.x, t.y -= r.y, e.x -= r.x, e.y -= r.y, n.x -= r.x, n.y -= r.y, i.x -= r.x, i.y -= r.y;\n    }, e.prototype.computeIntersect = function (e, n, i, r) {\n      if (this._isProper = !1, !j.intersects(e, n, i, r)) return t.NO_INTERSECTION;\n      var o = at.orientationIndex(e, n, i),\n          s = at.orientationIndex(e, n, r);\n      if (o > 0 && s > 0 || o < 0 && s < 0) return t.NO_INTERSECTION;\n      var a = at.orientationIndex(i, r, e),\n          u = at.orientationIndex(i, r, n);\n      if (a > 0 && u > 0 || a < 0 && u < 0) return t.NO_INTERSECTION;\n      return 0 === o && 0 === s && 0 === a && 0 === u ? this.computeCollinearIntersection(e, n, i, r) : (0 === o || 0 === s || 0 === a || 0 === u ? (this._isProper = !1, e.equals2D(i) || e.equals2D(r) ? this._intPt[0] = e : n.equals2D(i) || n.equals2D(r) ? this._intPt[0] = n : 0 === o ? this._intPt[0] = new C(i) : 0 === s ? this._intPt[0] = new C(r) : 0 === a ? this._intPt[0] = new C(e) : 0 === u && (this._intPt[0] = new C(n))) : (this._isProper = !0, this._intPt[0] = this.intersection(e, n, i, r)), t.POINT_INTERSECTION);\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e.nearestEndpoint = function (t, e, n, i) {\n      var r = t,\n          o = at.distancePointLine(t, n, i),\n          s = at.distancePointLine(e, n, i);\n      return s < o && (o = s, r = e), (s = at.distancePointLine(n, t, e)) < o && (o = s, r = n), (s = at.distancePointLine(i, t, e)) < o && (o = s, r = i), r;\n    }, e;\n  }(nt),\n      ot = function () {};\n\n  ot.prototype.interfaces_ = function () {\n    return [];\n  }, ot.prototype.getClass = function () {\n    return ot;\n  }, ot.orientationIndex = function (t, e, n) {\n    var i = e.x - t.x,\n        r = e.y - t.y,\n        o = n.x - e.x,\n        s = n.y - e.y;\n    return ot.signOfDet2x2(i, r, o, s);\n  }, ot.signOfDet2x2 = function (t, e, n, i) {\n    var r = null,\n        o = null,\n        s = null;\n    if (r = 1, 0 === t || 0 === i) return 0 === e || 0 === n ? 0 : e > 0 ? n > 0 ? -r : r : n > 0 ? r : -r;\n    if (0 === e || 0 === n) return i > 0 ? t > 0 ? r : -r : t > 0 ? -r : r;\n\n    if (e > 0 ? i > 0 ? e <= i || (r = -r, o = t, t = n, n = o, o = e, e = i, i = o) : e <= -i ? (r = -r, n = -n, i = -i) : (o = t, t = -n, n = o, o = e, e = -i, i = o) : i > 0 ? -e <= i ? (r = -r, t = -t, e = -e) : (o = -t, t = n, n = o, o = -e, e = i, i = o) : e >= i ? (t = -t, e = -e, n = -n, i = -i) : (r = -r, o = -t, t = -n, n = o, o = -e, e = -i, i = o), t > 0) {\n      if (!(n > 0)) return r;\n      if (!(t <= n)) return r;\n    } else {\n      if (n > 0) return -r;\n      if (!(t >= n)) return -r;\n      r = -r, t = -t, n = -n;\n    }\n\n    for (;;) {\n      if (s = Math.floor(n / t), n -= s * t, (i -= s * e) < 0) return -r;\n      if (i > e) return r;\n\n      if (t > n + n) {\n        if (e < i + i) return r;\n      } else {\n        if (e > i + i) return -r;\n        n = t - n, i = e - i, r = -r;\n      }\n\n      if (0 === i) return 0 === n ? 0 : -r;\n      if (0 === n) return r;\n      if (s = Math.floor(t / n), t -= s * n, (e -= s * i) < 0) return r;\n      if (e > i) return -r;\n\n      if (n > t + t) {\n        if (i < e + e) return -r;\n      } else {\n        if (i > e + e) return r;\n        t = n - t, e = i - e, r = -r;\n      }\n\n      if (0 === e) return 0 === t ? 0 : r;\n      if (0 === t) return -r;\n    }\n  };\n\n  var st = function () {\n    this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1;\n    var t = arguments[0];\n    this._p = t;\n  };\n\n  st.prototype.countSegment = function (t, e) {\n    if (t.x < this._p.x && e.x < this._p.x) return null;\n    if (this._p.x === e.x && this._p.y === e.y) return this._isPointOnSegment = !0, null;\n\n    if (t.y === this._p.y && e.y === this._p.y) {\n      var n = t.x,\n          i = e.x;\n      return n > i && (n = e.x, i = t.x), this._p.x >= n && this._p.x <= i && (this._isPointOnSegment = !0), null;\n    }\n\n    if (t.y > this._p.y && e.y <= this._p.y || e.y > this._p.y && t.y <= this._p.y) {\n      var r = t.x - this._p.x,\n          o = t.y - this._p.y,\n          s = e.x - this._p.x,\n          a = e.y - this._p.y,\n          u = ot.signOfDet2x2(r, o, s, a);\n      if (0 === u) return this._isPointOnSegment = !0, null;\n      a < o && (u = -u), u > 0 && this._crossingCount++;\n    }\n  }, st.prototype.isPointInPolygon = function () {\n    return this.getLocation() !== w.EXTERIOR;\n  }, st.prototype.getLocation = function () {\n    return this._isPointOnSegment ? w.BOUNDARY : this._crossingCount % 2 == 1 ? w.INTERIOR : w.EXTERIOR;\n  }, st.prototype.isOnSegment = function () {\n    return this._isPointOnSegment;\n  }, st.prototype.interfaces_ = function () {\n    return [];\n  }, st.prototype.getClass = function () {\n    return st;\n  }, st.locatePointInRing = function () {\n    if (arguments[0] instanceof C && T(arguments[1], V)) {\n      for (var t = arguments[0], e = arguments[1], n = new st(t), i = new C(), r = new C(), o = 1; o < e.size(); o++) if (e.getCoordinate(o, i), e.getCoordinate(o - 1, r), n.countSegment(i, r), n.isOnSegment()) return n.getLocation();\n\n      return n.getLocation();\n    }\n\n    if (arguments[0] instanceof C && arguments[1] instanceof Array) {\n      for (var s = arguments[0], a = arguments[1], u = new st(s), l = 1; l < a.length; l++) {\n        var c = a[l],\n            p = a[l - 1];\n        if (u.countSegment(c, p), u.isOnSegment()) return u.getLocation();\n      }\n\n      return u.getLocation();\n    }\n  };\n\n  var at = function () {},\n      ut = {\n    CLOCKWISE: {\n      configurable: !0\n    },\n    RIGHT: {\n      configurable: !0\n    },\n    COUNTERCLOCKWISE: {\n      configurable: !0\n    },\n    LEFT: {\n      configurable: !0\n    },\n    COLLINEAR: {\n      configurable: !0\n    },\n    STRAIGHT: {\n      configurable: !0\n    }\n  };\n\n  at.prototype.interfaces_ = function () {\n    return [];\n  }, at.prototype.getClass = function () {\n    return at;\n  }, at.orientationIndex = function (t, e, n) {\n    return q.orientationIndex(t, e, n);\n  }, at.signedArea = function () {\n    if (arguments[0] instanceof Array) {\n      var t = arguments[0];\n      if (t.length < 3) return 0;\n\n      for (var e = 0, n = t[0].x, i = 1; i < t.length - 1; i++) {\n        var r = t[i].x - n,\n            o = t[i + 1].y;\n        e += r * (t[i - 1].y - o);\n      }\n\n      return e / 2;\n    }\n\n    if (T(arguments[0], V)) {\n      var s = arguments[0],\n          a = s.size();\n      if (a < 3) return 0;\n      var u = new C(),\n          l = new C(),\n          c = new C();\n      s.getCoordinate(0, l), s.getCoordinate(1, c);\n      var p = l.x;\n      c.x -= p;\n\n      for (var h = 0, f = 1; f < a - 1; f++) u.y = l.y, l.x = c.x, l.y = c.y, s.getCoordinate(f + 1, c), c.x -= p, h += l.x * (u.y - c.y);\n\n      return h / 2;\n    }\n  }, at.distanceLineLine = function (t, e, n, i) {\n    if (t.equals(e)) return at.distancePointLine(t, n, i);\n    if (n.equals(i)) return at.distancePointLine(i, t, e);\n    var r = !1;\n\n    if (j.intersects(t, e, n, i)) {\n      var o = (e.x - t.x) * (i.y - n.y) - (e.y - t.y) * (i.x - n.x);\n      if (0 === o) r = !0;else {\n        var s = (t.y - n.y) * (i.x - n.x) - (t.x - n.x) * (i.y - n.y),\n            a = ((t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y)) / o,\n            u = s / o;\n        (u < 0 || u > 1 || a < 0 || a > 1) && (r = !0);\n      }\n    } else r = !0;\n\n    return r ? R.min(at.distancePointLine(t, n, i), at.distancePointLine(e, n, i), at.distancePointLine(n, t, e), at.distancePointLine(i, t, e)) : 0;\n  }, at.isPointInRing = function (t, e) {\n    return at.locatePointInRing(t, e) !== w.EXTERIOR;\n  }, at.computeLength = function (t) {\n    var e = t.size();\n    if (e <= 1) return 0;\n    var n = 0,\n        i = new C();\n    t.getCoordinate(0, i);\n\n    for (var r = i.x, o = i.y, s = 1; s < e; s++) {\n      t.getCoordinate(s, i);\n      var a = i.x,\n          u = i.y,\n          l = a - r,\n          c = u - o;\n      n += Math.sqrt(l * l + c * c), r = a, o = u;\n    }\n\n    return n;\n  }, at.isCCW = function (t) {\n    var e = t.length - 1;\n    if (e < 3) throw new m(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n\n    for (var n = t[0], i = 0, r = 1; r <= e; r++) {\n      var o = t[r];\n      o.y > n.y && (n = o, i = r);\n    }\n\n    var s = i;\n\n    do {\n      (s -= 1) < 0 && (s = e);\n    } while (t[s].equals2D(n) && s !== i);\n\n    var a = i;\n\n    do {\n      a = (a + 1) % e;\n    } while (t[a].equals2D(n) && a !== i);\n\n    var u = t[s],\n        l = t[a];\n    if (u.equals2D(n) || l.equals2D(n) || u.equals2D(l)) return !1;\n    var c = at.computeOrientation(u, n, l),\n        p = !1;\n    return p = 0 === c ? u.x > l.x : c > 0, p;\n  }, at.locatePointInRing = function (t, e) {\n    return st.locatePointInRing(t, e);\n  }, at.distancePointLinePerpendicular = function (t, e, n) {\n    var i = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),\n        r = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / i;\n    return Math.abs(r) * Math.sqrt(i);\n  }, at.computeOrientation = function (t, e, n) {\n    return at.orientationIndex(t, e, n);\n  }, at.distancePointLine = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      if (0 === e.length) throw new m(\"Line array must contain at least one vertex\");\n\n      for (var n = t.distance(e[0]), i = 0; i < e.length - 1; i++) {\n        var r = at.distancePointLine(t, e[i], e[i + 1]);\n        r < n && (n = r);\n      }\n\n      return n;\n    }\n\n    if (3 === arguments.length) {\n      var o = arguments[0],\n          s = arguments[1],\n          a = arguments[2];\n      if (s.x === a.x && s.y === a.y) return o.distance(s);\n      var u = (a.x - s.x) * (a.x - s.x) + (a.y - s.y) * (a.y - s.y),\n          l = ((o.x - s.x) * (a.x - s.x) + (o.y - s.y) * (a.y - s.y)) / u;\n      if (l <= 0) return o.distance(s);\n      if (l >= 1) return o.distance(a);\n      var c = ((s.y - o.y) * (a.x - s.x) - (s.x - o.x) * (a.y - s.y)) / u;\n      return Math.abs(c) * Math.sqrt(u);\n    }\n  }, at.isOnLine = function (t, e) {\n    for (var n = new rt(), i = 1; i < e.length; i++) {\n      var r = e[i - 1],\n          o = e[i];\n      if (n.computeIntersection(t, r, o), n.hasIntersection()) return !0;\n    }\n\n    return !1;\n  }, ut.CLOCKWISE.get = function () {\n    return -1;\n  }, ut.RIGHT.get = function () {\n    return at.CLOCKWISE;\n  }, ut.COUNTERCLOCKWISE.get = function () {\n    return 1;\n  }, ut.LEFT.get = function () {\n    return at.COUNTERCLOCKWISE;\n  }, ut.COLLINEAR.get = function () {\n    return 0;\n  }, ut.STRAIGHT.get = function () {\n    return at.COLLINEAR;\n  }, Object.defineProperties(at, ut);\n\n  var lt = function () {};\n\n  lt.prototype.filter = function (t) {}, lt.prototype.interfaces_ = function () {\n    return [];\n  }, lt.prototype.getClass = function () {\n    return lt;\n  };\n\n  var ct = function () {\n    var t = arguments[0];\n    this._envelope = null, this._factory = null, this._SRID = null, this._userData = null, this._factory = t, this._SRID = t.getSRID();\n  },\n      pt = {\n    serialVersionUID: {\n      configurable: !0\n    },\n    SORTINDEX_POINT: {\n      configurable: !0\n    },\n    SORTINDEX_MULTIPOINT: {\n      configurable: !0\n    },\n    SORTINDEX_LINESTRING: {\n      configurable: !0\n    },\n    SORTINDEX_LINEARRING: {\n      configurable: !0\n    },\n    SORTINDEX_MULTILINESTRING: {\n      configurable: !0\n    },\n    SORTINDEX_POLYGON: {\n      configurable: !0\n    },\n    SORTINDEX_MULTIPOLYGON: {\n      configurable: !0\n    },\n    SORTINDEX_GEOMETRYCOLLECTION: {\n      configurable: !0\n    },\n    geometryChangedFilter: {\n      configurable: !0\n    }\n  };\n\n  ct.prototype.isGeometryCollection = function () {\n    return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION;\n  }, ct.prototype.getFactory = function () {\n    return this._factory;\n  }, ct.prototype.getGeometryN = function (t) {\n    return this;\n  }, ct.prototype.getArea = function () {\n    return 0;\n  }, ct.prototype.isRectangle = function () {\n    return !1;\n  }, ct.prototype.equals = function () {\n    if (arguments[0] instanceof ct) {\n      var t = arguments[0];\n      return null !== t && this.equalsTopo(t);\n    }\n\n    if (arguments[0] instanceof Object) {\n      var e = arguments[0];\n      if (!(e instanceof ct)) return !1;\n      var n = e;\n      return this.equalsExact(n);\n    }\n  }, ct.prototype.equalsExact = function (t) {\n    return this === t || this.equalsExact(t, 0);\n  }, ct.prototype.geometryChanged = function () {\n    this.apply(ct.geometryChangedFilter);\n  }, ct.prototype.geometryChangedAction = function () {\n    this._envelope = null;\n  }, ct.prototype.equalsNorm = function (t) {\n    return null !== t && this.norm().equalsExact(t.norm());\n  }, ct.prototype.getLength = function () {\n    return 0;\n  }, ct.prototype.getNumGeometries = function () {\n    return 1;\n  }, ct.prototype.compareTo = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n          e = t;\n      return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(t);\n    }\n\n    if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1];\n      return this.getSortIndex() !== n.getSortIndex() ? this.getSortIndex() - n.getSortIndex() : this.isEmpty() && n.isEmpty() ? 0 : this.isEmpty() ? -1 : n.isEmpty() ? 1 : this.compareToSameClass(n, i);\n    }\n  }, ct.prototype.getUserData = function () {\n    return this._userData;\n  }, ct.prototype.getSRID = function () {\n    return this._SRID;\n  }, ct.prototype.getEnvelope = function () {\n    return this.getFactory().toGeometry(this.getEnvelopeInternal());\n  }, ct.prototype.checkNotGeometryCollection = function (t) {\n    if (t.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION) throw new m(\"This method does not support GeometryCollection arguments\");\n  }, ct.prototype.equal = function (t, e, n) {\n    return 0 === n ? t.equals(e) : t.distance(e) <= n;\n  }, ct.prototype.norm = function () {\n    var t = this.copy();\n    return t.normalize(), t;\n  }, ct.prototype.getPrecisionModel = function () {\n    return this._factory.getPrecisionModel();\n  }, ct.prototype.getEnvelopeInternal = function () {\n    return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new j(this._envelope);\n  }, ct.prototype.setSRID = function (t) {\n    this._SRID = t;\n  }, ct.prototype.setUserData = function (t) {\n    this._userData = t;\n  }, ct.prototype.compare = function (t, e) {\n    for (var n = t.iterator(), i = e.iterator(); n.hasNext() && i.hasNext();) {\n      var r = n.next(),\n          o = i.next(),\n          s = r.compareTo(o);\n      if (0 !== s) return s;\n    }\n\n    return n.hasNext() ? 1 : i.hasNext() ? -1 : 0;\n  }, ct.prototype.hashCode = function () {\n    return this.getEnvelopeInternal().hashCode();\n  }, ct.prototype.isGeometryCollectionOrDerived = function () {\n    return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === ct.SORTINDEX_MULTIPOINT || this.getSortIndex() === ct.SORTINDEX_MULTILINESTRING || this.getSortIndex() === ct.SORTINDEX_MULTIPOLYGON;\n  }, ct.prototype.interfaces_ = function () {\n    return [x, E, e];\n  }, ct.prototype.getClass = function () {\n    return ct;\n  }, ct.hasNonEmptyElements = function (t) {\n    for (var e = 0; e < t.length; e++) if (!t[e].isEmpty()) return !0;\n\n    return !1;\n  }, ct.hasNullElements = function (t) {\n    for (var e = 0; e < t.length; e++) if (null === t[e]) return !0;\n\n    return !1;\n  }, pt.serialVersionUID.get = function () {\n    return 0x799ea46522854c00;\n  }, pt.SORTINDEX_POINT.get = function () {\n    return 0;\n  }, pt.SORTINDEX_MULTIPOINT.get = function () {\n    return 1;\n  }, pt.SORTINDEX_LINESTRING.get = function () {\n    return 2;\n  }, pt.SORTINDEX_LINEARRING.get = function () {\n    return 3;\n  }, pt.SORTINDEX_MULTILINESTRING.get = function () {\n    return 4;\n  }, pt.SORTINDEX_POLYGON.get = function () {\n    return 5;\n  }, pt.SORTINDEX_MULTIPOLYGON.get = function () {\n    return 6;\n  }, pt.SORTINDEX_GEOMETRYCOLLECTION.get = function () {\n    return 7;\n  }, pt.geometryChangedFilter.get = function () {\n    return ht;\n  }, Object.defineProperties(ct, pt);\n\n  var ht = function () {};\n\n  ht.interfaces_ = function () {\n    return [lt];\n  }, ht.filter = function (t) {\n    t.geometryChangedAction();\n  };\n\n  var ft = function () {};\n\n  ft.prototype.filter = function (t) {}, ft.prototype.interfaces_ = function () {\n    return [];\n  }, ft.prototype.getClass = function () {\n    return ft;\n  };\n\n  var gt = function () {},\n      dt = {\n    Mod2BoundaryNodeRule: {\n      configurable: !0\n    },\n    EndPointBoundaryNodeRule: {\n      configurable: !0\n    },\n    MultiValentEndPointBoundaryNodeRule: {\n      configurable: !0\n    },\n    MonoValentEndPointBoundaryNodeRule: {\n      configurable: !0\n    },\n    MOD2_BOUNDARY_RULE: {\n      configurable: !0\n    },\n    ENDPOINT_BOUNDARY_RULE: {\n      configurable: !0\n    },\n    MULTIVALENT_ENDPOINT_BOUNDARY_RULE: {\n      configurable: !0\n    },\n    MONOVALENT_ENDPOINT_BOUNDARY_RULE: {\n      configurable: !0\n    },\n    OGC_SFS_BOUNDARY_RULE: {\n      configurable: !0\n    }\n  };\n\n  gt.prototype.isInBoundary = function (t) {}, gt.prototype.interfaces_ = function () {\n    return [];\n  }, gt.prototype.getClass = function () {\n    return gt;\n  }, dt.Mod2BoundaryNodeRule.get = function () {\n    return yt;\n  }, dt.EndPointBoundaryNodeRule.get = function () {\n    return _t;\n  }, dt.MultiValentEndPointBoundaryNodeRule.get = function () {\n    return mt;\n  }, dt.MonoValentEndPointBoundaryNodeRule.get = function () {\n    return vt;\n  }, dt.MOD2_BOUNDARY_RULE.get = function () {\n    return new yt();\n  }, dt.ENDPOINT_BOUNDARY_RULE.get = function () {\n    return new _t();\n  }, dt.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function () {\n    return new mt();\n  }, dt.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function () {\n    return new vt();\n  }, dt.OGC_SFS_BOUNDARY_RULE.get = function () {\n    return gt.MOD2_BOUNDARY_RULE;\n  }, Object.defineProperties(gt, dt);\n\n  var yt = function () {};\n\n  yt.prototype.isInBoundary = function (t) {\n    return t % 2 == 1;\n  }, yt.prototype.interfaces_ = function () {\n    return [gt];\n  }, yt.prototype.getClass = function () {\n    return yt;\n  };\n\n  var _t = function () {};\n\n  _t.prototype.isInBoundary = function (t) {\n    return t > 0;\n  }, _t.prototype.interfaces_ = function () {\n    return [gt];\n  }, _t.prototype.getClass = function () {\n    return _t;\n  };\n\n  var mt = function () {};\n\n  mt.prototype.isInBoundary = function (t) {\n    return t > 1;\n  }, mt.prototype.interfaces_ = function () {\n    return [gt];\n  }, mt.prototype.getClass = function () {\n    return mt;\n  };\n\n  var vt = function () {};\n\n  vt.prototype.isInBoundary = function (t) {\n    return 1 === t;\n  }, vt.prototype.interfaces_ = function () {\n    return [gt];\n  }, vt.prototype.getClass = function () {\n    return vt;\n  };\n\n  var It = function () {};\n\n  It.prototype.add = function () {}, It.prototype.addAll = function () {}, It.prototype.isEmpty = function () {}, It.prototype.iterator = function () {}, It.prototype.size = function () {}, It.prototype.toArray = function () {}, It.prototype.remove = function () {}, (n.prototype = new Error()).name = \"IndexOutOfBoundsException\";\n\n  var Et = function () {};\n\n  Et.prototype.hasNext = function () {}, Et.prototype.next = function () {}, Et.prototype.remove = function () {};\n\n  var xt = function (t) {\n    function e() {\n      t.apply(this, arguments);\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.get = function () {}, e.prototype.set = function () {}, e.prototype.isEmpty = function () {}, e;\n  }(It);\n\n  (i.prototype = new Error()).name = \"NoSuchElementException\";\n\n  var Nt = function (t) {\n    function e() {\n      t.call(this), this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.ensureCapacity = function () {}, e.prototype.interfaces_ = function () {\n      return [t, It];\n    }, e.prototype.add = function (t) {\n      return 1 === arguments.length ? this.array_.push(t) : this.array_.splice(arguments[0], arguments[1]), !0;\n    }, e.prototype.clear = function () {\n      this.array_ = [];\n    }, e.prototype.addAll = function (t) {\n      for (var e = t.iterator(); e.hasNext();) this.add(e.next());\n\n      return !0;\n    }, e.prototype.set = function (t, e) {\n      var n = this.array_[t];\n      return this.array_[t] = e, n;\n    }, e.prototype.iterator = function () {\n      return new Ct(this);\n    }, e.prototype.get = function (t) {\n      if (t < 0 || t >= this.size()) throw new n();\n      return this.array_[t];\n    }, e.prototype.isEmpty = function () {\n      return 0 === this.array_.length;\n    }, e.prototype.size = function () {\n      return this.array_.length;\n    }, e.prototype.toArray = function () {\n      for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);\n\n      return t;\n    }, e.prototype.remove = function (t) {\n      for (var e = !1, n = 0, i = this.array_.length; n < i; n++) if (this.array_[n] === t) {\n        this.array_.splice(n, 1), e = !0;\n        break;\n      }\n\n      return e;\n    }, e;\n  }(xt),\n      Ct = function (t) {\n    function e(e) {\n      t.call(this), this.arrayList_ = e, this.position_ = 0;\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.next = function () {\n      if (this.position_ === this.arrayList_.size()) throw new i();\n      return this.arrayList_.get(this.position_++);\n    }, e.prototype.hasNext = function () {\n      return this.position_ < this.arrayList_.size();\n    }, e.prototype.set = function (t) {\n      return this.arrayList_.set(this.position_ - 1, t);\n    }, e.prototype.remove = function () {\n      this.arrayList_.remove(this.arrayList_.get(this.position_));\n    }, e;\n  }(Et),\n      St = function (t) {\n    function e() {\n      if (t.call(this), 0 === arguments.length) ;else if (1 === arguments.length) {\n        var e = arguments[0];\n        this.ensureCapacity(e.length), this.add(e, !0);\n      } else if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1];\n        this.ensureCapacity(n.length), this.add(n, i);\n      }\n    }\n\n    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n    var n = {\n      coordArrayType: {\n        configurable: !0\n      }\n    };\n    return n.coordArrayType.get = function () {\n      return new Array(0).fill(null);\n    }, e.prototype.getCoordinate = function (t) {\n      return this.get(t);\n    }, e.prototype.addAll = function () {\n      if (2 === arguments.length) {\n        for (var e = arguments[0], n = arguments[1], i = !1, r = e.iterator(); r.hasNext();) this.add(r.next(), n), i = !0;\n\n        return i;\n      }\n\n      return t.prototype.addAll.apply(this, arguments);\n    }, e.prototype.clone = function () {\n      for (var e = t.prototype.clone.call(this), n = 0; n < this.size(); n++) e.add(n, this.get(n).copy());\n\n      return e;\n    }, e.prototype.toCoordinateArray = function () {\n      return this.toArray(e.coordArrayType);\n    }, e.prototype.add = function () {\n      if (1 === arguments.length) {\n        var e = arguments[0];\n        t.prototype.add.call(this, e);\n      } else if (2 === arguments.length) {\n        if (arguments[0] instanceof Array && \"boolean\" == typeof arguments[1]) {\n          var n = arguments[0],\n              i = arguments[1];\n          return this.add(n, i, !0), !0;\n        }\n\n        if (arguments[0] instanceof C && \"boolean\" == typeof arguments[1]) {\n          var r = arguments[0];\n\n          if (!arguments[1] && this.size() >= 1) {\n            if (this.get(this.size() - 1).equals2D(r)) return null;\n          }\n\n          t.prototype.add.call(this, r);\n        } else if (arguments[0] instanceof Object && \"boolean\" == typeof arguments[1]) {\n          var o = arguments[0],\n              s = arguments[1];\n          return this.add(o, s), !0;\n        }\n      } else if (3 === arguments.length) {\n        if (\"boolean\" == typeof arguments[2] && arguments[0] instanceof Array && \"boolean\" == typeof arguments[1]) {\n          var a = arguments[0],\n              u = arguments[1];\n          if (arguments[2]) for (var l = 0; l < a.length; l++) this.add(a[l], u);else for (var c = a.length - 1; c >= 0; c--) this.add(a[c], u);\n          return !0;\n        }\n\n        if (\"boolean\" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof C) {\n          var p = arguments[0],\n              h = arguments[1];\n\n          if (!arguments[2]) {\n            var f = this.size();\n\n            if (f > 0) {\n              if (p > 0) {\n                if (this.get(p - 1).equals2D(h)) return null;\n              }\n\n              if (p < f) {\n                if (this.get(p).equals2D(h)) return null;\n              }\n            }\n          }\n\n          t.prototype.add.call(this, p, h);\n        }\n      } else if (4 === arguments.length) {\n        var g = arguments[0],\n            d = arguments[1],\n            y = arguments[2],\n            _ = arguments[3],\n            m = 1;\n        y > _ && (m = -1);\n\n        for (var v = y; v !== _; v += m) this.add(g[v], d);\n\n        return !0;\n      }\n    }, e.prototype.closeRing = function () {\n      this.size() > 0 && this.add(new C(this.get(0)), !1);\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, Object.defineProperties(e, n), e;\n  }(Nt),\n      Lt = function () {},\n      bt = {\n    ForwardComparator: {\n      configurable: !0\n    },\n    BidirectionalComparator: {\n      configurable: !0\n    },\n    coordArrayType: {\n      configurable: !0\n    }\n  };\n\n  bt.ForwardComparator.get = function () {\n    return wt;\n  }, bt.BidirectionalComparator.get = function () {\n    return Ot;\n  }, bt.coordArrayType.get = function () {\n    return new Array(0).fill(null);\n  }, Lt.prototype.interfaces_ = function () {\n    return [];\n  }, Lt.prototype.getClass = function () {\n    return Lt;\n  }, Lt.isRing = function (t) {\n    return !(t.length < 4) && !!t[0].equals2D(t[t.length - 1]);\n  }, Lt.ptNotInList = function (t, e) {\n    for (var n = 0; n < t.length; n++) {\n      var i = t[n];\n      if (Lt.indexOf(i, e) < 0) return i;\n    }\n\n    return null;\n  }, Lt.scroll = function (t, e) {\n    var n = Lt.indexOf(e, t);\n    if (n < 0) return null;\n    var i = new Array(t.length).fill(null);\n    Y.arraycopy(t, n, i, 0, t.length - n), Y.arraycopy(t, 0, i, t.length - n, n), Y.arraycopy(i, 0, t, 0, t.length);\n  }, Lt.equals = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      if (t === e) return !0;\n      if (null === t || null === e) return !1;\n      if (t.length !== e.length) return !1;\n\n      for (var n = 0; n < t.length; n++) if (!t[n].equals(e[n])) return !1;\n\n      return !0;\n    }\n\n    if (3 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1],\n          o = arguments[2];\n      if (i === r) return !0;\n      if (null === i || null === r) return !1;\n      if (i.length !== r.length) return !1;\n\n      for (var s = 0; s < i.length; s++) if (0 !== o.compare(i[s], r[s])) return !1;\n\n      return !0;\n    }\n  }, Lt.intersection = function (t, e) {\n    for (var n = new St(), i = 0; i < t.length; i++) e.intersects(t[i]) && n.add(t[i], !0);\n\n    return n.toCoordinateArray();\n  }, Lt.hasRepeatedPoints = function (t) {\n    for (var e = 1; e < t.length; e++) if (t[e - 1].equals(t[e])) return !0;\n\n    return !1;\n  }, Lt.removeRepeatedPoints = function (t) {\n    if (!Lt.hasRepeatedPoints(t)) return t;\n    return new St(t, !1).toCoordinateArray();\n  }, Lt.reverse = function (t) {\n    for (var e = t.length - 1, n = Math.trunc(e / 2), i = 0; i <= n; i++) {\n      var r = t[i];\n      t[i] = t[e - i], t[e - i] = r;\n    }\n  }, Lt.removeNull = function (t) {\n    for (var e = 0, n = 0; n < t.length; n++) null !== t[n] && e++;\n\n    var i = new Array(e).fill(null);\n    if (0 === e) return i;\n\n    for (var r = 0, o = 0; o < t.length; o++) null !== t[o] && (i[r++] = t[o]);\n\n    return i;\n  }, Lt.copyDeep = function () {\n    if (1 === arguments.length) {\n      for (var t = arguments[0], e = new Array(t.length).fill(null), n = 0; n < t.length; n++) e[n] = new C(t[n]);\n\n      return e;\n    }\n\n    if (5 === arguments.length) for (var i = arguments[0], r = arguments[1], o = arguments[2], s = arguments[3], a = arguments[4], u = 0; u < a; u++) o[s + u] = new C(i[r + u]);\n  }, Lt.isEqualReversed = function (t, e) {\n    for (var n = 0; n < t.length; n++) {\n      var i = t[n],\n          r = e[t.length - n - 1];\n      if (0 !== i.compareTo(r)) return !1;\n    }\n\n    return !0;\n  }, Lt.envelope = function (t) {\n    for (var e = new j(), n = 0; n < t.length; n++) e.expandToInclude(t[n]);\n\n    return e;\n  }, Lt.toCoordinateArray = function (t) {\n    return t.toArray(Lt.coordArrayType);\n  }, Lt.atLeastNCoordinatesOrNothing = function (t, e) {\n    return e.length >= t ? e : [];\n  }, Lt.indexOf = function (t, e) {\n    for (var n = 0; n < e.length; n++) if (t.equals(e[n])) return n;\n\n    return -1;\n  }, Lt.increasingDirection = function (t) {\n    for (var e = 0; e < Math.trunc(t.length / 2); e++) {\n      var n = t.length - 1 - e,\n          i = t[e].compareTo(t[n]);\n      if (0 !== i) return i;\n    }\n\n    return 1;\n  }, Lt.compare = function (t, e) {\n    for (var n = 0; n < t.length && n < e.length;) {\n      var i = t[n].compareTo(e[n]);\n      if (0 !== i) return i;\n      n++;\n    }\n\n    return n < e.length ? -1 : n < t.length ? 1 : 0;\n  }, Lt.minCoordinate = function (t) {\n    for (var e = null, n = 0; n < t.length; n++) (null === e || e.compareTo(t[n]) > 0) && (e = t[n]);\n\n    return e;\n  }, Lt.extract = function (t, e, n) {\n    e = R.clamp(e, 0, t.length);\n    var i = (n = R.clamp(n, -1, t.length)) - e + 1;\n    n < 0 && (i = 0), e >= t.length && (i = 0), n < e && (i = 0);\n    var r = new Array(i).fill(null);\n    if (0 === i) return r;\n\n    for (var o = 0, s = e; s <= n; s++) r[o++] = t[s];\n\n    return r;\n  }, Object.defineProperties(Lt, bt);\n\n  var wt = function () {};\n\n  wt.prototype.compare = function (t, e) {\n    return Lt.compare(t, e);\n  }, wt.prototype.interfaces_ = function () {\n    return [N];\n  }, wt.prototype.getClass = function () {\n    return wt;\n  };\n\n  var Ot = function () {};\n\n  Ot.prototype.compare = function (t, e) {\n    var n = t,\n        i = e;\n    if (n.length < i.length) return -1;\n    if (n.length > i.length) return 1;\n    if (0 === n.length) return 0;\n    var r = Lt.compare(n, i);\n    return Lt.isEqualReversed(n, i) ? 0 : r;\n  }, Ot.prototype.OLDcompare = function (t, e) {\n    var n = t,\n        i = e;\n    if (n.length < i.length) return -1;\n    if (n.length > i.length) return 1;\n    if (0 === n.length) return 0;\n\n    for (var r = Lt.increasingDirection(n), o = Lt.increasingDirection(i), s = r > 0 ? 0 : n.length - 1, a = o > 0 ? 0 : n.length - 1, u = 0; u < n.length; u++) {\n      var l = n[s].compareTo(i[a]);\n      if (0 !== l) return l;\n      s += r, a += o;\n    }\n\n    return 0;\n  }, Ot.prototype.interfaces_ = function () {\n    return [N];\n  }, Ot.prototype.getClass = function () {\n    return Ot;\n  };\n\n  var Tt = function () {};\n\n  Tt.prototype.get = function () {}, Tt.prototype.put = function () {}, Tt.prototype.size = function () {}, Tt.prototype.values = function () {}, Tt.prototype.entrySet = function () {};\n\n  var Rt = function (t) {\n    function e() {\n      t.apply(this, arguments);\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e;\n  }(Tt);\n\n  (r.prototype = new Error()).name = \"OperationNotSupported\", (o.prototype = new It()).contains = function () {};\n\n  var Pt = function (t) {\n    function e() {\n      t.call(this), this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.contains = function (t) {\n      for (var e = 0, n = this.array_.length; e < n; e++) {\n        if (this.array_[e] === t) return !0;\n      }\n\n      return !1;\n    }, e.prototype.add = function (t) {\n      return !this.contains(t) && (this.array_.push(t), !0);\n    }, e.prototype.addAll = function (t) {\n      for (var e = t.iterator(); e.hasNext();) this.add(e.next());\n\n      return !0;\n    }, e.prototype.remove = function (t) {\n      throw new Error();\n    }, e.prototype.size = function () {\n      return this.array_.length;\n    }, e.prototype.isEmpty = function () {\n      return 0 === this.array_.length;\n    }, e.prototype.toArray = function () {\n      for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);\n\n      return t;\n    }, e.prototype.iterator = function () {\n      return new Dt(this);\n    }, e;\n  }(o),\n      Dt = function (t) {\n    function e(e) {\n      t.call(this), this.hashSet_ = e, this.position_ = 0;\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.next = function () {\n      if (this.position_ === this.hashSet_.size()) throw new i();\n      return this.hashSet_.array_[this.position_++];\n    }, e.prototype.hasNext = function () {\n      return this.position_ < this.hashSet_.size();\n    }, e.prototype.remove = function () {\n      throw new r();\n    }, e;\n  }(Et),\n      Mt = 0;\n\n  (p.prototype = new Rt()).get = function (t) {\n    for (var e = this.root_; null !== e;) {\n      var n = t.compareTo(e.key);\n      if (n < 0) e = e.left;else {\n        if (!(n > 0)) return e.value;\n        e = e.right;\n      }\n    }\n\n    return null;\n  }, p.prototype.put = function (t, e) {\n    if (null === this.root_) return this.root_ = {\n      key: t,\n      value: e,\n      left: null,\n      right: null,\n      parent: null,\n      color: Mt,\n      getValue: function () {\n        return this.value;\n      },\n      getKey: function () {\n        return this.key;\n      }\n    }, this.size_ = 1, null;\n    var n,\n        i,\n        r = this.root_;\n\n    do {\n      if (n = r, (i = t.compareTo(r.key)) < 0) r = r.left;else {\n        if (!(i > 0)) {\n          var o = r.value;\n          return r.value = e, o;\n        }\n\n        r = r.right;\n      }\n    } while (null !== r);\n\n    var s = {\n      key: t,\n      left: null,\n      right: null,\n      value: e,\n      parent: n,\n      color: Mt,\n      getValue: function () {\n        return this.value;\n      },\n      getKey: function () {\n        return this.key;\n      }\n    };\n    return i < 0 ? n.left = s : n.right = s, this.fixAfterInsertion(s), this.size_++, null;\n  }, p.prototype.fixAfterInsertion = function (t) {\n    for (t.color = 1; null != t && t !== this.root_ && 1 === t.parent.color;) if (a(t) === l(a(a(t)))) {\n      var e = c(a(a(t)));\n      1 === s(e) ? (u(a(t), Mt), u(e, Mt), u(a(a(t)), 1), t = a(a(t))) : (t === c(a(t)) && (t = a(t), this.rotateLeft(t)), u(a(t), Mt), u(a(a(t)), 1), this.rotateRight(a(a(t))));\n    } else {\n      var n = l(a(a(t)));\n      1 === s(n) ? (u(a(t), Mt), u(n, Mt), u(a(a(t)), 1), t = a(a(t))) : (t === l(a(t)) && (t = a(t), this.rotateRight(t)), u(a(t), Mt), u(a(a(t)), 1), this.rotateLeft(a(a(t))));\n    }\n\n    this.root_.color = Mt;\n  }, p.prototype.values = function () {\n    var t = new Nt(),\n        e = this.getFirstEntry();\n    if (null !== e) for (t.add(e.value); null !== (e = p.successor(e));) t.add(e.value);\n    return t;\n  }, p.prototype.entrySet = function () {\n    var t = new Pt(),\n        e = this.getFirstEntry();\n    if (null !== e) for (t.add(e); null !== (e = p.successor(e));) t.add(e);\n    return t;\n  }, p.prototype.rotateLeft = function (t) {\n    if (null != t) {\n      var e = t.right;\n      t.right = e.left, null != e.left && (e.left.parent = t), e.parent = t.parent, null === t.parent ? this.root_ = e : t.parent.left === t ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e;\n    }\n  }, p.prototype.rotateRight = function (t) {\n    if (null != t) {\n      var e = t.left;\n      t.left = e.right, null != e.right && (e.right.parent = t), e.parent = t.parent, null === t.parent ? this.root_ = e : t.parent.right === t ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e;\n    }\n  }, p.prototype.getFirstEntry = function () {\n    var t = this.root_;\n    if (null != t) for (; null != t.left;) t = t.left;\n    return t;\n  }, p.successor = function (t) {\n    if (null === t) return null;\n\n    if (null !== t.right) {\n      for (var e = t.right; null !== e.left;) e = e.left;\n\n      return e;\n    }\n\n    for (var n = t.parent, i = t; null !== n && i === n.right;) i = n, n = n.parent;\n\n    return n;\n  }, p.prototype.size = function () {\n    return this.size_;\n  };\n\n  var At = function () {};\n\n  At.prototype.interfaces_ = function () {\n    return [];\n  }, At.prototype.getClass = function () {\n    return At;\n  }, h.prototype = new o(), (f.prototype = new h()).contains = function (t) {\n    for (var e = 0, n = this.array_.length; e < n; e++) {\n      if (0 === this.array_[e].compareTo(t)) return !0;\n    }\n\n    return !1;\n  }, f.prototype.add = function (t) {\n    if (this.contains(t)) return !1;\n\n    for (var e = 0, n = this.array_.length; e < n; e++) {\n      if (1 === this.array_[e].compareTo(t)) return this.array_.splice(e, 0, t), !0;\n    }\n\n    return this.array_.push(t), !0;\n  }, f.prototype.addAll = function (t) {\n    for (var e = t.iterator(); e.hasNext();) this.add(e.next());\n\n    return !0;\n  }, f.prototype.remove = function (t) {\n    throw new r();\n  }, f.prototype.size = function () {\n    return this.array_.length;\n  }, f.prototype.isEmpty = function () {\n    return 0 === this.array_.length;\n  }, f.prototype.toArray = function () {\n    for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);\n\n    return t;\n  }, f.prototype.iterator = function () {\n    return new Ft(this);\n  };\n\n  var Ft = function (t) {\n    this.treeSet_ = t, this.position_ = 0;\n  };\n\n  Ft.prototype.next = function () {\n    if (this.position_ === this.treeSet_.size()) throw new i();\n    return this.treeSet_.array_[this.position_++];\n  }, Ft.prototype.hasNext = function () {\n    return this.position_ < this.treeSet_.size();\n  }, Ft.prototype.remove = function () {\n    throw new r();\n  };\n\n  var Gt = function () {};\n\n  Gt.sort = function () {\n    var t,\n        e,\n        n,\n        i,\n        r = arguments[0];\n    if (1 === arguments.length) i = function (t, e) {\n      return t.compareTo(e);\n    }, r.sort(i);else if (2 === arguments.length) n = arguments[1], i = function (t, e) {\n      return n.compare(t, e);\n    }, r.sort(i);else if (3 === arguments.length) {\n      (e = r.slice(arguments[1], arguments[2])).sort();\n      var o = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length));\n\n      for (r.splice(0, r.length), t = 0; t < o.length; t++) r.push(o[t]);\n    } else if (4 === arguments.length) for (e = r.slice(arguments[1], arguments[2]), n = arguments[3], i = function (t, e) {\n      return n.compare(t, e);\n    }, e.sort(i), o = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length)), r.splice(0, r.length), t = 0; t < o.length; t++) r.push(o[t]);\n  }, Gt.asList = function (t) {\n    for (var e = new Nt(), n = 0, i = t.length; n < i; n++) e.add(t[n]);\n\n    return e;\n  };\n\n  var qt = function () {},\n      Bt = {\n    P: {\n      configurable: !0\n    },\n    L: {\n      configurable: !0\n    },\n    A: {\n      configurable: !0\n    },\n    FALSE: {\n      configurable: !0\n    },\n    TRUE: {\n      configurable: !0\n    },\n    DONTCARE: {\n      configurable: !0\n    },\n    SYM_FALSE: {\n      configurable: !0\n    },\n    SYM_TRUE: {\n      configurable: !0\n    },\n    SYM_DONTCARE: {\n      configurable: !0\n    },\n    SYM_P: {\n      configurable: !0\n    },\n    SYM_L: {\n      configurable: !0\n    },\n    SYM_A: {\n      configurable: !0\n    }\n  };\n\n  Bt.P.get = function () {\n    return 0;\n  }, Bt.L.get = function () {\n    return 1;\n  }, Bt.A.get = function () {\n    return 2;\n  }, Bt.FALSE.get = function () {\n    return -1;\n  }, Bt.TRUE.get = function () {\n    return -2;\n  }, Bt.DONTCARE.get = function () {\n    return -3;\n  }, Bt.SYM_FALSE.get = function () {\n    return \"F\";\n  }, Bt.SYM_TRUE.get = function () {\n    return \"T\";\n  }, Bt.SYM_DONTCARE.get = function () {\n    return \"*\";\n  }, Bt.SYM_P.get = function () {\n    return \"0\";\n  }, Bt.SYM_L.get = function () {\n    return \"1\";\n  }, Bt.SYM_A.get = function () {\n    return \"2\";\n  }, qt.prototype.interfaces_ = function () {\n    return [];\n  }, qt.prototype.getClass = function () {\n    return qt;\n  }, qt.toDimensionSymbol = function (t) {\n    switch (t) {\n      case qt.FALSE:\n        return qt.SYM_FALSE;\n\n      case qt.TRUE:\n        return qt.SYM_TRUE;\n\n      case qt.DONTCARE:\n        return qt.SYM_DONTCARE;\n\n      case qt.P:\n        return qt.SYM_P;\n\n      case qt.L:\n        return qt.SYM_L;\n\n      case qt.A:\n        return qt.SYM_A;\n    }\n\n    throw new m(\"Unknown dimension value: \" + t);\n  }, qt.toDimensionValue = function (t) {\n    switch (A.toUpperCase(t)) {\n      case qt.SYM_FALSE:\n        return qt.FALSE;\n\n      case qt.SYM_TRUE:\n        return qt.TRUE;\n\n      case qt.SYM_DONTCARE:\n        return qt.DONTCARE;\n\n      case qt.SYM_P:\n        return qt.P;\n\n      case qt.SYM_L:\n        return qt.L;\n\n      case qt.SYM_A:\n        return qt.A;\n    }\n\n    throw new m(\"Unknown dimension symbol: \" + t);\n  }, Object.defineProperties(qt, Bt);\n\n  var Vt = function () {};\n\n  Vt.prototype.filter = function (t) {}, Vt.prototype.interfaces_ = function () {\n    return [];\n  }, Vt.prototype.getClass = function () {\n    return Vt;\n  };\n\n  var Ut = function () {};\n\n  Ut.prototype.filter = function (t, e) {}, Ut.prototype.isDone = function () {}, Ut.prototype.isGeometryChanged = function () {}, Ut.prototype.interfaces_ = function () {\n    return [];\n  }, Ut.prototype.getClass = function () {\n    return Ut;\n  };\n\n  var zt = function (t) {\n    function e(e, n) {\n      if (t.call(this, n), this._geometries = e || [], t.hasNullElements(this._geometries)) throw new m(\"geometries must not contain null elements\");\n    }\n\n    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n    var n = {\n      serialVersionUID: {\n        configurable: !0\n      }\n    };\n    return e.prototype.computeEnvelopeInternal = function () {\n      for (var t = new j(), e = 0; e < this._geometries.length; e++) t.expandToInclude(this._geometries[e].getEnvelopeInternal());\n\n      return t;\n    }, e.prototype.getGeometryN = function (t) {\n      return this._geometries[t];\n    }, e.prototype.getSortIndex = function () {\n      return t.SORTINDEX_GEOMETRYCOLLECTION;\n    }, e.prototype.getCoordinates = function () {\n      for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = 0; n < this._geometries.length; n++) for (var i = this._geometries[n].getCoordinates(), r = 0; r < i.length; r++) t[++e] = i[r];\n\n      return t;\n    }, e.prototype.getArea = function () {\n      for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getArea();\n\n      return t;\n    }, e.prototype.equalsExact = function () {\n      if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        if (!this.isEquivalentClass(e)) return !1;\n        var i = e;\n        if (this._geometries.length !== i._geometries.length) return !1;\n\n        for (var r = 0; r < this._geometries.length; r++) if (!this._geometries[r].equalsExact(i._geometries[r], n)) return !1;\n\n        return !0;\n      }\n\n      return t.prototype.equalsExact.apply(this, arguments);\n    }, e.prototype.normalize = function () {\n      for (var t = 0; t < this._geometries.length; t++) this._geometries[t].normalize();\n\n      Gt.sort(this._geometries);\n    }, e.prototype.getCoordinate = function () {\n      return this.isEmpty() ? null : this._geometries[0].getCoordinate();\n    }, e.prototype.getBoundaryDimension = function () {\n      for (var t = qt.FALSE, e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getBoundaryDimension());\n\n      return t;\n    }, e.prototype.getDimension = function () {\n      for (var t = qt.FALSE, e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getDimension());\n\n      return t;\n    }, e.prototype.getLength = function () {\n      for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getLength();\n\n      return t;\n    }, e.prototype.getNumPoints = function () {\n      for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getNumPoints();\n\n      return t;\n    }, e.prototype.getNumGeometries = function () {\n      return this._geometries.length;\n    }, e.prototype.reverse = function () {\n      for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++) e[n] = this._geometries[n].reverse();\n\n      return this.getFactory().createGeometryCollection(e);\n    }, e.prototype.compareToSameClass = function () {\n      if (1 === arguments.length) {\n        var t = arguments[0],\n            e = new f(Gt.asList(this._geometries)),\n            n = new f(Gt.asList(t._geometries));\n        return this.compare(e, n);\n      }\n\n      if (2 === arguments.length) {\n        for (var i = arguments[0], r = arguments[1], o = i, s = this.getNumGeometries(), a = o.getNumGeometries(), u = 0; u < s && u < a;) {\n          var l = this.getGeometryN(u),\n              c = o.getGeometryN(u),\n              p = l.compareToSameClass(c, r);\n          if (0 !== p) return p;\n          u++;\n        }\n\n        return u < s ? 1 : u < a ? -1 : 0;\n      }\n    }, e.prototype.apply = function () {\n      if (T(arguments[0], ft)) for (var t = arguments[0], e = 0; e < this._geometries.length; e++) this._geometries[e].apply(t);else if (T(arguments[0], Ut)) {\n        var n = arguments[0];\n        if (0 === this._geometries.length) return null;\n\n        for (var i = 0; i < this._geometries.length && (this._geometries[i].apply(n), !n.isDone()); i++);\n\n        n.isGeometryChanged() && this.geometryChanged();\n      } else if (T(arguments[0], Vt)) {\n        var r = arguments[0];\n        r.filter(this);\n\n        for (var o = 0; o < this._geometries.length; o++) this._geometries[o].apply(r);\n      } else if (T(arguments[0], lt)) {\n        var s = arguments[0];\n        s.filter(this);\n\n        for (var a = 0; a < this._geometries.length; a++) this._geometries[a].apply(s);\n      }\n    }, e.prototype.getBoundary = function () {\n      return this.checkNotGeometryCollection(this), et.shouldNeverReachHere(), null;\n    }, e.prototype.clone = function () {\n      var e = t.prototype.clone.call(this);\n      e._geometries = new Array(this._geometries.length).fill(null);\n\n      for (var n = 0; n < this._geometries.length; n++) e._geometries[n] = this._geometries[n].clone();\n\n      return e;\n    }, e.prototype.getGeometryType = function () {\n      return \"GeometryCollection\";\n    }, e.prototype.copy = function () {\n      for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++) t[n] = this._geometries[n].copy();\n\n      return new e(t, this._factory);\n    }, e.prototype.isEmpty = function () {\n      for (var t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isEmpty()) return !1;\n\n      return !0;\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, n.serialVersionUID.get = function () {\n      return -0x4f07bcb1f857d800;\n    }, Object.defineProperties(e, n), e;\n  }(ct),\n      Xt = function (t) {\n    function e() {\n      t.apply(this, arguments);\n    }\n\n    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n    var n = {\n      serialVersionUID: {\n        configurable: !0\n      }\n    };\n    return e.prototype.getSortIndex = function () {\n      return ct.SORTINDEX_MULTILINESTRING;\n    }, e.prototype.equalsExact = function () {\n      if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n);\n      }\n\n      return t.prototype.equalsExact.apply(this, arguments);\n    }, e.prototype.getBoundaryDimension = function () {\n      return this.isClosed() ? qt.FALSE : 0;\n    }, e.prototype.isClosed = function () {\n      if (this.isEmpty()) return !1;\n\n      for (var t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isClosed()) return !1;\n\n      return !0;\n    }, e.prototype.getDimension = function () {\n      return 1;\n    }, e.prototype.reverse = function () {\n      for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++) e[t - 1 - n] = this._geometries[n].reverse();\n\n      return this.getFactory().createMultiLineString(e);\n    }, e.prototype.getBoundary = function () {\n      return new Yt(this).getBoundary();\n    }, e.prototype.getGeometryType = function () {\n      return \"MultiLineString\";\n    }, e.prototype.copy = function () {\n      for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++) t[n] = this._geometries[n].copy();\n\n      return new e(t, this._factory);\n    }, e.prototype.interfaces_ = function () {\n      return [At];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, n.serialVersionUID.get = function () {\n      return 0x7155d2ab4afa8000;\n    }, Object.defineProperties(e, n), e;\n  }(zt),\n      Yt = function () {\n    if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, 1 === arguments.length) {\n      var t = arguments[0],\n          e = gt.MOD2_BOUNDARY_RULE;\n      this._geom = t, this._geomFact = t.getFactory(), this._bnRule = e;\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1];\n      this._geom = n, this._geomFact = n.getFactory(), this._bnRule = i;\n    }\n  };\n\n  Yt.prototype.boundaryMultiLineString = function (t) {\n    if (this._geom.isEmpty()) return this.getEmptyMultiPoint();\n    var e = this.computeBoundaryCoordinates(t);\n    return 1 === e.length ? this._geomFact.createPoint(e[0]) : this._geomFact.createMultiPointFromCoords(e);\n  }, Yt.prototype.getBoundary = function () {\n    return this._geom instanceof Kt ? this.boundaryLineString(this._geom) : this._geom instanceof Xt ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary();\n  }, Yt.prototype.boundaryLineString = function (t) {\n    if (this._geom.isEmpty()) return this.getEmptyMultiPoint();\n\n    if (t.isClosed()) {\n      return this._bnRule.isInBoundary(2) ? t.getStartPoint() : this._geomFact.createMultiPoint();\n    }\n\n    return this._geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()]);\n  }, Yt.prototype.getEmptyMultiPoint = function () {\n    return this._geomFact.createMultiPoint();\n  }, Yt.prototype.computeBoundaryCoordinates = function (t) {\n    var e = new Nt();\n    this._endpointMap = new p();\n\n    for (var n = 0; n < t.getNumGeometries(); n++) {\n      var i = t.getGeometryN(n);\n      0 !== i.getNumPoints() && (this.addEndpoint(i.getCoordinateN(0)), this.addEndpoint(i.getCoordinateN(i.getNumPoints() - 1)));\n    }\n\n    for (var r = this._endpointMap.entrySet().iterator(); r.hasNext();) {\n      var o = r.next(),\n          s = o.getValue().count;\n      this._bnRule.isInBoundary(s) && e.add(o.getKey());\n    }\n\n    return Lt.toCoordinateArray(e);\n  }, Yt.prototype.addEndpoint = function (t) {\n    var e = this._endpointMap.get(t);\n\n    null === e && (e = new kt(), this._endpointMap.put(t, e)), e.count++;\n  }, Yt.prototype.interfaces_ = function () {\n    return [];\n  }, Yt.prototype.getClass = function () {\n    return Yt;\n  }, Yt.getBoundary = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return new Yt(t).getBoundary();\n    }\n\n    if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      return new Yt(e, n).getBoundary();\n    }\n  };\n\n  var kt = function () {\n    this.count = null;\n  };\n\n  kt.prototype.interfaces_ = function () {\n    return [];\n  }, kt.prototype.getClass = function () {\n    return kt;\n  };\n\n  var jt = function () {},\n      Ht = {\n    NEWLINE: {\n      configurable: !0\n    },\n    SIMPLE_ORDINATE_FORMAT: {\n      configurable: !0\n    }\n  };\n\n  jt.prototype.interfaces_ = function () {\n    return [];\n  }, jt.prototype.getClass = function () {\n    return jt;\n  }, jt.chars = function (t, e) {\n    for (var n = new Array(e).fill(null), i = 0; i < e; i++) n[i] = t;\n\n    return String(n);\n  }, jt.getStackTrace = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n          e = new function () {}(),\n          n = new function () {}(e);\n      return t.printStackTrace(n), e.toString();\n    }\n\n    if (2 === arguments.length) {\n      for (var i = arguments[0], r = arguments[1], o = \"\", s = new function () {}(new function () {}(jt.getStackTrace(i))), a = 0; a < r; a++) try {\n        o += s.readLine() + jt.NEWLINE;\n      } catch (t) {\n        if (!(t instanceof g)) throw t;\n        et.shouldNeverReachHere();\n      }\n\n      return o;\n    }\n  }, jt.split = function (t, e) {\n    for (var n = e.length, i = new Nt(), r = \"\" + t, o = r.indexOf(e); o >= 0;) {\n      var s = r.substring(0, o);\n      i.add(s), o = (r = r.substring(o + n)).indexOf(e);\n    }\n\n    r.length > 0 && i.add(r);\n\n    for (var a = new Array(i.size()).fill(null), u = 0; u < a.length; u++) a[u] = i.get(u);\n\n    return a;\n  }, jt.toString = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return jt.SIMPLE_ORDINATE_FORMAT.format(t);\n    }\n  }, jt.spaces = function (t) {\n    return jt.chars(\" \", t);\n  }, Ht.NEWLINE.get = function () {\n    return Y.getProperty(\"line.separator\");\n  }, Ht.SIMPLE_ORDINATE_FORMAT.get = function () {\n    return new function () {}(\"0.#\");\n  }, Object.defineProperties(jt, Ht);\n\n  var Wt = function () {};\n\n  Wt.prototype.interfaces_ = function () {\n    return [];\n  }, Wt.prototype.getClass = function () {\n    return Wt;\n  }, Wt.copyCoord = function (t, e, n, i) {\n    for (var r = Math.min(t.getDimension(), n.getDimension()), o = 0; o < r; o++) n.setOrdinate(i, o, t.getOrdinate(e, o));\n  }, Wt.isRing = function (t) {\n    var e = t.size();\n    return 0 === e || !(e <= 3) && t.getOrdinate(0, V.X) === t.getOrdinate(e - 1, V.X) && t.getOrdinate(0, V.Y) === t.getOrdinate(e - 1, V.Y);\n  }, Wt.isEqual = function (t, e) {\n    var n = t.size();\n    if (n !== e.size()) return !1;\n\n    for (var i = Math.min(t.getDimension(), e.getDimension()), r = 0; r < n; r++) for (var o = 0; o < i; o++) {\n      var s = t.getOrdinate(r, o),\n          a = e.getOrdinate(r, o);\n      if (t.getOrdinate(r, o) !== e.getOrdinate(r, o) && (!v.isNaN(s) || !v.isNaN(a))) return !1;\n    }\n\n    return !0;\n  }, Wt.extend = function (t, e, n) {\n    var i = t.create(n, e.getDimension()),\n        r = e.size();\n    if (Wt.copy(e, 0, i, 0, r), r > 0) for (var o = r; o < n; o++) Wt.copy(e, r - 1, i, o, 1);\n    return i;\n  }, Wt.reverse = function (t) {\n    for (var e = t.size() - 1, n = Math.trunc(e / 2), i = 0; i <= n; i++) Wt.swap(t, i, e - i);\n  }, Wt.swap = function (t, e, n) {\n    if (e === n) return null;\n\n    for (var i = 0; i < t.getDimension(); i++) {\n      var r = t.getOrdinate(e, i);\n      t.setOrdinate(e, i, t.getOrdinate(n, i)), t.setOrdinate(n, i, r);\n    }\n  }, Wt.copy = function (t, e, n, i, r) {\n    for (var o = 0; o < r; o++) Wt.copyCoord(t, e + o, n, i + o);\n  }, Wt.toString = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n          e = t.size();\n      if (0 === e) return \"()\";\n      var n = t.getDimension(),\n          i = new D();\n      i.append(\"(\");\n\n      for (var r = 0; r < e; r++) {\n        r > 0 && i.append(\" \");\n\n        for (var o = 0; o < n; o++) o > 0 && i.append(\",\"), i.append(jt.toString(t.getOrdinate(r, o)));\n      }\n\n      return i.append(\")\"), i.toString();\n    }\n  }, Wt.ensureValidRing = function (t, e) {\n    var n = e.size();\n    if (0 === n) return e;\n    if (n <= 3) return Wt.createClosedRing(t, e, 4);\n    return e.getOrdinate(0, V.X) === e.getOrdinate(n - 1, V.X) && e.getOrdinate(0, V.Y) === e.getOrdinate(n - 1, V.Y) ? e : Wt.createClosedRing(t, e, n + 1);\n  }, Wt.createClosedRing = function (t, e, n) {\n    var i = t.create(n, e.getDimension()),\n        r = e.size();\n    Wt.copy(e, 0, i, 0, r);\n\n    for (var o = r; o < n; o++) Wt.copy(e, 0, i, o, 1);\n\n    return i;\n  };\n\n  var Kt = function (t) {\n    function e(e, n) {\n      t.call(this, n), this._points = null, this.init(e);\n    }\n\n    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n    var n = {\n      serialVersionUID: {\n        configurable: !0\n      }\n    };\n    return e.prototype.computeEnvelopeInternal = function () {\n      return this.isEmpty() ? new j() : this._points.expandEnvelope(new j());\n    }, e.prototype.isRing = function () {\n      return this.isClosed() && this.isSimple();\n    }, e.prototype.getSortIndex = function () {\n      return t.SORTINDEX_LINESTRING;\n    }, e.prototype.getCoordinates = function () {\n      return this._points.toCoordinateArray();\n    }, e.prototype.equalsExact = function () {\n      if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        if (!this.isEquivalentClass(e)) return !1;\n        var i = e;\n        if (this._points.size() !== i._points.size()) return !1;\n\n        for (var r = 0; r < this._points.size(); r++) if (!this.equal(this._points.getCoordinate(r), i._points.getCoordinate(r), n)) return !1;\n\n        return !0;\n      }\n\n      return t.prototype.equalsExact.apply(this, arguments);\n    }, e.prototype.normalize = function () {\n      for (var t = 0; t < Math.trunc(this._points.size() / 2); t++) {\n        var e = this._points.size() - 1 - t;\n        if (!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))) return this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e)) > 0 && Wt.reverse(this._points), null;\n      }\n    }, e.prototype.getCoordinate = function () {\n      return this.isEmpty() ? null : this._points.getCoordinate(0);\n    }, e.prototype.getBoundaryDimension = function () {\n      return this.isClosed() ? qt.FALSE : 0;\n    }, e.prototype.isClosed = function () {\n      return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));\n    }, e.prototype.getEndPoint = function () {\n      return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);\n    }, e.prototype.getDimension = function () {\n      return 1;\n    }, e.prototype.getLength = function () {\n      return at.computeLength(this._points);\n    }, e.prototype.getNumPoints = function () {\n      return this._points.size();\n    }, e.prototype.reverse = function () {\n      var t = this._points.copy();\n\n      Wt.reverse(t);\n      return this.getFactory().createLineString(t);\n    }, e.prototype.compareToSameClass = function () {\n      if (1 === arguments.length) {\n        for (var t = arguments[0], e = 0, n = 0; e < this._points.size() && n < t._points.size();) {\n          var i = this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));\n\n          if (0 !== i) return i;\n          e++, n++;\n        }\n\n        return e < this._points.size() ? 1 : n < t._points.size() ? -1 : 0;\n      }\n\n      if (2 === arguments.length) {\n        var r = arguments[0];\n        return arguments[1].compare(this._points, r._points);\n      }\n    }, e.prototype.apply = function () {\n      if (T(arguments[0], ft)) for (var t = arguments[0], e = 0; e < this._points.size(); e++) t.filter(this._points.getCoordinate(e));else if (T(arguments[0], Ut)) {\n        var n = arguments[0];\n        if (0 === this._points.size()) return null;\n\n        for (var i = 0; i < this._points.size() && (n.filter(this._points, i), !n.isDone()); i++);\n\n        n.isGeometryChanged() && this.geometryChanged();\n      } else if (T(arguments[0], Vt)) {\n        arguments[0].filter(this);\n      } else if (T(arguments[0], lt)) {\n        arguments[0].filter(this);\n      }\n    }, e.prototype.getBoundary = function () {\n      return new Yt(this).getBoundary();\n    }, e.prototype.isEquivalentClass = function (t) {\n      return t instanceof e;\n    }, e.prototype.clone = function () {\n      var e = t.prototype.clone.call(this);\n      return e._points = this._points.clone(), e;\n    }, e.prototype.getCoordinateN = function (t) {\n      return this._points.getCoordinate(t);\n    }, e.prototype.getGeometryType = function () {\n      return \"LineString\";\n    }, e.prototype.copy = function () {\n      return new e(this._points.copy(), this._factory);\n    }, e.prototype.getCoordinateSequence = function () {\n      return this._points;\n    }, e.prototype.isEmpty = function () {\n      return 0 === this._points.size();\n    }, e.prototype.init = function (t) {\n      if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size()) throw new m(\"Invalid number of points in LineString (found \" + t.size() + \" - must be 0 or >= 2)\");\n      this._points = t;\n    }, e.prototype.isCoordinate = function (t) {\n      for (var e = 0; e < this._points.size(); e++) if (this._points.getCoordinate(e).equals(t)) return !0;\n\n      return !1;\n    }, e.prototype.getStartPoint = function () {\n      return this.isEmpty() ? null : this.getPointN(0);\n    }, e.prototype.getPointN = function (t) {\n      return this.getFactory().createPoint(this._points.getCoordinate(t));\n    }, e.prototype.interfaces_ = function () {\n      return [At];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, n.serialVersionUID.get = function () {\n      return 0x2b2b51ba435c8e00;\n    }, Object.defineProperties(e, n), e;\n  }(ct),\n      Jt = function () {};\n\n  Jt.prototype.interfaces_ = function () {\n    return [];\n  }, Jt.prototype.getClass = function () {\n    return Jt;\n  };\n\n  var Qt = function (t) {\n    function e(e, n) {\n      t.call(this, n), this._coordinates = e || null, this.init(this._coordinates);\n    }\n\n    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n    var n = {\n      serialVersionUID: {\n        configurable: !0\n      }\n    };\n    return e.prototype.computeEnvelopeInternal = function () {\n      if (this.isEmpty()) return new j();\n      var t = new j();\n      return t.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t;\n    }, e.prototype.getSortIndex = function () {\n      return t.SORTINDEX_POINT;\n    }, e.prototype.getCoordinates = function () {\n      return this.isEmpty() ? [] : [this.getCoordinate()];\n    }, e.prototype.equalsExact = function () {\n      if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        return !!this.isEquivalentClass(e) && (!(!this.isEmpty() || !e.isEmpty()) || this.isEmpty() === e.isEmpty() && this.equal(e.getCoordinate(), this.getCoordinate(), n));\n      }\n\n      return t.prototype.equalsExact.apply(this, arguments);\n    }, e.prototype.normalize = function () {}, e.prototype.getCoordinate = function () {\n      return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null;\n    }, e.prototype.getBoundaryDimension = function () {\n      return qt.FALSE;\n    }, e.prototype.getDimension = function () {\n      return 0;\n    }, e.prototype.getNumPoints = function () {\n      return this.isEmpty() ? 0 : 1;\n    }, e.prototype.reverse = function () {\n      return this.copy();\n    }, e.prototype.getX = function () {\n      if (null === this.getCoordinate()) throw new Error(\"getX called on empty Point\");\n      return this.getCoordinate().x;\n    }, e.prototype.compareToSameClass = function () {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return this.getCoordinate().compareTo(t.getCoordinate());\n      }\n\n      if (2 === arguments.length) {\n        var e = arguments[0];\n        return arguments[1].compare(this._coordinates, e._coordinates);\n      }\n    }, e.prototype.apply = function () {\n      if (T(arguments[0], ft)) {\n        var t = arguments[0];\n        if (this.isEmpty()) return null;\n        t.filter(this.getCoordinate());\n      } else if (T(arguments[0], Ut)) {\n        var e = arguments[0];\n        if (this.isEmpty()) return null;\n        e.filter(this._coordinates, 0), e.isGeometryChanged() && this.geometryChanged();\n      } else if (T(arguments[0], Vt)) {\n        arguments[0].filter(this);\n      } else if (T(arguments[0], lt)) {\n        arguments[0].filter(this);\n      }\n    }, e.prototype.getBoundary = function () {\n      return this.getFactory().createGeometryCollection(null);\n    }, e.prototype.clone = function () {\n      var e = t.prototype.clone.call(this);\n      return e._coordinates = this._coordinates.clone(), e;\n    }, e.prototype.getGeometryType = function () {\n      return \"Point\";\n    }, e.prototype.copy = function () {\n      return new e(this._coordinates.copy(), this._factory);\n    }, e.prototype.getCoordinateSequence = function () {\n      return this._coordinates;\n    }, e.prototype.getY = function () {\n      if (null === this.getCoordinate()) throw new Error(\"getY called on empty Point\");\n      return this.getCoordinate().y;\n    }, e.prototype.isEmpty = function () {\n      return 0 === this._coordinates.size();\n    }, e.prototype.init = function (t) {\n      null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), et.isTrue(t.size() <= 1), this._coordinates = t;\n    }, e.prototype.isSimple = function () {\n      return !0;\n    }, e.prototype.interfaces_ = function () {\n      return [Jt];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, n.serialVersionUID.get = function () {\n      return 0x44077bad161cbc00;\n    }, Object.defineProperties(e, n), e;\n  }(ct),\n      Zt = function () {};\n\n  Zt.prototype.interfaces_ = function () {\n    return [];\n  }, Zt.prototype.getClass = function () {\n    return Zt;\n  };\n\n  var $t = function (t) {\n    function e(e, n, i) {\n      if (t.call(this, i), this._shell = null, this._holes = null, null === e && (e = this.getFactory().createLinearRing()), null === n && (n = []), t.hasNullElements(n)) throw new m(\"holes must not contain null elements\");\n      if (e.isEmpty() && t.hasNonEmptyElements(n)) throw new m(\"shell is empty but holes are not\");\n      this._shell = e, this._holes = n;\n    }\n\n    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n    var n = {\n      serialVersionUID: {\n        configurable: !0\n      }\n    };\n    return e.prototype.computeEnvelopeInternal = function () {\n      return this._shell.getEnvelopeInternal();\n    }, e.prototype.getSortIndex = function () {\n      return t.SORTINDEX_POLYGON;\n    }, e.prototype.getCoordinates = function () {\n      if (this.isEmpty()) return [];\n\n      for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = this._shell.getCoordinates(), i = 0; i < n.length; i++) t[++e] = n[i];\n\n      for (var r = 0; r < this._holes.length; r++) for (var o = this._holes[r].getCoordinates(), s = 0; s < o.length; s++) t[++e] = o[s];\n\n      return t;\n    }, e.prototype.getArea = function () {\n      var t = 0;\n      t += Math.abs(at.signedArea(this._shell.getCoordinateSequence()));\n\n      for (var e = 0; e < this._holes.length; e++) t -= Math.abs(at.signedArea(this._holes[e].getCoordinateSequence()));\n\n      return t;\n    }, e.prototype.isRectangle = function () {\n      if (0 !== this.getNumInteriorRing()) return !1;\n      if (null === this._shell) return !1;\n      if (5 !== this._shell.getNumPoints()) return !1;\n\n      for (var t = this._shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), n = 0; n < 5; n++) {\n        var i = t.getX(n);\n        if (i !== e.getMinX() && i !== e.getMaxX()) return !1;\n        var r = t.getY(n);\n        if (r !== e.getMinY() && r !== e.getMaxY()) return !1;\n      }\n\n      for (var o = t.getX(0), s = t.getY(0), a = 1; a <= 4; a++) {\n        var u = t.getX(a),\n            l = t.getY(a);\n        if (u !== o === (l !== s)) return !1;\n        o = u, s = l;\n      }\n\n      return !0;\n    }, e.prototype.equalsExact = function () {\n      if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        if (!this.isEquivalentClass(e)) return !1;\n        var i = e,\n            r = this._shell,\n            o = i._shell;\n        if (!r.equalsExact(o, n)) return !1;\n        if (this._holes.length !== i._holes.length) return !1;\n\n        for (var s = 0; s < this._holes.length; s++) if (!this._holes[s].equalsExact(i._holes[s], n)) return !1;\n\n        return !0;\n      }\n\n      return t.prototype.equalsExact.apply(this, arguments);\n    }, e.prototype.normalize = function () {\n      if (0 === arguments.length) {\n        this.normalize(this._shell, !0);\n\n        for (var t = 0; t < this._holes.length; t++) this.normalize(this._holes[t], !1);\n\n        Gt.sort(this._holes);\n      } else if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        if (e.isEmpty()) return null;\n        var i = new Array(e.getCoordinates().length - 1).fill(null);\n        Y.arraycopy(e.getCoordinates(), 0, i, 0, i.length);\n        var r = Lt.minCoordinate(e.getCoordinates());\n        Lt.scroll(i, r), Y.arraycopy(i, 0, e.getCoordinates(), 0, i.length), e.getCoordinates()[i.length] = i[0], at.isCCW(e.getCoordinates()) === n && Lt.reverse(e.getCoordinates());\n      }\n    }, e.prototype.getCoordinate = function () {\n      return this._shell.getCoordinate();\n    }, e.prototype.getNumInteriorRing = function () {\n      return this._holes.length;\n    }, e.prototype.getBoundaryDimension = function () {\n      return 1;\n    }, e.prototype.getDimension = function () {\n      return 2;\n    }, e.prototype.getLength = function () {\n      var t = 0;\n      t += this._shell.getLength();\n\n      for (var e = 0; e < this._holes.length; e++) t += this._holes[e].getLength();\n\n      return t;\n    }, e.prototype.getNumPoints = function () {\n      for (var t = this._shell.getNumPoints(), e = 0; e < this._holes.length; e++) t += this._holes[e].getNumPoints();\n\n      return t;\n    }, e.prototype.reverse = function () {\n      var t = this.copy();\n      t._shell = this._shell.copy().reverse(), t._holes = new Array(this._holes.length).fill(null);\n\n      for (var e = 0; e < this._holes.length; e++) t._holes[e] = this._holes[e].copy().reverse();\n\n      return t;\n    }, e.prototype.convexHull = function () {\n      return this.getExteriorRing().convexHull();\n    }, e.prototype.compareToSameClass = function () {\n      if (1 === arguments.length) {\n        var t = arguments[0],\n            e = this._shell,\n            n = t._shell;\n        return e.compareToSameClass(n);\n      }\n\n      if (2 === arguments.length) {\n        var i = arguments[0],\n            r = arguments[1],\n            o = i,\n            s = this._shell,\n            a = o._shell,\n            u = s.compareToSameClass(a, r);\n        if (0 !== u) return u;\n\n        for (var l = this.getNumInteriorRing(), c = o.getNumInteriorRing(), p = 0; p < l && p < c;) {\n          var h = this.getInteriorRingN(p),\n              f = o.getInteriorRingN(p),\n              g = h.compareToSameClass(f, r);\n          if (0 !== g) return g;\n          p++;\n        }\n\n        return p < l ? 1 : p < c ? -1 : 0;\n      }\n    }, e.prototype.apply = function (t) {\n      if (T(t, ft)) {\n        this._shell.apply(t);\n\n        for (var e = 0; e < this._holes.length; e++) this._holes[e].apply(t);\n      } else if (T(t, Ut)) {\n        if (this._shell.apply(t), !t.isDone()) for (var n = 0; n < this._holes.length && (this._holes[n].apply(t), !t.isDone()); n++);\n        t.isGeometryChanged() && this.geometryChanged();\n      } else if (T(t, Vt)) t.filter(this);else if (T(t, lt)) {\n        t.filter(this), this._shell.apply(t);\n\n        for (var i = 0; i < this._holes.length; i++) this._holes[i].apply(t);\n      }\n    }, e.prototype.getBoundary = function () {\n      if (this.isEmpty()) return this.getFactory().createMultiLineString();\n      var t = new Array(this._holes.length + 1).fill(null);\n      t[0] = this._shell;\n\n      for (var e = 0; e < this._holes.length; e++) t[e + 1] = this._holes[e];\n\n      return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t);\n    }, e.prototype.clone = function () {\n      var e = t.prototype.clone.call(this);\n      e._shell = this._shell.clone(), e._holes = new Array(this._holes.length).fill(null);\n\n      for (var n = 0; n < this._holes.length; n++) e._holes[n] = this._holes[n].clone();\n\n      return e;\n    }, e.prototype.getGeometryType = function () {\n      return \"Polygon\";\n    }, e.prototype.copy = function () {\n      for (var t = this._shell.copy(), n = new Array(this._holes.length).fill(null), i = 0; i < n.length; i++) n[i] = this._holes[i].copy();\n\n      return new e(t, n, this._factory);\n    }, e.prototype.getExteriorRing = function () {\n      return this._shell;\n    }, e.prototype.isEmpty = function () {\n      return this._shell.isEmpty();\n    }, e.prototype.getInteriorRingN = function (t) {\n      return this._holes[t];\n    }, e.prototype.interfaces_ = function () {\n      return [Zt];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, n.serialVersionUID.get = function () {\n      return -0x307ffefd8dc97200;\n    }, Object.defineProperties(e, n), e;\n  }(ct),\n      te = function (t) {\n    function e() {\n      t.apply(this, arguments);\n    }\n\n    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n    var n = {\n      serialVersionUID: {\n        configurable: !0\n      }\n    };\n    return e.prototype.getSortIndex = function () {\n      return ct.SORTINDEX_MULTIPOINT;\n    }, e.prototype.isValid = function () {\n      return !0;\n    }, e.prototype.equalsExact = function () {\n      if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n);\n      }\n\n      return t.prototype.equalsExact.apply(this, arguments);\n    }, e.prototype.getCoordinate = function () {\n      if (1 === arguments.length) {\n        var e = arguments[0];\n        return this._geometries[e].getCoordinate();\n      }\n\n      return t.prototype.getCoordinate.apply(this, arguments);\n    }, e.prototype.getBoundaryDimension = function () {\n      return qt.FALSE;\n    }, e.prototype.getDimension = function () {\n      return 0;\n    }, e.prototype.getBoundary = function () {\n      return this.getFactory().createGeometryCollection(null);\n    }, e.prototype.getGeometryType = function () {\n      return \"MultiPoint\";\n    }, e.prototype.copy = function () {\n      for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++) t[n] = this._geometries[n].copy();\n\n      return new e(t, this._factory);\n    }, e.prototype.interfaces_ = function () {\n      return [Jt];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, n.serialVersionUID.get = function () {\n      return -0x6fb1ed4162e0fc00;\n    }, Object.defineProperties(e, n), e;\n  }(zt),\n      ee = function (t) {\n    function e(e, n) {\n      e instanceof C && n instanceof _e && (e = n.getCoordinateSequenceFactory().create(e)), t.call(this, e, n), this.validateConstruction();\n    }\n\n    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n    var n = {\n      MINIMUM_VALID_SIZE: {\n        configurable: !0\n      },\n      serialVersionUID: {\n        configurable: !0\n      }\n    };\n    return e.prototype.getSortIndex = function () {\n      return ct.SORTINDEX_LINEARRING;\n    }, e.prototype.getBoundaryDimension = function () {\n      return qt.FALSE;\n    }, e.prototype.isClosed = function () {\n      return !!this.isEmpty() || t.prototype.isClosed.call(this);\n    }, e.prototype.reverse = function () {\n      var t = this._points.copy();\n\n      Wt.reverse(t);\n      return this.getFactory().createLinearRing(t);\n    }, e.prototype.validateConstruction = function () {\n      if (!this.isEmpty() && !t.prototype.isClosed.call(this)) throw new m(\"Points of LinearRing do not form a closed linestring\");\n      if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < e.MINIMUM_VALID_SIZE) throw new m(\"Invalid number of points in LinearRing (found \" + this.getCoordinateSequence().size() + \" - must be 0 or >= 4)\");\n    }, e.prototype.getGeometryType = function () {\n      return \"LinearRing\";\n    }, e.prototype.copy = function () {\n      return new e(this._points.copy(), this._factory);\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, n.MINIMUM_VALID_SIZE.get = function () {\n      return 4;\n    }, n.serialVersionUID.get = function () {\n      return -0x3b229e262367a600;\n    }, Object.defineProperties(e, n), e;\n  }(Kt),\n      ne = function (t) {\n    function e() {\n      t.apply(this, arguments);\n    }\n\n    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n    var n = {\n      serialVersionUID: {\n        configurable: !0\n      }\n    };\n    return e.prototype.getSortIndex = function () {\n      return ct.SORTINDEX_MULTIPOLYGON;\n    }, e.prototype.equalsExact = function () {\n      if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n);\n      }\n\n      return t.prototype.equalsExact.apply(this, arguments);\n    }, e.prototype.getBoundaryDimension = function () {\n      return 1;\n    }, e.prototype.getDimension = function () {\n      return 2;\n    }, e.prototype.reverse = function () {\n      for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++) e[n] = this._geometries[n].reverse();\n\n      return this.getFactory().createMultiPolygon(e);\n    }, e.prototype.getBoundary = function () {\n      if (this.isEmpty()) return this.getFactory().createMultiLineString();\n\n      for (var t = new Nt(), e = 0; e < this._geometries.length; e++) for (var n = this._geometries[e].getBoundary(), i = 0; i < n.getNumGeometries(); i++) t.add(n.getGeometryN(i));\n\n      var r = new Array(t.size()).fill(null);\n      return this.getFactory().createMultiLineString(t.toArray(r));\n    }, e.prototype.getGeometryType = function () {\n      return \"MultiPolygon\";\n    }, e.prototype.copy = function () {\n      for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++) t[n] = this._geometries[n].copy();\n\n      return new e(t, this._factory);\n    }, e.prototype.interfaces_ = function () {\n      return [Zt];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, n.serialVersionUID.get = function () {\n      return -0x7a5aa1369171980;\n    }, Object.defineProperties(e, n), e;\n  }(zt),\n      ie = function (t) {\n    this._factory = t || null, this._isUserDataCopied = !1;\n  },\n      re = {\n    NoOpGeometryOperation: {\n      configurable: !0\n    },\n    CoordinateOperation: {\n      configurable: !0\n    },\n    CoordinateSequenceOperation: {\n      configurable: !0\n    }\n  };\n\n  ie.prototype.setCopyUserData = function (t) {\n    this._isUserDataCopied = t;\n  }, ie.prototype.edit = function (t, e) {\n    if (null === t) return null;\n    var n = this.editInternal(t, e);\n    return this._isUserDataCopied && n.setUserData(t.getUserData()), n;\n  }, ie.prototype.editInternal = function (t, e) {\n    return null === this._factory && (this._factory = t.getFactory()), t instanceof zt ? this.editGeometryCollection(t, e) : t instanceof $t ? this.editPolygon(t, e) : t instanceof Qt ? e.edit(t, this._factory) : t instanceof Kt ? e.edit(t, this._factory) : (et.shouldNeverReachHere(\"Unsupported Geometry class: \" + t.getClass().getName()), null);\n  }, ie.prototype.editGeometryCollection = function (t, e) {\n    for (var n = e.edit(t, this._factory), i = new Nt(), r = 0; r < n.getNumGeometries(); r++) {\n      var o = this.edit(n.getGeometryN(r), e);\n      null === o || o.isEmpty() || i.add(o);\n    }\n\n    return n.getClass() === te ? this._factory.createMultiPoint(i.toArray([])) : n.getClass() === Xt ? this._factory.createMultiLineString(i.toArray([])) : n.getClass() === ne ? this._factory.createMultiPolygon(i.toArray([])) : this._factory.createGeometryCollection(i.toArray([]));\n  }, ie.prototype.editPolygon = function (t, e) {\n    var n = e.edit(t, this._factory);\n    if (null === n && (n = this._factory.createPolygon(null)), n.isEmpty()) return n;\n    var i = this.edit(n.getExteriorRing(), e);\n    if (null === i || i.isEmpty()) return this._factory.createPolygon();\n\n    for (var r = new Nt(), o = 0; o < n.getNumInteriorRing(); o++) {\n      var s = this.edit(n.getInteriorRingN(o), e);\n      null === s || s.isEmpty() || r.add(s);\n    }\n\n    return this._factory.createPolygon(i, r.toArray([]));\n  }, ie.prototype.interfaces_ = function () {\n    return [];\n  }, ie.prototype.getClass = function () {\n    return ie;\n  }, ie.GeometryEditorOperation = function () {}, re.NoOpGeometryOperation.get = function () {\n    return oe;\n  }, re.CoordinateOperation.get = function () {\n    return se;\n  }, re.CoordinateSequenceOperation.get = function () {\n    return ae;\n  }, Object.defineProperties(ie, re);\n\n  var oe = function () {};\n\n  oe.prototype.edit = function (t, e) {\n    return t;\n  }, oe.prototype.interfaces_ = function () {\n    return [ie.GeometryEditorOperation];\n  }, oe.prototype.getClass = function () {\n    return oe;\n  };\n\n  var se = function () {};\n\n  se.prototype.edit = function (t, e) {\n    var n = this.editCoordinates(t.getCoordinates(), t);\n    return null === n ? t : t instanceof ee ? e.createLinearRing(n) : t instanceof Kt ? e.createLineString(n) : t instanceof Qt ? n.length > 0 ? e.createPoint(n[0]) : e.createPoint() : t;\n  }, se.prototype.interfaces_ = function () {\n    return [ie.GeometryEditorOperation];\n  }, se.prototype.getClass = function () {\n    return se;\n  };\n\n  var ae = function () {};\n\n  ae.prototype.edit = function (t, e) {\n    return t instanceof ee ? e.createLinearRing(this.edit(t.getCoordinateSequence(), t)) : t instanceof Kt ? e.createLineString(this.edit(t.getCoordinateSequence(), t)) : t instanceof Qt ? e.createPoint(this.edit(t.getCoordinateSequence(), t)) : t;\n  }, ae.prototype.interfaces_ = function () {\n    return [ie.GeometryEditorOperation];\n  }, ae.prototype.getClass = function () {\n    return ae;\n  };\n\n  var ue = function () {\n    if (this._dimension = 3, this._coordinates = null, 1 === arguments.length) {\n      if (arguments[0] instanceof Array) this._coordinates = arguments[0], this._dimension = 3;else if (Number.isInteger(arguments[0])) {\n        var t = arguments[0];\n        this._coordinates = new Array(t).fill(null);\n\n        for (var e = 0; e < t; e++) this._coordinates[e] = new C();\n      } else if (T(arguments[0], V)) {\n        var n = arguments[0];\n        if (null === n) return this._coordinates = new Array(0).fill(null), null;\n        this._dimension = n.getDimension(), this._coordinates = new Array(n.size()).fill(null);\n\n        for (var i = 0; i < this._coordinates.length; i++) this._coordinates[i] = n.getCoordinateCopy(i);\n      }\n    } else if (2 === arguments.length) if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n      var r = arguments[0],\n          o = arguments[1];\n      this._coordinates = r, this._dimension = o, null === r && (this._coordinates = new Array(0).fill(null));\n    } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n      var s = arguments[0],\n          a = arguments[1];\n      this._coordinates = new Array(s).fill(null), this._dimension = a;\n\n      for (var u = 0; u < s; u++) this._coordinates[u] = new C();\n    }\n  },\n      le = {\n    serialVersionUID: {\n      configurable: !0\n    }\n  };\n\n  ue.prototype.setOrdinate = function (t, e, n) {\n    switch (e) {\n      case V.X:\n        this._coordinates[t].x = n;\n        break;\n\n      case V.Y:\n        this._coordinates[t].y = n;\n        break;\n\n      case V.Z:\n        this._coordinates[t].z = n;\n        break;\n\n      default:\n        throw new m(\"invalid ordinateIndex\");\n    }\n  }, ue.prototype.size = function () {\n    return this._coordinates.length;\n  }, ue.prototype.getOrdinate = function (t, e) {\n    switch (e) {\n      case V.X:\n        return this._coordinates[t].x;\n\n      case V.Y:\n        return this._coordinates[t].y;\n\n      case V.Z:\n        return this._coordinates[t].z;\n    }\n\n    return v.NaN;\n  }, ue.prototype.getCoordinate = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return this._coordinates[t];\n    }\n\n    if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      n.x = this._coordinates[e].x, n.y = this._coordinates[e].y, n.z = this._coordinates[e].z;\n    }\n  }, ue.prototype.getCoordinateCopy = function (t) {\n    return new C(this._coordinates[t]);\n  }, ue.prototype.getDimension = function () {\n    return this._dimension;\n  }, ue.prototype.getX = function (t) {\n    return this._coordinates[t].x;\n  }, ue.prototype.clone = function () {\n    for (var t = new Array(this.size()).fill(null), e = 0; e < this._coordinates.length; e++) t[e] = this._coordinates[e].clone();\n\n    return new ue(t, this._dimension);\n  }, ue.prototype.expandEnvelope = function (t) {\n    for (var e = 0; e < this._coordinates.length; e++) t.expandToInclude(this._coordinates[e]);\n\n    return t;\n  }, ue.prototype.copy = function () {\n    for (var t = new Array(this.size()).fill(null), e = 0; e < this._coordinates.length; e++) t[e] = this._coordinates[e].copy();\n\n    return new ue(t, this._dimension);\n  }, ue.prototype.toString = function () {\n    if (this._coordinates.length > 0) {\n      var t = new D(17 * this._coordinates.length);\n      t.append(\"(\"), t.append(this._coordinates[0]);\n\n      for (var e = 1; e < this._coordinates.length; e++) t.append(\", \"), t.append(this._coordinates[e]);\n\n      return t.append(\")\"), t.toString();\n    }\n\n    return \"()\";\n  }, ue.prototype.getY = function (t) {\n    return this._coordinates[t].y;\n  }, ue.prototype.toCoordinateArray = function () {\n    return this._coordinates;\n  }, ue.prototype.interfaces_ = function () {\n    return [V, e];\n  }, ue.prototype.getClass = function () {\n    return ue;\n  }, le.serialVersionUID.get = function () {\n    return -0xcb44a778db18e00;\n  }, Object.defineProperties(ue, le);\n\n  var ce = function () {},\n      pe = {\n    serialVersionUID: {\n      configurable: !0\n    },\n    instanceObject: {\n      configurable: !0\n    }\n  };\n\n  ce.prototype.readResolve = function () {\n    return ce.instance();\n  }, ce.prototype.create = function () {\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof Array) {\n        var t = arguments[0];\n        return new ue(t);\n      }\n\n      if (T(arguments[0], V)) {\n        var e = arguments[0];\n        return new ue(e);\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1];\n      return i > 3 && (i = 3), i < 2 ? new ue(n) : new ue(n, i);\n    }\n  }, ce.prototype.interfaces_ = function () {\n    return [b, e];\n  }, ce.prototype.getClass = function () {\n    return ce;\n  }, ce.instance = function () {\n    return ce.instanceObject;\n  }, pe.serialVersionUID.get = function () {\n    return -0x38e49fa6cf6f2e00;\n  }, pe.instanceObject.get = function () {\n    return new ce();\n  }, Object.defineProperties(ce, pe);\n\n  var he = function (t) {\n    function e() {\n      t.call(this), this.map_ = new Map();\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.get = function (t) {\n      return this.map_.get(t) || null;\n    }, e.prototype.put = function (t, e) {\n      return this.map_.set(t, e), e;\n    }, e.prototype.values = function () {\n      for (var t = new Nt(), e = this.map_.values(), n = e.next(); !n.done;) t.add(n.value), n = e.next();\n\n      return t;\n    }, e.prototype.entrySet = function () {\n      var t = new Pt();\n      return this.map_.entries().forEach(function (e) {\n        return t.add(e);\n      }), t;\n    }, e.prototype.size = function () {\n      return this.map_.size();\n    }, e;\n  }(Tt),\n      fe = function t() {\n    if (this._modelType = null, this._scale = null, 0 === arguments.length) this._modelType = t.FLOATING;else if (1 === arguments.length) if (arguments[0] instanceof de) {\n      var e = arguments[0];\n      this._modelType = e, e === t.FIXED && this.setScale(1);\n    } else if (\"number\" == typeof arguments[0]) {\n      var n = arguments[0];\n      this._modelType = t.FIXED, this.setScale(n);\n    } else if (arguments[0] instanceof t) {\n      var i = arguments[0];\n      this._modelType = i._modelType, this._scale = i._scale;\n    }\n  },\n      ge = {\n    serialVersionUID: {\n      configurable: !0\n    },\n    maximumPreciseValue: {\n      configurable: !0\n    }\n  };\n\n  fe.prototype.equals = function (t) {\n    if (!(t instanceof fe)) return !1;\n    var e = t;\n    return this._modelType === e._modelType && this._scale === e._scale;\n  }, fe.prototype.compareTo = function (t) {\n    var e = t,\n        n = this.getMaximumSignificantDigits(),\n        i = e.getMaximumSignificantDigits();\n    return new M(n).compareTo(new M(i));\n  }, fe.prototype.getScale = function () {\n    return this._scale;\n  }, fe.prototype.isFloating = function () {\n    return this._modelType === fe.FLOATING || this._modelType === fe.FLOATING_SINGLE;\n  }, fe.prototype.getType = function () {\n    return this._modelType;\n  }, fe.prototype.toString = function () {\n    var t = \"UNKNOWN\";\n    return this._modelType === fe.FLOATING ? t = \"Floating\" : this._modelType === fe.FLOATING_SINGLE ? t = \"Floating-Single\" : this._modelType === fe.FIXED && (t = \"Fixed (Scale=\" + this.getScale() + \")\"), t;\n  }, fe.prototype.makePrecise = function () {\n    if (\"number\" == typeof arguments[0]) {\n      var t = arguments[0];\n      if (v.isNaN(t)) return t;\n\n      if (this._modelType === fe.FLOATING_SINGLE) {\n        return t;\n      }\n\n      return this._modelType === fe.FIXED ? Math.round(t * this._scale) / this._scale : t;\n    }\n\n    if (arguments[0] instanceof C) {\n      var e = arguments[0];\n      if (this._modelType === fe.FLOATING) return null;\n      e.x = this.makePrecise(e.x), e.y = this.makePrecise(e.y);\n    }\n  }, fe.prototype.getMaximumSignificantDigits = function () {\n    var t = 16;\n    return this._modelType === fe.FLOATING ? t = 16 : this._modelType === fe.FLOATING_SINGLE ? t = 6 : this._modelType === fe.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t;\n  }, fe.prototype.setScale = function (t) {\n    this._scale = Math.abs(t);\n  }, fe.prototype.interfaces_ = function () {\n    return [e, E];\n  }, fe.prototype.getClass = function () {\n    return fe;\n  }, fe.mostPrecise = function (t, e) {\n    return t.compareTo(e) >= 0 ? t : e;\n  }, ge.serialVersionUID.get = function () {\n    return 0x6bee6404e9a25c00;\n  }, ge.maximumPreciseValue.get = function () {\n    return 9007199254740992;\n  }, Object.defineProperties(fe, ge);\n\n  var de = function t(e) {\n    this._name = e || null, t.nameToTypeMap.put(e, this);\n  },\n      ye = {\n    serialVersionUID: {\n      configurable: !0\n    },\n    nameToTypeMap: {\n      configurable: !0\n    }\n  };\n\n  de.prototype.readResolve = function () {\n    return de.nameToTypeMap.get(this._name);\n  }, de.prototype.toString = function () {\n    return this._name;\n  }, de.prototype.interfaces_ = function () {\n    return [e];\n  }, de.prototype.getClass = function () {\n    return de;\n  }, ye.serialVersionUID.get = function () {\n    return -552860263173159e4;\n  }, ye.nameToTypeMap.get = function () {\n    return new he();\n  }, Object.defineProperties(de, ye), fe.Type = de, fe.FIXED = new de(\"FIXED\"), fe.FLOATING = new de(\"FLOATING\"), fe.FLOATING_SINGLE = new de(\"FLOATING SINGLE\");\n\n  var _e = function t() {\n    this._precisionModel = new fe(), this._SRID = 0, this._coordinateSequenceFactory = t.getDefaultCoordinateSequenceFactory(), 0 === arguments.length || (1 === arguments.length ? T(arguments[0], b) ? this._coordinateSequenceFactory = arguments[0] : arguments[0] instanceof fe && (this._precisionModel = arguments[0]) : 2 === arguments.length ? (this._precisionModel = arguments[0], this._SRID = arguments[1]) : 3 === arguments.length && (this._precisionModel = arguments[0], this._SRID = arguments[1], this._coordinateSequenceFactory = arguments[2]));\n  },\n      me = {\n    serialVersionUID: {\n      configurable: !0\n    }\n  };\n\n  _e.prototype.toGeometry = function (t) {\n    return t.isNull() ? this.createPoint(null) : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new C(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new C(t.getMinX(), t.getMinY()), new C(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new C(t.getMinX(), t.getMinY()), new C(t.getMinX(), t.getMaxY()), new C(t.getMaxX(), t.getMaxY()), new C(t.getMaxX(), t.getMinY()), new C(t.getMinX(), t.getMinY())]), null);\n  }, _e.prototype.createLineString = function (t) {\n    return t ? t instanceof Array ? new Kt(this.getCoordinateSequenceFactory().create(t), this) : T(t, V) ? new Kt(t, this) : void 0 : new Kt(this.getCoordinateSequenceFactory().create([]), this);\n  }, _e.prototype.createMultiLineString = function () {\n    if (0 === arguments.length) return new Xt(null, this);\n\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return new Xt(t, this);\n    }\n  }, _e.prototype.buildGeometry = function (t) {\n    for (var e = null, n = !1, i = !1, r = t.iterator(); r.hasNext();) {\n      var o = r.next(),\n          s = o.getClass();\n      null === e && (e = s), s !== e && (n = !0), o.isGeometryCollectionOrDerived() && (i = !0);\n    }\n\n    if (null === e) return this.createGeometryCollection();\n    if (n || i) return this.createGeometryCollection(_e.toGeometryArray(t));\n    var a = t.iterator().next();\n\n    if (t.size() > 1) {\n      if (a instanceof $t) return this.createMultiPolygon(_e.toPolygonArray(t));\n      if (a instanceof Kt) return this.createMultiLineString(_e.toLineStringArray(t));\n      if (a instanceof Qt) return this.createMultiPoint(_e.toPointArray(t));\n      et.shouldNeverReachHere(\"Unhandled class: \" + a.getClass().getName());\n    }\n\n    return a;\n  }, _e.prototype.createMultiPointFromCoords = function (t) {\n    return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);\n  }, _e.prototype.createPoint = function () {\n    if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([]));\n\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof C) {\n        var t = arguments[0];\n        return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null);\n      }\n\n      if (T(arguments[0], V)) {\n        var e = arguments[0];\n        return new Qt(e, this);\n      }\n    }\n  }, _e.prototype.getCoordinateSequenceFactory = function () {\n    return this._coordinateSequenceFactory;\n  }, _e.prototype.createPolygon = function () {\n    if (0 === arguments.length) return new $t(null, null, this);\n\n    if (1 === arguments.length) {\n      if (T(arguments[0], V)) {\n        var t = arguments[0];\n        return this.createPolygon(this.createLinearRing(t));\n      }\n\n      if (arguments[0] instanceof Array) {\n        var e = arguments[0];\n        return this.createPolygon(this.createLinearRing(e));\n      }\n\n      if (arguments[0] instanceof ee) {\n        var n = arguments[0];\n        return this.createPolygon(n, null);\n      }\n    } else if (2 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1];\n      return new $t(i, r, this);\n    }\n  }, _e.prototype.getSRID = function () {\n    return this._SRID;\n  }, _e.prototype.createGeometryCollection = function () {\n    if (0 === arguments.length) return new zt(null, this);\n\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return new zt(t, this);\n    }\n  }, _e.prototype.createGeometry = function (t) {\n    return new ie(this).edit(t, {\n      edit: function () {\n        if (2 === arguments.length) {\n          var t = arguments[0];\n          return this._coordinateSequenceFactory.create(t);\n        }\n      }\n    });\n  }, _e.prototype.getPrecisionModel = function () {\n    return this._precisionModel;\n  }, _e.prototype.createLinearRing = function () {\n    if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));\n\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof Array) {\n        var t = arguments[0];\n        return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);\n      }\n\n      if (T(arguments[0], V)) {\n        var e = arguments[0];\n        return new ee(e, this);\n      }\n    }\n  }, _e.prototype.createMultiPolygon = function () {\n    if (0 === arguments.length) return new ne(null, this);\n\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return new ne(t, this);\n    }\n  }, _e.prototype.createMultiPoint = function () {\n    if (0 === arguments.length) return new te(null, this);\n\n    if (1 === arguments.length) {\n      if (arguments[0] instanceof Array) {\n        var t = arguments[0];\n        return new te(t, this);\n      }\n\n      if (arguments[0] instanceof Array) {\n        var e = arguments[0];\n        return this.createMultiPoint(null !== e ? this.getCoordinateSequenceFactory().create(e) : null);\n      }\n\n      if (T(arguments[0], V)) {\n        var n = arguments[0];\n        if (null === n) return this.createMultiPoint(new Array(0).fill(null));\n\n        for (var i = new Array(n.size()).fill(null), r = 0; r < n.size(); r++) {\n          var o = this.getCoordinateSequenceFactory().create(1, n.getDimension());\n          Wt.copy(n, r, o, 0, 1), i[r] = this.createPoint(o);\n        }\n\n        return this.createMultiPoint(i);\n      }\n    }\n  }, _e.prototype.interfaces_ = function () {\n    return [e];\n  }, _e.prototype.getClass = function () {\n    return _e;\n  }, _e.toMultiPolygonArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, _e.toGeometryArray = function (t) {\n    if (null === t) return null;\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, _e.getDefaultCoordinateSequenceFactory = function () {\n    return ce.instance();\n  }, _e.toMultiLineStringArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, _e.toLineStringArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, _e.toMultiPointArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, _e.toLinearRingArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, _e.toPointArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, _e.toPolygonArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, _e.createPointFromInternalCoord = function (t, e) {\n    return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t);\n  }, me.serialVersionUID.get = function () {\n    return -0x5ea75f2051eeb400;\n  }, Object.defineProperties(_e, me);\n\n  var ve = [\"Point\", \"MultiPoint\", \"LineString\", \"MultiLineString\", \"Polygon\", \"MultiPolygon\"],\n      Ie = function (t) {\n    this.geometryFactory = t || new _e();\n  };\n\n  Ie.prototype.read = function (t) {\n    var e,\n        n = (e = \"string\" == typeof t ? JSON.parse(t) : t).type;\n    if (!Ee[n]) throw new Error(\"Unknown GeoJSON type: \" + e.type);\n    return -1 !== ve.indexOf(n) ? Ee[n].apply(this, [e.coordinates]) : \"GeometryCollection\" === n ? Ee[n].apply(this, [e.geometries]) : Ee[n].apply(this, [e]);\n  }, Ie.prototype.write = function (t) {\n    var e = t.getGeometryType();\n    if (!xe[e]) throw new Error(\"Geometry is not supported\");\n    return xe[e].apply(this, [t]);\n  };\n\n  var Ee = {\n    Feature: function (t) {\n      var e = {};\n\n      for (var n in t) e[n] = t[n];\n\n      if (t.geometry) {\n        var i = t.geometry.type;\n        if (!Ee[i]) throw new Error(\"Unknown GeoJSON type: \" + t.type);\n        e.geometry = this.read(t.geometry);\n      }\n\n      return t.bbox && (e.bbox = Ee.bbox.apply(this, [t.bbox])), e;\n    },\n    FeatureCollection: function (t) {\n      var e = {};\n\n      if (t.features) {\n        e.features = [];\n\n        for (var n = 0; n < t.features.length; ++n) e.features.push(this.read(t.features[n]));\n      }\n\n      return t.bbox && (e.bbox = this.parse.bbox.apply(this, [t.bbox])), e;\n    },\n    coordinates: function (t) {\n      for (var e = [], n = 0; n < t.length; ++n) {\n        var i = t[n];\n        e.push(new C(i[0], i[1]));\n      }\n\n      return e;\n    },\n    bbox: function (t) {\n      return this.geometryFactory.createLinearRing([new C(t[0], t[1]), new C(t[2], t[1]), new C(t[2], t[3]), new C(t[0], t[3]), new C(t[0], t[1])]);\n    },\n    Point: function (t) {\n      var e = new C(t[0], t[1]);\n      return this.geometryFactory.createPoint(e);\n    },\n    MultiPoint: function (t) {\n      for (var e = [], n = 0; n < t.length; ++n) e.push(Ee.Point.apply(this, [t[n]]));\n\n      return this.geometryFactory.createMultiPoint(e);\n    },\n    LineString: function (t) {\n      var e = Ee.coordinates.apply(this, [t]);\n      return this.geometryFactory.createLineString(e);\n    },\n    MultiLineString: function (t) {\n      for (var e = [], n = 0; n < t.length; ++n) e.push(Ee.LineString.apply(this, [t[n]]));\n\n      return this.geometryFactory.createMultiLineString(e);\n    },\n    Polygon: function (t) {\n      for (var e = Ee.coordinates.apply(this, [t[0]]), n = this.geometryFactory.createLinearRing(e), i = [], r = 1; r < t.length; ++r) {\n        var o = t[r],\n            s = Ee.coordinates.apply(this, [o]),\n            a = this.geometryFactory.createLinearRing(s);\n        i.push(a);\n      }\n\n      return this.geometryFactory.createPolygon(n, i);\n    },\n    MultiPolygon: function (t) {\n      for (var e = [], n = 0; n < t.length; ++n) {\n        var i = t[n];\n        e.push(Ee.Polygon.apply(this, [i]));\n      }\n\n      return this.geometryFactory.createMultiPolygon(e);\n    },\n    GeometryCollection: function (t) {\n      for (var e = [], n = 0; n < t.length; ++n) {\n        var i = t[n];\n        e.push(this.read(i));\n      }\n\n      return this.geometryFactory.createGeometryCollection(e);\n    }\n  },\n      xe = {\n    coordinate: function (t) {\n      return [t.x, t.y];\n    },\n    Point: function (t) {\n      return {\n        type: \"Point\",\n        coordinates: xe.coordinate.apply(this, [t.getCoordinate()])\n      };\n    },\n    MultiPoint: function (t) {\n      for (var e = [], n = 0; n < t._geometries.length; ++n) {\n        var i = t._geometries[n],\n            r = xe.Point.apply(this, [i]);\n        e.push(r.coordinates);\n      }\n\n      return {\n        type: \"MultiPoint\",\n        coordinates: e\n      };\n    },\n    LineString: function (t) {\n      for (var e = [], n = t.getCoordinates(), i = 0; i < n.length; ++i) {\n        var r = n[i];\n        e.push(xe.coordinate.apply(this, [r]));\n      }\n\n      return {\n        type: \"LineString\",\n        coordinates: e\n      };\n    },\n    MultiLineString: function (t) {\n      for (var e = [], n = 0; n < t._geometries.length; ++n) {\n        var i = t._geometries[n],\n            r = xe.LineString.apply(this, [i]);\n        e.push(r.coordinates);\n      }\n\n      return {\n        type: \"MultiLineString\",\n        coordinates: e\n      };\n    },\n    Polygon: function (t) {\n      var e = [],\n          n = xe.LineString.apply(this, [t._shell]);\n      e.push(n.coordinates);\n\n      for (var i = 0; i < t._holes.length; ++i) {\n        var r = t._holes[i],\n            o = xe.LineString.apply(this, [r]);\n        e.push(o.coordinates);\n      }\n\n      return {\n        type: \"Polygon\",\n        coordinates: e\n      };\n    },\n    MultiPolygon: function (t) {\n      for (var e = [], n = 0; n < t._geometries.length; ++n) {\n        var i = t._geometries[n],\n            r = xe.Polygon.apply(this, [i]);\n        e.push(r.coordinates);\n      }\n\n      return {\n        type: \"MultiPolygon\",\n        coordinates: e\n      };\n    },\n    GeometryCollection: function (t) {\n      for (var e = [], n = 0; n < t._geometries.length; ++n) {\n        var i = t._geometries[n],\n            r = i.getGeometryType();\n        e.push(xe[r].apply(this, [i]));\n      }\n\n      return {\n        type: \"GeometryCollection\",\n        geometries: e\n      };\n    }\n  },\n      Ne = function (t) {\n    this.geometryFactory = t || new _e(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new Ie(this.geometryFactory);\n  };\n\n  Ne.prototype.read = function (t) {\n    var e = this.parser.read(t);\n    return this.precisionModel.getType() === fe.FIXED && this.reducePrecision(e), e;\n  }, Ne.prototype.reducePrecision = function (t) {\n    var e, n;\n    if (t.coordinate) this.precisionModel.makePrecise(t.coordinate);else if (t.points) for (e = 0, n = t.points.length; e < n; e++) this.precisionModel.makePrecise(t.points[e]);else if (t.geometries) for (e = 0, n = t.geometries.length; e < n; e++) this.reducePrecision(t.geometries[e]);\n  };\n\n  var Ce = function () {\n    this.parser = new Ie(this.geometryFactory);\n  };\n\n  Ce.prototype.write = function (t) {\n    return this.parser.write(t);\n  };\n\n  var Se = function () {},\n      Le = {\n    ON: {\n      configurable: !0\n    },\n    LEFT: {\n      configurable: !0\n    },\n    RIGHT: {\n      configurable: !0\n    }\n  };\n\n  Se.prototype.interfaces_ = function () {\n    return [];\n  }, Se.prototype.getClass = function () {\n    return Se;\n  }, Se.opposite = function (t) {\n    return t === Se.LEFT ? Se.RIGHT : t === Se.RIGHT ? Se.LEFT : t;\n  }, Le.ON.get = function () {\n    return 0;\n  }, Le.LEFT.get = function () {\n    return 1;\n  }, Le.RIGHT.get = function () {\n    return 2;\n  }, Object.defineProperties(Se, Le), (d.prototype = new Error()).name = \"EmptyStackException\", (y.prototype = new xt()).add = function (t) {\n    return this.array_.push(t), !0;\n  }, y.prototype.get = function (t) {\n    if (t < 0 || t >= this.size()) throw new Error();\n    return this.array_[t];\n  }, y.prototype.push = function (t) {\n    return this.array_.push(t), t;\n  }, y.prototype.pop = function (t) {\n    if (0 === this.array_.length) throw new d();\n    return this.array_.pop();\n  }, y.prototype.peek = function () {\n    if (0 === this.array_.length) throw new d();\n    return this.array_[this.array_.length - 1];\n  }, y.prototype.empty = function () {\n    return 0 === this.array_.length;\n  }, y.prototype.isEmpty = function () {\n    return this.empty();\n  }, y.prototype.search = function (t) {\n    return this.array_.indexOf(t);\n  }, y.prototype.size = function () {\n    return this.array_.length;\n  }, y.prototype.toArray = function () {\n    for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);\n\n    return t;\n  };\n\n  var be = function () {\n    this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;\n  };\n\n  be.prototype.getCoordinate = function () {\n    return this._minCoord;\n  }, be.prototype.getRightmostSide = function (t, e) {\n    var n = this.getRightmostSideOfSegment(t, e);\n    return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)), n < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t)), n;\n  }, be.prototype.findRightmostEdgeAtVertex = function () {\n    var t = this._minDe.getEdge().getCoordinates();\n\n    et.isTrue(this._minIndex > 0 && this._minIndex < t.length, \"rightmost point expected to be interior vertex of edge\");\n    var e = t[this._minIndex - 1],\n        n = t[this._minIndex + 1],\n        i = at.computeOrientation(this._minCoord, n, e),\n        r = !1;\n    e.y < this._minCoord.y && n.y < this._minCoord.y && i === at.COUNTERCLOCKWISE ? r = !0 : e.y > this._minCoord.y && n.y > this._minCoord.y && i === at.CLOCKWISE && (r = !0), r && (this._minIndex = this._minIndex - 1);\n  }, be.prototype.getRightmostSideOfSegment = function (t, e) {\n    var n = t.getEdge().getCoordinates();\n    if (e < 0 || e + 1 >= n.length) return -1;\n    if (n[e].y === n[e + 1].y) return -1;\n    var i = Se.LEFT;\n    return n[e].y < n[e + 1].y && (i = Se.RIGHT), i;\n  }, be.prototype.getEdge = function () {\n    return this._orientedDe;\n  }, be.prototype.checkForRightmostCoordinate = function (t) {\n    for (var e = t.getEdge().getCoordinates(), n = 0; n < e.length - 1; n++) (null === this._minCoord || e[n].x > this._minCoord.x) && (this._minDe = t, this._minIndex = n, this._minCoord = e[n]);\n  }, be.prototype.findRightmostEdgeAtNode = function () {\n    var t = this._minDe.getNode().getEdges();\n\n    this._minDe = t.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);\n  }, be.prototype.findEdge = function (t) {\n    for (var e = t.iterator(); e.hasNext();) {\n      var n = e.next();\n      n.isForward() && this.checkForRightmostCoordinate(n);\n    }\n\n    et.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), \"inconsistency in rightmost processing\"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe;\n    this.getRightmostSide(this._minDe, this._minIndex) === Se.LEFT && (this._orientedDe = this._minDe.getSym());\n  }, be.prototype.interfaces_ = function () {\n    return [];\n  }, be.prototype.getClass = function () {\n    return be;\n  };\n\n  var we = function (t) {\n    function e(n, i) {\n      t.call(this, e.msgWithCoord(n, i)), this.pt = i ? new C(i) : null, this.name = \"TopologyException\";\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getCoordinate = function () {\n      return this.pt;\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e.msgWithCoord = function (t, e) {\n      return e ? t : t + \" [ \" + e + \" ]\";\n    }, e;\n  }($),\n      Oe = function () {\n    this.array_ = [];\n  };\n\n  Oe.prototype.addLast = function (t) {\n    this.array_.push(t);\n  }, Oe.prototype.removeFirst = function () {\n    return this.array_.shift();\n  }, Oe.prototype.isEmpty = function () {\n    return 0 === this.array_.length;\n  };\n\n  var Te = function () {\n    this._finder = null, this._dirEdgeList = new Nt(), this._nodes = new Nt(), this._rightMostCoord = null, this._env = null, this._finder = new be();\n  };\n\n  Te.prototype.clearVisitedEdges = function () {\n    for (var t = this._dirEdgeList.iterator(); t.hasNext();) {\n      t.next().setVisited(!1);\n    }\n  }, Te.prototype.getRightmostCoordinate = function () {\n    return this._rightMostCoord;\n  }, Te.prototype.computeNodeDepth = function (t) {\n    for (var e = null, n = t.getEdges().iterator(); n.hasNext();) {\n      var i = n.next();\n\n      if (i.isVisited() || i.getSym().isVisited()) {\n        e = i;\n        break;\n      }\n    }\n\n    if (null === e) throw new we(\"unable to find edge to compute depths at \" + t.getCoordinate());\n    t.getEdges().computeDepths(e);\n\n    for (var r = t.getEdges().iterator(); r.hasNext();) {\n      var o = r.next();\n      o.setVisited(!0), this.copySymDepths(o);\n    }\n  }, Te.prototype.computeDepth = function (t) {\n    this.clearVisitedEdges();\n\n    var e = this._finder.getEdge();\n\n    e.setEdgeDepths(Se.RIGHT, t), this.copySymDepths(e), this.computeDepths(e);\n  }, Te.prototype.create = function (t) {\n    this.addReachable(t), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();\n  }, Te.prototype.findResultEdges = function () {\n    for (var t = this._dirEdgeList.iterator(); t.hasNext();) {\n      var e = t.next();\n      e.getDepth(Se.RIGHT) >= 1 && e.getDepth(Se.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0);\n    }\n  }, Te.prototype.computeDepths = function (t) {\n    var e = new Pt(),\n        n = new Oe(),\n        i = t.getNode();\n\n    for (n.addLast(i), e.add(i), t.setVisited(!0); !n.isEmpty();) {\n      var r = n.removeFirst();\n      e.add(r), this.computeNodeDepth(r);\n\n      for (var o = r.getEdges().iterator(); o.hasNext();) {\n        var s = o.next().getSym();\n\n        if (!s.isVisited()) {\n          var a = s.getNode();\n          e.contains(a) || (n.addLast(a), e.add(a));\n        }\n      }\n    }\n  }, Te.prototype.compareTo = function (t) {\n    var e = t;\n    return this._rightMostCoord.x < e._rightMostCoord.x ? -1 : this._rightMostCoord.x > e._rightMostCoord.x ? 1 : 0;\n  }, Te.prototype.getEnvelope = function () {\n    if (null === this._env) {\n      for (var t = new j(), e = this._dirEdgeList.iterator(); e.hasNext();) for (var n = e.next().getEdge().getCoordinates(), i = 0; i < n.length - 1; i++) t.expandToInclude(n[i]);\n\n      this._env = t;\n    }\n\n    return this._env;\n  }, Te.prototype.addReachable = function (t) {\n    var e = new y();\n\n    for (e.add(t); !e.empty();) {\n      var n = e.pop();\n      this.add(n, e);\n    }\n  }, Te.prototype.copySymDepths = function (t) {\n    var e = t.getSym();\n    e.setDepth(Se.LEFT, t.getDepth(Se.RIGHT)), e.setDepth(Se.RIGHT, t.getDepth(Se.LEFT));\n  }, Te.prototype.add = function (t, e) {\n    t.setVisited(!0), this._nodes.add(t);\n\n    for (var n = t.getEdges().iterator(); n.hasNext();) {\n      var i = n.next();\n\n      this._dirEdgeList.add(i);\n\n      var r = i.getSym().getNode();\n      r.isVisited() || e.push(r);\n    }\n  }, Te.prototype.getNodes = function () {\n    return this._nodes;\n  }, Te.prototype.getDirectedEdges = function () {\n    return this._dirEdgeList;\n  }, Te.prototype.interfaces_ = function () {\n    return [E];\n  }, Te.prototype.getClass = function () {\n    return Te;\n  };\n\n  var Re = function t() {\n    if (this.location = null, 1 === arguments.length) {\n      if (arguments[0] instanceof Array) {\n        var e = arguments[0];\n        this.init(e.length);\n      } else if (Number.isInteger(arguments[0])) {\n        var n = arguments[0];\n        this.init(1), this.location[Se.ON] = n;\n      } else if (arguments[0] instanceof t) {\n        var i = arguments[0];\n        if (this.init(i.location.length), null !== i) for (var r = 0; r < this.location.length; r++) this.location[r] = i.location[r];\n      }\n    } else if (3 === arguments.length) {\n      var o = arguments[0],\n          s = arguments[1],\n          a = arguments[2];\n      this.init(3), this.location[Se.ON] = o, this.location[Se.LEFT] = s, this.location[Se.RIGHT] = a;\n    }\n  };\n\n  Re.prototype.setAllLocations = function (t) {\n    for (var e = 0; e < this.location.length; e++) this.location[e] = t;\n  }, Re.prototype.isNull = function () {\n    for (var t = 0; t < this.location.length; t++) if (this.location[t] !== w.NONE) return !1;\n\n    return !0;\n  }, Re.prototype.setAllLocationsIfNull = function (t) {\n    for (var e = 0; e < this.location.length; e++) this.location[e] === w.NONE && (this.location[e] = t);\n  }, Re.prototype.isLine = function () {\n    return 1 === this.location.length;\n  }, Re.prototype.merge = function (t) {\n    if (t.location.length > this.location.length) {\n      var e = new Array(3).fill(null);\n      e[Se.ON] = this.location[Se.ON], e[Se.LEFT] = w.NONE, e[Se.RIGHT] = w.NONE, this.location = e;\n    }\n\n    for (var n = 0; n < this.location.length; n++) this.location[n] === w.NONE && n < t.location.length && (this.location[n] = t.location[n]);\n  }, Re.prototype.getLocations = function () {\n    return this.location;\n  }, Re.prototype.flip = function () {\n    if (this.location.length <= 1) return null;\n    var t = this.location[Se.LEFT];\n    this.location[Se.LEFT] = this.location[Se.RIGHT], this.location[Se.RIGHT] = t;\n  }, Re.prototype.toString = function () {\n    var t = new D();\n    return this.location.length > 1 && t.append(w.toLocationSymbol(this.location[Se.LEFT])), t.append(w.toLocationSymbol(this.location[Se.ON])), this.location.length > 1 && t.append(w.toLocationSymbol(this.location[Se.RIGHT])), t.toString();\n  }, Re.prototype.setLocations = function (t, e, n) {\n    this.location[Se.ON] = t, this.location[Se.LEFT] = e, this.location[Se.RIGHT] = n;\n  }, Re.prototype.get = function (t) {\n    return t < this.location.length ? this.location[t] : w.NONE;\n  }, Re.prototype.isArea = function () {\n    return this.location.length > 1;\n  }, Re.prototype.isAnyNull = function () {\n    for (var t = 0; t < this.location.length; t++) if (this.location[t] === w.NONE) return !0;\n\n    return !1;\n  }, Re.prototype.setLocation = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setLocation(Se.ON, t);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.location[e] = n;\n    }\n  }, Re.prototype.init = function (t) {\n    this.location = new Array(t).fill(null), this.setAllLocations(w.NONE);\n  }, Re.prototype.isEqualOnSide = function (t, e) {\n    return this.location[e] === t.location[e];\n  }, Re.prototype.allPositionsEqual = function (t) {\n    for (var e = 0; e < this.location.length; e++) if (this.location[e] !== t) return !1;\n\n    return !0;\n  }, Re.prototype.interfaces_ = function () {\n    return [];\n  }, Re.prototype.getClass = function () {\n    return Re;\n  };\n\n  var Pe = function t() {\n    if (this.elt = new Array(2).fill(null), 1 === arguments.length) {\n      if (Number.isInteger(arguments[0])) {\n        var e = arguments[0];\n        this.elt[0] = new Re(e), this.elt[1] = new Re(e);\n      } else if (arguments[0] instanceof t) {\n        var n = arguments[0];\n        this.elt[0] = new Re(n.elt[0]), this.elt[1] = new Re(n.elt[1]);\n      }\n    } else if (2 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1];\n      this.elt[0] = new Re(w.NONE), this.elt[1] = new Re(w.NONE), this.elt[i].setLocation(r);\n    } else if (3 === arguments.length) {\n      var o = arguments[0],\n          s = arguments[1],\n          a = arguments[2];\n      this.elt[0] = new Re(o, s, a), this.elt[1] = new Re(o, s, a);\n    } else if (4 === arguments.length) {\n      var u = arguments[0],\n          l = arguments[1],\n          c = arguments[2],\n          p = arguments[3];\n      this.elt[0] = new Re(w.NONE, w.NONE, w.NONE), this.elt[1] = new Re(w.NONE, w.NONE, w.NONE), this.elt[u].setLocations(l, c, p);\n    }\n  };\n\n  Pe.prototype.getGeometryCount = function () {\n    var t = 0;\n    return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t;\n  }, Pe.prototype.setAllLocations = function (t, e) {\n    this.elt[t].setAllLocations(e);\n  }, Pe.prototype.isNull = function (t) {\n    return this.elt[t].isNull();\n  }, Pe.prototype.setAllLocationsIfNull = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.elt[e].setAllLocationsIfNull(n);\n    }\n  }, Pe.prototype.isLine = function (t) {\n    return this.elt[t].isLine();\n  }, Pe.prototype.merge = function (t) {\n    for (var e = 0; e < 2; e++) null === this.elt[e] && null !== t.elt[e] ? this.elt[e] = new Re(t.elt[e]) : this.elt[e].merge(t.elt[e]);\n  }, Pe.prototype.flip = function () {\n    this.elt[0].flip(), this.elt[1].flip();\n  }, Pe.prototype.getLocation = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return this.elt[t].get(Se.ON);\n    }\n\n    if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      return this.elt[e].get(n);\n    }\n  }, Pe.prototype.toString = function () {\n    var t = new D();\n    return null !== this.elt[0] && (t.append(\"A:\"), t.append(this.elt[0].toString())), null !== this.elt[1] && (t.append(\" B:\"), t.append(this.elt[1].toString())), t.toString();\n  }, Pe.prototype.isArea = function () {\n    if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea();\n\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return this.elt[t].isArea();\n    }\n  }, Pe.prototype.isAnyNull = function (t) {\n    return this.elt[t].isAnyNull();\n  }, Pe.prototype.setLocation = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      this.elt[t].setLocation(Se.ON, e);\n    } else if (3 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2];\n      this.elt[n].setLocation(i, r);\n    }\n  }, Pe.prototype.isEqualOnSide = function (t, e) {\n    return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e);\n  }, Pe.prototype.allPositionsEqual = function (t, e) {\n    return this.elt[t].allPositionsEqual(e);\n  }, Pe.prototype.toLine = function (t) {\n    this.elt[t].isArea() && (this.elt[t] = new Re(this.elt[t].location[0]));\n  }, Pe.prototype.interfaces_ = function () {\n    return [];\n  }, Pe.prototype.getClass = function () {\n    return Pe;\n  }, Pe.toLineLabel = function (t) {\n    for (var e = new Pe(w.NONE), n = 0; n < 2; n++) e.setLocation(n, t.getLocation(n));\n\n    return e;\n  };\n\n  var De = function () {\n    this._startDe = null, this._maxNodeDegree = -1, this._edges = new Nt(), this._pts = new Nt(), this._label = new Pe(w.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new Nt(), this._geometryFactory = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this._geometryFactory = e, this.computePoints(t), this.computeRing();\n  };\n\n  De.prototype.computeRing = function () {\n    if (null !== this._ring) return null;\n\n    for (var t = new Array(this._pts.size()).fill(null), e = 0; e < this._pts.size(); e++) t[e] = this._pts.get(e);\n\n    this._ring = this._geometryFactory.createLinearRing(t), this._isHole = at.isCCW(this._ring.getCoordinates());\n  }, De.prototype.isIsolated = function () {\n    return 1 === this._label.getGeometryCount();\n  }, De.prototype.computePoints = function (t) {\n    this._startDe = t;\n    var e = t,\n        n = !0;\n\n    do {\n      if (null === e) throw new we(\"Found null DirectedEdge\");\n      if (e.getEdgeRing() === this) throw new we(\"Directed Edge visited twice during ring-building at \" + e.getCoordinate());\n\n      this._edges.add(e);\n\n      var i = e.getLabel();\n      et.isTrue(i.isArea()), this.mergeLabel(i), this.addPoints(e.getEdge(), e.isForward(), n), n = !1, this.setEdgeRing(e, this), e = this.getNext(e);\n    } while (e !== this._startDe);\n  }, De.prototype.getLinearRing = function () {\n    return this._ring;\n  }, De.prototype.getCoordinate = function (t) {\n    return this._pts.get(t);\n  }, De.prototype.computeMaxNodeDegree = function () {\n    this._maxNodeDegree = 0;\n    var t = this._startDe;\n\n    do {\n      var e = t.getNode().getEdges().getOutgoingDegree(this);\n      e > this._maxNodeDegree && (this._maxNodeDegree = e), t = this.getNext(t);\n    } while (t !== this._startDe);\n\n    this._maxNodeDegree *= 2;\n  }, De.prototype.addPoints = function (t, e, n) {\n    var i = t.getCoordinates();\n\n    if (e) {\n      var r = 1;\n      n && (r = 0);\n\n      for (var o = r; o < i.length; o++) this._pts.add(i[o]);\n    } else {\n      var s = i.length - 2;\n      n && (s = i.length - 1);\n\n      for (var a = s; a >= 0; a--) this._pts.add(i[a]);\n    }\n  }, De.prototype.isHole = function () {\n    return this._isHole;\n  }, De.prototype.setInResult = function () {\n    var t = this._startDe;\n\n    do {\n      t.getEdge().setInResult(!0), t = t.getNext();\n    } while (t !== this._startDe);\n  }, De.prototype.containsPoint = function (t) {\n    var e = this.getLinearRing();\n    if (!e.getEnvelopeInternal().contains(t)) return !1;\n    if (!at.isPointInRing(t, e.getCoordinates())) return !1;\n\n    for (var n = this._holes.iterator(); n.hasNext();) {\n      if (n.next().containsPoint(t)) return !1;\n    }\n\n    return !0;\n  }, De.prototype.addHole = function (t) {\n    this._holes.add(t);\n  }, De.prototype.isShell = function () {\n    return null === this._shell;\n  }, De.prototype.getLabel = function () {\n    return this._label;\n  }, De.prototype.getEdges = function () {\n    return this._edges;\n  }, De.prototype.getMaxNodeDegree = function () {\n    return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;\n  }, De.prototype.getShell = function () {\n    return this._shell;\n  }, De.prototype.mergeLabel = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.mergeLabel(t, 0), this.mergeLabel(t, 1);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1],\n          i = e.getLocation(n, Se.RIGHT);\n      if (i === w.NONE) return null;\n      if (this._label.getLocation(n) === w.NONE) return this._label.setLocation(n, i), null;\n    }\n  }, De.prototype.setShell = function (t) {\n    this._shell = t, null !== t && t.addHole(this);\n  }, De.prototype.toPolygon = function (t) {\n    for (var e = new Array(this._holes.size()).fill(null), n = 0; n < this._holes.size(); n++) e[n] = this._holes.get(n).getLinearRing();\n\n    return t.createPolygon(this.getLinearRing(), e);\n  }, De.prototype.interfaces_ = function () {\n    return [];\n  }, De.prototype.getClass = function () {\n    return De;\n  };\n\n  var Me = function (t) {\n    function e() {\n      var e = arguments[0],\n          n = arguments[1];\n      t.call(this, e, n);\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.setEdgeRing = function (t, e) {\n      t.setMinEdgeRing(e);\n    }, e.prototype.getNext = function (t) {\n      return t.getNextMin();\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e;\n  }(De),\n      Ae = function (t) {\n    function e() {\n      var e = arguments[0],\n          n = arguments[1];\n      t.call(this, e, n);\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.buildMinimalRings = function () {\n      var t = new Nt(),\n          e = this._startDe;\n\n      do {\n        if (null === e.getMinEdgeRing()) {\n          var n = new Me(e, this._geometryFactory);\n          t.add(n);\n        }\n\n        e = e.getNext();\n      } while (e !== this._startDe);\n\n      return t;\n    }, e.prototype.setEdgeRing = function (t, e) {\n      t.setEdgeRing(e);\n    }, e.prototype.linkDirectedEdgesForMinimalEdgeRings = function () {\n      var t = this._startDe;\n\n      do {\n        t.getNode().getEdges().linkMinimalDirectedEdges(this), t = t.getNext();\n      } while (t !== this._startDe);\n    }, e.prototype.getNext = function (t) {\n      return t.getNext();\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e;\n  }(De),\n      Fe = function () {\n    if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 === arguments.length) ;else if (1 === arguments.length) {\n      var t = arguments[0];\n      this._label = t;\n    }\n  };\n\n  Fe.prototype.setVisited = function (t) {\n    this._isVisited = t;\n  }, Fe.prototype.setInResult = function (t) {\n    this._isInResult = t;\n  }, Fe.prototype.isCovered = function () {\n    return this._isCovered;\n  }, Fe.prototype.isCoveredSet = function () {\n    return this._isCoveredSet;\n  }, Fe.prototype.setLabel = function (t) {\n    this._label = t;\n  }, Fe.prototype.getLabel = function () {\n    return this._label;\n  }, Fe.prototype.setCovered = function (t) {\n    this._isCovered = t, this._isCoveredSet = !0;\n  }, Fe.prototype.updateIM = function (t) {\n    et.isTrue(this._label.getGeometryCount() >= 2, \"found partial label\"), this.computeIM(t);\n  }, Fe.prototype.isInResult = function () {\n    return this._isInResult;\n  }, Fe.prototype.isVisited = function () {\n    return this._isVisited;\n  }, Fe.prototype.interfaces_ = function () {\n    return [];\n  }, Fe.prototype.getClass = function () {\n    return Fe;\n  };\n\n  var Ge = function (t) {\n    function e() {\n      t.call(this), this._coord = null, this._edges = null;\n      var e = arguments[0],\n          n = arguments[1];\n      this._coord = e, this._edges = n, this._label = new Pe(0, w.NONE);\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isIncidentEdgeInResult = function () {\n      for (var t = this.getEdges().getEdges().iterator(); t.hasNext();) {\n        if (t.next().getEdge().isInResult()) return !0;\n      }\n\n      return !1;\n    }, e.prototype.isIsolated = function () {\n      return 1 === this._label.getGeometryCount();\n    }, e.prototype.getCoordinate = function () {\n      return this._coord;\n    }, e.prototype.print = function (t) {\n      t.println(\"node \" + this._coord + \" lbl: \" + this._label);\n    }, e.prototype.computeIM = function (t) {}, e.prototype.computeMergedLocation = function (t, e) {\n      var n = w.NONE;\n\n      if (n = this._label.getLocation(e), !t.isNull(e)) {\n        var i = t.getLocation(e);\n        n !== w.BOUNDARY && (n = i);\n      }\n\n      return n;\n    }, e.prototype.setLabel = function () {\n      if (2 !== arguments.length) return t.prototype.setLabel.apply(this, arguments);\n      var e = arguments[0],\n          n = arguments[1];\n      null === this._label ? this._label = new Pe(e, n) : this._label.setLocation(e, n);\n    }, e.prototype.getEdges = function () {\n      return this._edges;\n    }, e.prototype.mergeLabel = function () {\n      if (arguments[0] instanceof e) {\n        var t = arguments[0];\n        this.mergeLabel(t._label);\n      } else if (arguments[0] instanceof Pe) for (var n = arguments[0], i = 0; i < 2; i++) {\n        var r = this.computeMergedLocation(n, i);\n        this._label.getLocation(i) === w.NONE && this._label.setLocation(i, r);\n      }\n    }, e.prototype.add = function (t) {\n      this._edges.insert(t), t.setNode(this);\n    }, e.prototype.setLabelBoundary = function (t) {\n      if (null === this._label) return null;\n      var e = w.NONE;\n      null !== this._label && (e = this._label.getLocation(t));\n      var n = null;\n\n      switch (e) {\n        case w.BOUNDARY:\n          n = w.INTERIOR;\n          break;\n\n        case w.INTERIOR:\n        default:\n          n = w.BOUNDARY;\n      }\n\n      this._label.setLocation(t, n);\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e;\n  }(Fe),\n      qe = function () {\n    this.nodeMap = new p(), this.nodeFact = null;\n    var t = arguments[0];\n    this.nodeFact = t;\n  };\n\n  qe.prototype.find = function (t) {\n    return this.nodeMap.get(t);\n  }, qe.prototype.addNode = function () {\n    if (arguments[0] instanceof C) {\n      var t = arguments[0],\n          e = this.nodeMap.get(t);\n      return null === e && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e;\n    }\n\n    if (arguments[0] instanceof Ge) {\n      var n = arguments[0],\n          i = this.nodeMap.get(n.getCoordinate());\n      return null === i ? (this.nodeMap.put(n.getCoordinate(), n), n) : (i.mergeLabel(n), i);\n    }\n  }, qe.prototype.print = function (t) {\n    for (var e = this.iterator(); e.hasNext();) {\n      e.next().print(t);\n    }\n  }, qe.prototype.iterator = function () {\n    return this.nodeMap.values().iterator();\n  }, qe.prototype.values = function () {\n    return this.nodeMap.values();\n  }, qe.prototype.getBoundaryNodes = function (t) {\n    for (var e = new Nt(), n = this.iterator(); n.hasNext();) {\n      var i = n.next();\n      i.getLabel().getLocation(t) === w.BOUNDARY && e.add(i);\n    }\n\n    return e;\n  }, qe.prototype.add = function (t) {\n    var e = t.getCoordinate();\n    this.addNode(e).add(t);\n  }, qe.prototype.interfaces_ = function () {\n    return [];\n  }, qe.prototype.getClass = function () {\n    return qe;\n  };\n\n  var Be = function () {},\n      Ve = {\n    NE: {\n      configurable: !0\n    },\n    NW: {\n      configurable: !0\n    },\n    SW: {\n      configurable: !0\n    },\n    SE: {\n      configurable: !0\n    }\n  };\n\n  Be.prototype.interfaces_ = function () {\n    return [];\n  }, Be.prototype.getClass = function () {\n    return Be;\n  }, Be.isNorthern = function (t) {\n    return t === Be.NE || t === Be.NW;\n  }, Be.isOpposite = function (t, e) {\n    if (t === e) return !1;\n    return 2 === (t - e + 4) % 4;\n  }, Be.commonHalfPlane = function (t, e) {\n    if (t === e) return t;\n    if (2 === (t - e + 4) % 4) return -1;\n    var n = t < e ? t : e;\n    return 0 === n && 3 === (t > e ? t : e) ? 3 : n;\n  }, Be.isInHalfPlane = function (t, e) {\n    return e === Be.SE ? t === Be.SE || t === Be.SW : t === e || t === e + 1;\n  }, Be.quadrant = function () {\n    if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n      var t = arguments[0],\n          e = arguments[1];\n      if (0 === t && 0 === e) throw new m(\"Cannot compute the quadrant for point ( \" + t + \", \" + e + \" )\");\n      return t >= 0 ? e >= 0 ? Be.NE : Be.SE : e >= 0 ? Be.NW : Be.SW;\n    }\n\n    if (arguments[0] instanceof C && arguments[1] instanceof C) {\n      var n = arguments[0],\n          i = arguments[1];\n      if (i.x === n.x && i.y === n.y) throw new m(\"Cannot compute the quadrant for two identical points \" + n);\n      return i.x >= n.x ? i.y >= n.y ? Be.NE : Be.SE : i.y >= n.y ? Be.NW : Be.SW;\n    }\n  }, Ve.NE.get = function () {\n    return 0;\n  }, Ve.NW.get = function () {\n    return 1;\n  }, Ve.SW.get = function () {\n    return 2;\n  }, Ve.SE.get = function () {\n    return 3;\n  }, Object.defineProperties(Be, Ve);\n\n  var Ue = function () {\n    if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) {\n      var t = arguments[0];\n      this._edge = t;\n    } else if (3 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1],\n          i = arguments[2];\n      this._edge = e, this.init(n, i), this._label = null;\n    } else if (4 === arguments.length) {\n      var r = arguments[0],\n          o = arguments[1],\n          s = arguments[2],\n          a = arguments[3];\n      this._edge = r, this.init(o, s), this._label = a;\n    }\n  };\n\n  Ue.prototype.compareDirection = function (t) {\n    return this._dx === t._dx && this._dy === t._dy ? 0 : this._quadrant > t._quadrant ? 1 : this._quadrant < t._quadrant ? -1 : at.computeOrientation(t._p0, t._p1, this._p1);\n  }, Ue.prototype.getDy = function () {\n    return this._dy;\n  }, Ue.prototype.getCoordinate = function () {\n    return this._p0;\n  }, Ue.prototype.setNode = function (t) {\n    this._node = t;\n  }, Ue.prototype.print = function (t) {\n    var e = Math.atan2(this._dy, this._dx),\n        n = this.getClass().getName(),\n        i = n.lastIndexOf(\".\"),\n        r = n.substring(i + 1);\n    t.print(\"  \" + r + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + e + \"   \" + this._label);\n  }, Ue.prototype.compareTo = function (t) {\n    var e = t;\n    return this.compareDirection(e);\n  }, Ue.prototype.getDirectedCoordinate = function () {\n    return this._p1;\n  }, Ue.prototype.getDx = function () {\n    return this._dx;\n  }, Ue.prototype.getLabel = function () {\n    return this._label;\n  }, Ue.prototype.getEdge = function () {\n    return this._edge;\n  }, Ue.prototype.getQuadrant = function () {\n    return this._quadrant;\n  }, Ue.prototype.getNode = function () {\n    return this._node;\n  }, Ue.prototype.toString = function () {\n    var t = Math.atan2(this._dy, this._dx),\n        e = this.getClass().getName(),\n        n = e.lastIndexOf(\".\");\n    return \"  \" + e.substring(n + 1) + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + t + \"   \" + this._label;\n  }, Ue.prototype.computeLabel = function (t) {}, Ue.prototype.init = function (t, e) {\n    this._p0 = t, this._p1 = e, this._dx = e.x - t.x, this._dy = e.y - t.y, this._quadrant = Be.quadrant(this._dx, this._dy), et.isTrue(!(0 === this._dx && 0 === this._dy), \"EdgeEnd with identical endpoints found\");\n  }, Ue.prototype.interfaces_ = function () {\n    return [E];\n  }, Ue.prototype.getClass = function () {\n    return Ue;\n  };\n\n  var ze = function (t) {\n    function e() {\n      var e = arguments[0],\n          n = arguments[1];\n      if (t.call(this, e), this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999], this._isForward = n, n) this.init(e.getCoordinate(0), e.getCoordinate(1));else {\n        var i = e.getNumPoints() - 1;\n        this.init(e.getCoordinate(i), e.getCoordinate(i - 1));\n      }\n      this.computeDirectedLabel();\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getNextMin = function () {\n      return this._nextMin;\n    }, e.prototype.getDepth = function (t) {\n      return this._depth[t];\n    }, e.prototype.setVisited = function (t) {\n      this._isVisited = t;\n    }, e.prototype.computeDirectedLabel = function () {\n      this._label = new Pe(this._edge.getLabel()), this._isForward || this._label.flip();\n    }, e.prototype.getNext = function () {\n      return this._next;\n    }, e.prototype.setDepth = function (t, e) {\n      if (-999 !== this._depth[t] && this._depth[t] !== e) throw new we(\"assigned depths do not match\", this.getCoordinate());\n      this._depth[t] = e;\n    }, e.prototype.isInteriorAreaEdge = function () {\n      for (var t = !0, e = 0; e < 2; e++) this._label.isArea(e) && this._label.getLocation(e, Se.LEFT) === w.INTERIOR && this._label.getLocation(e, Se.RIGHT) === w.INTERIOR || (t = !1);\n\n      return t;\n    }, e.prototype.setNextMin = function (t) {\n      this._nextMin = t;\n    }, e.prototype.print = function (e) {\n      t.prototype.print.call(this, e), e.print(\" \" + this._depth[Se.LEFT] + \"/\" + this._depth[Se.RIGHT]), e.print(\" (\" + this.getDepthDelta() + \")\"), this._isInResult && e.print(\" inResult\");\n    }, e.prototype.setMinEdgeRing = function (t) {\n      this._minEdgeRing = t;\n    }, e.prototype.isLineEdge = function () {\n      var t = this._label.isLine(0) || this._label.isLine(1),\n          e = !this._label.isArea(0) || this._label.allPositionsEqual(0, w.EXTERIOR),\n          n = !this._label.isArea(1) || this._label.allPositionsEqual(1, w.EXTERIOR);\n\n      return t && e && n;\n    }, e.prototype.setEdgeRing = function (t) {\n      this._edgeRing = t;\n    }, e.prototype.getMinEdgeRing = function () {\n      return this._minEdgeRing;\n    }, e.prototype.getDepthDelta = function () {\n      var t = this._edge.getDepthDelta();\n\n      return this._isForward || (t = -t), t;\n    }, e.prototype.setInResult = function (t) {\n      this._isInResult = t;\n    }, e.prototype.getSym = function () {\n      return this._sym;\n    }, e.prototype.isForward = function () {\n      return this._isForward;\n    }, e.prototype.getEdge = function () {\n      return this._edge;\n    }, e.prototype.printEdge = function (t) {\n      this.print(t), t.print(\" \"), this._isForward ? this._edge.print(t) : this._edge.printReverse(t);\n    }, e.prototype.setSym = function (t) {\n      this._sym = t;\n    }, e.prototype.setVisitedEdge = function (t) {\n      this.setVisited(t), this._sym.setVisited(t);\n    }, e.prototype.setEdgeDepths = function (t, e) {\n      var n = this.getEdge().getDepthDelta();\n      this._isForward || (n = -n);\n      var i = 1;\n      t === Se.LEFT && (i = -1);\n      var r = Se.opposite(t),\n          o = e + n * i;\n      this.setDepth(t, e), this.setDepth(r, o);\n    }, e.prototype.getEdgeRing = function () {\n      return this._edgeRing;\n    }, e.prototype.isInResult = function () {\n      return this._isInResult;\n    }, e.prototype.setNext = function (t) {\n      this._next = t;\n    }, e.prototype.isVisited = function () {\n      return this._isVisited;\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e.depthFactor = function (t, e) {\n      return t === w.EXTERIOR && e === w.INTERIOR ? 1 : t === w.INTERIOR && e === w.EXTERIOR ? -1 : 0;\n    }, e;\n  }(Ue),\n      Xe = function () {};\n\n  Xe.prototype.createNode = function (t) {\n    return new Ge(t, null);\n  }, Xe.prototype.interfaces_ = function () {\n    return [];\n  }, Xe.prototype.getClass = function () {\n    return Xe;\n  };\n\n  var Ye = function () {\n    if (this._edges = new Nt(), this._nodes = null, this._edgeEndList = new Nt(), 0 === arguments.length) this._nodes = new qe(new Xe());else if (1 === arguments.length) {\n      var t = arguments[0];\n      this._nodes = new qe(t);\n    }\n  };\n\n  Ye.prototype.printEdges = function (t) {\n    t.println(\"Edges:\");\n\n    for (var e = 0; e < this._edges.size(); e++) {\n      t.println(\"edge \" + e + \":\");\n\n      var n = this._edges.get(e);\n\n      n.print(t), n.eiList.print(t);\n    }\n  }, Ye.prototype.find = function (t) {\n    return this._nodes.find(t);\n  }, Ye.prototype.addNode = function () {\n    if (arguments[0] instanceof Ge) {\n      var t = arguments[0];\n      return this._nodes.addNode(t);\n    }\n\n    if (arguments[0] instanceof C) {\n      var e = arguments[0];\n      return this._nodes.addNode(e);\n    }\n  }, Ye.prototype.getNodeIterator = function () {\n    return this._nodes.iterator();\n  }, Ye.prototype.linkResultDirectedEdges = function () {\n    for (var t = this._nodes.iterator(); t.hasNext();) {\n      t.next().getEdges().linkResultDirectedEdges();\n    }\n  }, Ye.prototype.debugPrintln = function (t) {\n    Y.out.println(t);\n  }, Ye.prototype.isBoundaryNode = function (t, e) {\n    var n = this._nodes.find(e);\n\n    if (null === n) return !1;\n    var i = n.getLabel();\n    return null !== i && i.getLocation(t) === w.BOUNDARY;\n  }, Ye.prototype.linkAllDirectedEdges = function () {\n    for (var t = this._nodes.iterator(); t.hasNext();) {\n      t.next().getEdges().linkAllDirectedEdges();\n    }\n  }, Ye.prototype.matchInSameDirection = function (t, e, n, i) {\n    return !!t.equals(n) && at.computeOrientation(t, e, i) === at.COLLINEAR && Be.quadrant(t, e) === Be.quadrant(n, i);\n  }, Ye.prototype.getEdgeEnds = function () {\n    return this._edgeEndList;\n  }, Ye.prototype.debugPrint = function (t) {\n    Y.out.print(t);\n  }, Ye.prototype.getEdgeIterator = function () {\n    return this._edges.iterator();\n  }, Ye.prototype.findEdgeInSameDirection = function (t, e) {\n    for (var n = 0; n < this._edges.size(); n++) {\n      var i = this._edges.get(n),\n          r = i.getCoordinates();\n\n      if (this.matchInSameDirection(t, e, r[0], r[1])) return i;\n      if (this.matchInSameDirection(t, e, r[r.length - 1], r[r.length - 2])) return i;\n    }\n\n    return null;\n  }, Ye.prototype.insertEdge = function (t) {\n    this._edges.add(t);\n  }, Ye.prototype.findEdgeEnd = function (t) {\n    for (var e = this.getEdgeEnds().iterator(); e.hasNext();) {\n      var n = e.next();\n      if (n.getEdge() === t) return n;\n    }\n\n    return null;\n  }, Ye.prototype.addEdges = function (t) {\n    for (var e = t.iterator(); e.hasNext();) {\n      var n = e.next();\n\n      this._edges.add(n);\n\n      var i = new ze(n, !0),\n          r = new ze(n, !1);\n      i.setSym(r), r.setSym(i), this.add(i), this.add(r);\n    }\n  }, Ye.prototype.add = function (t) {\n    this._nodes.add(t), this._edgeEndList.add(t);\n  }, Ye.prototype.getNodes = function () {\n    return this._nodes.values();\n  }, Ye.prototype.findEdge = function (t, e) {\n    for (var n = 0; n < this._edges.size(); n++) {\n      var i = this._edges.get(n),\n          r = i.getCoordinates();\n\n      if (t.equals(r[0]) && e.equals(r[1])) return i;\n    }\n\n    return null;\n  }, Ye.prototype.interfaces_ = function () {\n    return [];\n  }, Ye.prototype.getClass = function () {\n    return Ye;\n  }, Ye.linkResultDirectedEdges = function (t) {\n    for (var e = t.iterator(); e.hasNext();) {\n      e.next().getEdges().linkResultDirectedEdges();\n    }\n  };\n\n  var ke = function () {\n    this._geometryFactory = null, this._shellList = new Nt();\n    var t = arguments[0];\n    this._geometryFactory = t;\n  };\n\n  ke.prototype.sortShellsAndHoles = function (t, e, n) {\n    for (var i = t.iterator(); i.hasNext();) {\n      var r = i.next();\n      r.isHole() ? n.add(r) : e.add(r);\n    }\n  }, ke.prototype.computePolygons = function (t) {\n    for (var e = new Nt(), n = t.iterator(); n.hasNext();) {\n      var i = n.next().toPolygon(this._geometryFactory);\n      e.add(i);\n    }\n\n    return e;\n  }, ke.prototype.placeFreeHoles = function (t, e) {\n    for (var n = e.iterator(); n.hasNext();) {\n      var i = n.next();\n\n      if (null === i.getShell()) {\n        var r = this.findEdgeRingContaining(i, t);\n        if (null === r) throw new we(\"unable to assign hole to a shell\", i.getCoordinate(0));\n        i.setShell(r);\n      }\n    }\n  }, ke.prototype.buildMinimalEdgeRings = function (t, e, n) {\n    for (var i = new Nt(), r = t.iterator(); r.hasNext();) {\n      var o = r.next();\n\n      if (o.getMaxNodeDegree() > 2) {\n        o.linkDirectedEdgesForMinimalEdgeRings();\n        var s = o.buildMinimalRings(),\n            a = this.findShell(s);\n        null !== a ? (this.placePolygonHoles(a, s), e.add(a)) : n.addAll(s);\n      } else i.add(o);\n    }\n\n    return i;\n  }, ke.prototype.containsPoint = function (t) {\n    for (var e = this._shellList.iterator(); e.hasNext();) {\n      if (e.next().containsPoint(t)) return !0;\n    }\n\n    return !1;\n  }, ke.prototype.buildMaximalEdgeRings = function (t) {\n    for (var e = new Nt(), n = t.iterator(); n.hasNext();) {\n      var i = n.next();\n\n      if (i.isInResult() && i.getLabel().isArea() && null === i.getEdgeRing()) {\n        var r = new Ae(i, this._geometryFactory);\n        e.add(r), r.setInResult();\n      }\n    }\n\n    return e;\n  }, ke.prototype.placePolygonHoles = function (t, e) {\n    for (var n = e.iterator(); n.hasNext();) {\n      var i = n.next();\n      i.isHole() && i.setShell(t);\n    }\n  }, ke.prototype.getPolygons = function () {\n    return this.computePolygons(this._shellList);\n  }, ke.prototype.findEdgeRingContaining = function (t, e) {\n    for (var n = t.getLinearRing(), i = n.getEnvelopeInternal(), r = n.getCoordinateN(0), o = null, s = null, a = e.iterator(); a.hasNext();) {\n      var u = a.next(),\n          l = u.getLinearRing(),\n          c = l.getEnvelopeInternal();\n      null !== o && (s = o.getLinearRing().getEnvelopeInternal());\n      var p = !1;\n      c.contains(i) && at.isPointInRing(r, l.getCoordinates()) && (p = !0), p && (null === o || s.contains(c)) && (o = u);\n    }\n\n    return o;\n  }, ke.prototype.findShell = function (t) {\n    for (var e = 0, n = null, i = t.iterator(); i.hasNext();) {\n      var r = i.next();\n      r.isHole() || (n = r, e++);\n    }\n\n    return et.isTrue(e <= 1, \"found two shells in MinimalEdgeRing list\"), n;\n  }, ke.prototype.add = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.add(t.getEdgeEnds(), t.getNodes());\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      Ye.linkResultDirectedEdges(n);\n      var i = this.buildMaximalEdgeRings(e),\n          r = new Nt(),\n          o = this.buildMinimalEdgeRings(i, this._shellList, r);\n      this.sortShellsAndHoles(o, this._shellList, r), this.placeFreeHoles(this._shellList, r);\n    }\n  }, ke.prototype.interfaces_ = function () {\n    return [];\n  }, ke.prototype.getClass = function () {\n    return ke;\n  };\n\n  var je = function () {};\n\n  je.prototype.getBounds = function () {}, je.prototype.interfaces_ = function () {\n    return [];\n  }, je.prototype.getClass = function () {\n    return je;\n  };\n\n  var He = function () {\n    this._bounds = null, this._item = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this._bounds = t, this._item = e;\n  };\n\n  He.prototype.getItem = function () {\n    return this._item;\n  }, He.prototype.getBounds = function () {\n    return this._bounds;\n  }, He.prototype.interfaces_ = function () {\n    return [je, e];\n  }, He.prototype.getClass = function () {\n    return He;\n  };\n\n  var We = function () {\n    this._size = null, this._items = null, this._size = 0, this._items = new Nt(), this._items.add(null);\n  };\n\n  We.prototype.poll = function () {\n    if (this.isEmpty()) return null;\n\n    var t = this._items.get(1);\n\n    return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t;\n  }, We.prototype.size = function () {\n    return this._size;\n  }, We.prototype.reorder = function (t) {\n    for (var e = null, n = this._items.get(t); 2 * t <= this._size && ((e = 2 * t) !== this._size && this._items.get(e + 1).compareTo(this._items.get(e)) < 0 && e++, this._items.get(e).compareTo(n) < 0); t = e) this._items.set(t, this._items.get(e));\n\n    this._items.set(t, n);\n  }, We.prototype.clear = function () {\n    this._size = 0, this._items.clear();\n  }, We.prototype.isEmpty = function () {\n    return 0 === this._size;\n  }, We.prototype.add = function (t) {\n    this._items.add(null), this._size += 1;\n    var e = this._size;\n\n    for (this._items.set(0, t); t.compareTo(this._items.get(Math.trunc(e / 2))) < 0; e /= 2) this._items.set(e, this._items.get(Math.trunc(e / 2)));\n\n    this._items.set(e, t);\n  }, We.prototype.interfaces_ = function () {\n    return [];\n  }, We.prototype.getClass = function () {\n    return We;\n  };\n\n  var Ke = function () {};\n\n  Ke.prototype.visitItem = function (t) {}, Ke.prototype.interfaces_ = function () {\n    return [];\n  }, Ke.prototype.getClass = function () {\n    return Ke;\n  };\n\n  var Je = function () {};\n\n  Je.prototype.insert = function (t, e) {}, Je.prototype.remove = function (t, e) {}, Je.prototype.query = function () {}, Je.prototype.interfaces_ = function () {\n    return [];\n  }, Je.prototype.getClass = function () {\n    return Je;\n  };\n\n  var Qe = function () {\n    if (this._childBoundables = new Nt(), this._bounds = null, this._level = null, 0 === arguments.length) ;else if (1 === arguments.length) {\n      var t = arguments[0];\n      this._level = t;\n    }\n  },\n      Ze = {\n    serialVersionUID: {\n      configurable: !0\n    }\n  };\n\n  Qe.prototype.getLevel = function () {\n    return this._level;\n  }, Qe.prototype.size = function () {\n    return this._childBoundables.size();\n  }, Qe.prototype.getChildBoundables = function () {\n    return this._childBoundables;\n  }, Qe.prototype.addChildBoundable = function (t) {\n    et.isTrue(null === this._bounds), this._childBoundables.add(t);\n  }, Qe.prototype.isEmpty = function () {\n    return this._childBoundables.isEmpty();\n  }, Qe.prototype.getBounds = function () {\n    return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds;\n  }, Qe.prototype.interfaces_ = function () {\n    return [je, e];\n  }, Qe.prototype.getClass = function () {\n    return Qe;\n  }, Ze.serialVersionUID.get = function () {\n    return 0x5a1e55ec41369800;\n  }, Object.defineProperties(Qe, Ze);\n\n  var $e = function () {};\n\n  $e.reverseOrder = function () {\n    return {\n      compare: function (t, e) {\n        return e.compareTo(t);\n      }\n    };\n  }, $e.min = function (t) {\n    return $e.sort(t), t.get(0);\n  }, $e.sort = function (t, e) {\n    var n = t.toArray();\n    e ? Gt.sort(n, e) : Gt.sort(n);\n\n    for (var i = t.iterator(), r = 0, o = n.length; r < o; r++) i.next(), i.set(n[r]);\n  }, $e.singletonList = function (t) {\n    var e = new Nt();\n    return e.add(t), e;\n  };\n\n  var tn = function () {\n    this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n    this._boundable1 = t, this._boundable2 = e, this._itemDistance = n, this._distance = this.distance();\n  };\n\n  tn.prototype.expandToQueue = function (t, e) {\n    var n = tn.isComposite(this._boundable1),\n        i = tn.isComposite(this._boundable2);\n    if (n && i) return tn.area(this._boundable1) > tn.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, t, e), null) : (this.expand(this._boundable2, this._boundable1, t, e), null);\n    if (n) return this.expand(this._boundable1, this._boundable2, t, e), null;\n    if (i) return this.expand(this._boundable2, this._boundable1, t, e), null;\n    throw new m(\"neither boundable is composite\");\n  }, tn.prototype.isLeaves = function () {\n    return !(tn.isComposite(this._boundable1) || tn.isComposite(this._boundable2));\n  }, tn.prototype.compareTo = function (t) {\n    var e = t;\n    return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0;\n  }, tn.prototype.expand = function (t, e, n, i) {\n    for (var r = t.getChildBoundables().iterator(); r.hasNext();) {\n      var o = r.next(),\n          s = new tn(o, e, this._itemDistance);\n      s.getDistance() < i && n.add(s);\n    }\n  }, tn.prototype.getBoundable = function (t) {\n    return 0 === t ? this._boundable1 : this._boundable2;\n  }, tn.prototype.getDistance = function () {\n    return this._distance;\n  }, tn.prototype.distance = function () {\n    return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());\n  }, tn.prototype.interfaces_ = function () {\n    return [E];\n  }, tn.prototype.getClass = function () {\n    return tn;\n  }, tn.area = function (t) {\n    return t.getBounds().getArea();\n  }, tn.isComposite = function (t) {\n    return t instanceof Qe;\n  };\n\n  var en = function t() {\n    if (this._root = null, this._built = !1, this._itemBoundables = new Nt(), this._nodeCapacity = null, 0 === arguments.length) {\n      var e = t.DEFAULT_NODE_CAPACITY;\n      this._nodeCapacity = e;\n    } else if (1 === arguments.length) {\n      var n = arguments[0];\n      et.isTrue(n > 1, \"Node capacity must be greater than 1\"), this._nodeCapacity = n;\n    }\n  },\n      nn = {\n    IntersectsOp: {\n      configurable: !0\n    },\n    serialVersionUID: {\n      configurable: !0\n    },\n    DEFAULT_NODE_CAPACITY: {\n      configurable: !0\n    }\n  };\n\n  en.prototype.getNodeCapacity = function () {\n    return this._nodeCapacity;\n  }, en.prototype.lastNode = function (t) {\n    return t.get(t.size() - 1);\n  }, en.prototype.size = function () {\n    if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));\n\n    if (1 === arguments.length) {\n      for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) {\n        var n = e.next();\n        n instanceof Qe ? t += this.size(n) : n instanceof He && (t += 1);\n      }\n\n      return t;\n    }\n  }, en.prototype.removeItem = function (t, e) {\n    for (var n = null, i = t.getChildBoundables().iterator(); i.hasNext();) {\n      var r = i.next();\n      r instanceof He && r.getItem() === e && (n = r);\n    }\n\n    return null !== n && (t.getChildBoundables().remove(n), !0);\n  }, en.prototype.itemsTree = function () {\n    if (0 === arguments.length) {\n      this.build();\n      var t = this.itemsTree(this._root);\n      return null === t ? new Nt() : t;\n    }\n\n    if (1 === arguments.length) {\n      for (var e = arguments[0], n = new Nt(), i = e.getChildBoundables().iterator(); i.hasNext();) {\n        var r = i.next();\n\n        if (r instanceof Qe) {\n          var o = this.itemsTree(r);\n          null !== o && n.add(o);\n        } else r instanceof He ? n.add(r.getItem()) : et.shouldNeverReachHere();\n      }\n\n      return n.size() <= 0 ? null : n;\n    }\n  }, en.prototype.insert = function (t, e) {\n    et.isTrue(!this._built, \"Cannot insert items into an STR packed R-tree after it has been built.\"), this._itemBoundables.add(new He(t, e));\n  }, en.prototype.boundablesAtLevel = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n          e = new Nt();\n      return this.boundablesAtLevel(t, this._root, e), e;\n    }\n\n    if (3 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2];\n      if (et.isTrue(n > -2), i.getLevel() === n) return r.add(i), null;\n\n      for (var o = i.getChildBoundables().iterator(); o.hasNext();) {\n        var s = o.next();\n        s instanceof Qe ? this.boundablesAtLevel(n, s, r) : (et.isTrue(s instanceof He), -1 === n && r.add(s));\n      }\n\n      return null;\n    }\n  }, en.prototype.query = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.build();\n      var e = new Nt();\n      return this.isEmpty() ? e : (this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.query(t, this._root, e), e);\n    }\n\n    if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1];\n      if (this.build(), this.isEmpty()) return null;\n      this.getIntersectsOp().intersects(this._root.getBounds(), n) && this.query(n, this._root, i);\n    } else if (3 === arguments.length) if (T(arguments[2], Ke) && arguments[0] instanceof Object && arguments[1] instanceof Qe) for (var r = arguments[0], o = arguments[1], s = arguments[2], a = o.getChildBoundables(), u = 0; u < a.size(); u++) {\n      var l = a.get(u);\n      this.getIntersectsOp().intersects(l.getBounds(), r) && (l instanceof Qe ? this.query(r, l, s) : l instanceof He ? s.visitItem(l.getItem()) : et.shouldNeverReachHere());\n    } else if (T(arguments[2], xt) && arguments[0] instanceof Object && arguments[1] instanceof Qe) for (var c = arguments[0], p = arguments[1], h = arguments[2], f = p.getChildBoundables(), g = 0; g < f.size(); g++) {\n      var d = f.get(g);\n      this.getIntersectsOp().intersects(d.getBounds(), c) && (d instanceof Qe ? this.query(c, d, h) : d instanceof He ? h.add(d.getItem()) : et.shouldNeverReachHere());\n    }\n  }, en.prototype.build = function () {\n    if (this._built) return null;\n    this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0;\n  }, en.prototype.getRoot = function () {\n    return this.build(), this._root;\n  }, en.prototype.remove = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.remove(t, this._root, e);\n    }\n\n    if (3 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2],\n          o = this.removeItem(i, r);\n      if (o) return !0;\n\n      for (var s = null, a = i.getChildBoundables().iterator(); a.hasNext();) {\n        var u = a.next();\n\n        if (this.getIntersectsOp().intersects(u.getBounds(), n) && u instanceof Qe && (o = this.remove(n, u, r))) {\n          s = u;\n          break;\n        }\n      }\n\n      return null !== s && s.getChildBoundables().isEmpty() && i.getChildBoundables().remove(s), o;\n    }\n  }, en.prototype.createHigherLevels = function (t, e) {\n    et.isTrue(!t.isEmpty());\n    var n = this.createParentBoundables(t, e + 1);\n    return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1);\n  }, en.prototype.depth = function () {\n    if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));\n\n    if (1 === arguments.length) {\n      for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) {\n        var n = e.next();\n\n        if (n instanceof Qe) {\n          var i = this.depth(n);\n          i > t && (t = i);\n        }\n      }\n\n      return t + 1;\n    }\n  }, en.prototype.createParentBoundables = function (t, e) {\n    et.isTrue(!t.isEmpty());\n    var n = new Nt();\n    n.add(this.createNode(e));\n    var i = new Nt(t);\n    $e.sort(i, this.getComparator());\n\n    for (var r = i.iterator(); r.hasNext();) {\n      var o = r.next();\n      this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() && n.add(this.createNode(e)), this.lastNode(n).addChildBoundable(o);\n    }\n\n    return n;\n  }, en.prototype.isEmpty = function () {\n    return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();\n  }, en.prototype.interfaces_ = function () {\n    return [e];\n  }, en.prototype.getClass = function () {\n    return en;\n  }, en.compareDoubles = function (t, e) {\n    return t > e ? 1 : t < e ? -1 : 0;\n  }, nn.IntersectsOp.get = function () {\n    return rn;\n  }, nn.serialVersionUID.get = function () {\n    return -0x35ef64c82d4c5400;\n  }, nn.DEFAULT_NODE_CAPACITY.get = function () {\n    return 10;\n  }, Object.defineProperties(en, nn);\n\n  var rn = function () {},\n      on = function () {};\n\n  on.prototype.distance = function (t, e) {}, on.prototype.interfaces_ = function () {\n    return [];\n  }, on.prototype.getClass = function () {\n    return on;\n  };\n\n  var sn = function (t) {\n    function n(e) {\n      e = e || n.DEFAULT_NODE_CAPACITY, t.call(this, e);\n    }\n\n    t && (n.__proto__ = t), (n.prototype = Object.create(t && t.prototype)).constructor = n;\n    var i = {\n      STRtreeNode: {\n        configurable: !0\n      },\n      serialVersionUID: {\n        configurable: !0\n      },\n      xComparator: {\n        configurable: !0\n      },\n      yComparator: {\n        configurable: !0\n      },\n      intersectsOp: {\n        configurable: !0\n      },\n      DEFAULT_NODE_CAPACITY: {\n        configurable: !0\n      }\n    };\n    return n.prototype.createParentBoundablesFromVerticalSlices = function (t, e) {\n      et.isTrue(t.length > 0);\n\n      for (var n = new Nt(), i = 0; i < t.length; i++) n.addAll(this.createParentBoundablesFromVerticalSlice(t[i], e));\n\n      return n;\n    }, n.prototype.createNode = function (t) {\n      return new an(t);\n    }, n.prototype.size = function () {\n      return 0 === arguments.length ? t.prototype.size.call(this) : t.prototype.size.apply(this, arguments);\n    }, n.prototype.insert = function () {\n      if (2 !== arguments.length) return t.prototype.insert.apply(this, arguments);\n      var e = arguments[0],\n          n = arguments[1];\n      if (e.isNull()) return null;\n      t.prototype.insert.call(this, e, n);\n    }, n.prototype.getIntersectsOp = function () {\n      return n.intersectsOp;\n    }, n.prototype.verticalSlices = function (t, e) {\n      for (var n = Math.trunc(Math.ceil(t.size() / e)), i = new Array(e).fill(null), r = t.iterator(), o = 0; o < e; o++) {\n        i[o] = new Nt();\n\n        for (var s = 0; r.hasNext() && s < n;) {\n          var a = r.next();\n          i[o].add(a), s++;\n        }\n      }\n\n      return i;\n    }, n.prototype.query = function () {\n      if (1 === arguments.length) {\n        var e = arguments[0];\n        return t.prototype.query.call(this, e);\n      }\n\n      if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1];\n        t.prototype.query.call(this, n, i);\n      } else if (3 === arguments.length) if (T(arguments[2], Ke) && arguments[0] instanceof Object && arguments[1] instanceof Qe) {\n        var r = arguments[0],\n            o = arguments[1],\n            s = arguments[2];\n        t.prototype.query.call(this, r, o, s);\n      } else if (T(arguments[2], xt) && arguments[0] instanceof Object && arguments[1] instanceof Qe) {\n        var a = arguments[0],\n            u = arguments[1],\n            l = arguments[2];\n        t.prototype.query.call(this, a, u, l);\n      }\n    }, n.prototype.getComparator = function () {\n      return n.yComparator;\n    }, n.prototype.createParentBoundablesFromVerticalSlice = function (e, n) {\n      return t.prototype.createParentBoundables.call(this, e, n);\n    }, n.prototype.remove = function () {\n      if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        return t.prototype.remove.call(this, e, n);\n      }\n\n      return t.prototype.remove.apply(this, arguments);\n    }, n.prototype.depth = function () {\n      return 0 === arguments.length ? t.prototype.depth.call(this) : t.prototype.depth.apply(this, arguments);\n    }, n.prototype.createParentBoundables = function (t, e) {\n      et.isTrue(!t.isEmpty());\n      var i = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())),\n          r = new Nt(t);\n      $e.sort(r, n.xComparator);\n      var o = this.verticalSlices(r, Math.trunc(Math.ceil(Math.sqrt(i))));\n      return this.createParentBoundablesFromVerticalSlices(o, e);\n    }, n.prototype.nearestNeighbour = function () {\n      if (1 === arguments.length) {\n        if (T(arguments[0], on)) {\n          var t = arguments[0],\n              e = new tn(this.getRoot(), this.getRoot(), t);\n          return this.nearestNeighbour(e);\n        }\n\n        if (arguments[0] instanceof tn) {\n          var i = arguments[0];\n          return this.nearestNeighbour(i, v.POSITIVE_INFINITY);\n        }\n      } else if (2 === arguments.length) {\n        if (arguments[0] instanceof n && T(arguments[1], on)) {\n          var r = arguments[0],\n              o = arguments[1],\n              s = new tn(this.getRoot(), r.getRoot(), o);\n          return this.nearestNeighbour(s);\n        }\n\n        if (arguments[0] instanceof tn && \"number\" == typeof arguments[1]) {\n          var a = arguments[0],\n              u = arguments[1],\n              l = null,\n              c = new We();\n\n          for (c.add(a); !c.isEmpty() && u > 0;) {\n            var p = c.poll(),\n                h = p.getDistance();\n            if (h >= u) break;\n            p.isLeaves() ? (u = h, l = p) : p.expandToQueue(c, u);\n          }\n\n          return [l.getBoundable(0).getItem(), l.getBoundable(1).getItem()];\n        }\n      } else if (3 === arguments.length) {\n        var f = arguments[0],\n            g = arguments[1],\n            d = arguments[2],\n            y = new He(f, g),\n            _ = new tn(this.getRoot(), y, d);\n\n        return this.nearestNeighbour(_)[0];\n      }\n    }, n.prototype.interfaces_ = function () {\n      return [Je, e];\n    }, n.prototype.getClass = function () {\n      return n;\n    }, n.centreX = function (t) {\n      return n.avg(t.getMinX(), t.getMaxX());\n    }, n.avg = function (t, e) {\n      return (t + e) / 2;\n    }, n.centreY = function (t) {\n      return n.avg(t.getMinY(), t.getMaxY());\n    }, i.STRtreeNode.get = function () {\n      return an;\n    }, i.serialVersionUID.get = function () {\n      return 0x39920f7d5f261e0;\n    }, i.xComparator.get = function () {\n      return {\n        interfaces_: function () {\n          return [N];\n        },\n        compare: function (e, i) {\n          return t.compareDoubles(n.centreX(e.getBounds()), n.centreX(i.getBounds()));\n        }\n      };\n    }, i.yComparator.get = function () {\n      return {\n        interfaces_: function () {\n          return [N];\n        },\n        compare: function (e, i) {\n          return t.compareDoubles(n.centreY(e.getBounds()), n.centreY(i.getBounds()));\n        }\n      };\n    }, i.intersectsOp.get = function () {\n      return {\n        interfaces_: function () {\n          return [t.IntersectsOp];\n        },\n        intersects: function (t, e) {\n          return t.intersects(e);\n        }\n      };\n    }, i.DEFAULT_NODE_CAPACITY.get = function () {\n      return 10;\n    }, Object.defineProperties(n, i), n;\n  }(en),\n      an = function (t) {\n    function e() {\n      var e = arguments[0];\n      t.call(this, e);\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.computeBounds = function () {\n      for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext();) {\n        var n = e.next();\n        null === t ? t = new j(n.getBounds()) : t.expandToInclude(n.getBounds());\n      }\n\n      return t;\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e;\n  }(Qe),\n      un = function () {};\n\n  un.prototype.interfaces_ = function () {\n    return [];\n  }, un.prototype.getClass = function () {\n    return un;\n  }, un.relativeSign = function (t, e) {\n    return t < e ? -1 : t > e ? 1 : 0;\n  }, un.compare = function (t, e, n) {\n    if (e.equals2D(n)) return 0;\n    var i = un.relativeSign(e.x, n.x),\n        r = un.relativeSign(e.y, n.y);\n\n    switch (t) {\n      case 0:\n        return un.compareValue(i, r);\n\n      case 1:\n        return un.compareValue(r, i);\n\n      case 2:\n        return un.compareValue(r, -i);\n\n      case 3:\n        return un.compareValue(-i, r);\n\n      case 4:\n        return un.compareValue(-i, -r);\n\n      case 5:\n        return un.compareValue(-r, -i);\n\n      case 6:\n        return un.compareValue(-r, i);\n\n      case 7:\n        return un.compareValue(i, -r);\n    }\n\n    return et.shouldNeverReachHere(\"invalid octant value\"), 0;\n  }, un.compareValue = function (t, e) {\n    return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0;\n  };\n\n  var ln = function () {\n    this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2],\n        i = arguments[3];\n    this._segString = t, this.coord = new C(e), this.segmentIndex = n, this._segmentOctant = i, this._isInterior = !e.equals2D(t.getCoordinate(n));\n  };\n\n  ln.prototype.getCoordinate = function () {\n    return this.coord;\n  }, ln.prototype.print = function (t) {\n    t.print(this.coord), t.print(\" seg # = \" + this.segmentIndex);\n  }, ln.prototype.compareTo = function (t) {\n    var e = t;\n    return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : un.compare(this._segmentOctant, this.coord, e.coord);\n  }, ln.prototype.isEndPoint = function (t) {\n    return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t;\n  }, ln.prototype.isInterior = function () {\n    return this._isInterior;\n  }, ln.prototype.interfaces_ = function () {\n    return [E];\n  }, ln.prototype.getClass = function () {\n    return ln;\n  };\n\n  var cn = function () {\n    this._nodeMap = new p(), this._edge = null;\n    var t = arguments[0];\n    this._edge = t;\n  };\n\n  cn.prototype.getSplitCoordinates = function () {\n    var t = new St();\n    this.addEndpoints();\n\n    for (var e = this.iterator(), n = e.next(); e.hasNext();) {\n      var i = e.next();\n      this.addEdgeCoordinates(n, i, t), n = i;\n    }\n\n    return t.toCoordinateArray();\n  }, cn.prototype.addCollapsedNodes = function () {\n    var t = new Nt();\n    this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);\n\n    for (var e = t.iterator(); e.hasNext();) {\n      var n = e.next().intValue();\n      this.add(this._edge.getCoordinate(n), n);\n    }\n  }, cn.prototype.print = function (t) {\n    t.println(\"Intersections:\");\n\n    for (var e = this.iterator(); e.hasNext();) {\n      e.next().print(t);\n    }\n  }, cn.prototype.findCollapsesFromExistingVertices = function (t) {\n    for (var e = 0; e < this._edge.size() - 2; e++) {\n      var n = this._edge.getCoordinate(e),\n          i = this._edge.getCoordinate(e + 2);\n\n      n.equals2D(i) && t.add(new M(e + 1));\n    }\n  }, cn.prototype.addEdgeCoordinates = function (t, e, n) {\n    var i = this._edge.getCoordinate(e.segmentIndex),\n        r = e.isInterior() || !e.coord.equals2D(i);\n\n    n.add(new C(t.coord), !1);\n\n    for (var o = t.segmentIndex + 1; o <= e.segmentIndex; o++) n.add(this._edge.getCoordinate(o));\n\n    r && n.add(new C(e.coord));\n  }, cn.prototype.iterator = function () {\n    return this._nodeMap.values().iterator();\n  }, cn.prototype.addSplitEdges = function (t) {\n    this.addEndpoints(), this.addCollapsedNodes();\n\n    for (var e = this.iterator(), n = e.next(); e.hasNext();) {\n      var i = e.next(),\n          r = this.createSplitEdge(n, i);\n      t.add(r), n = i;\n    }\n  }, cn.prototype.findCollapseIndex = function (t, e, n) {\n    if (!t.coord.equals2D(e.coord)) return !1;\n    var i = e.segmentIndex - t.segmentIndex;\n    return e.isInterior() || i--, 1 === i && (n[0] = t.segmentIndex + 1, !0);\n  }, cn.prototype.findCollapsesFromInsertedNodes = function (t) {\n    for (var e = new Array(1).fill(null), n = this.iterator(), i = n.next(); n.hasNext();) {\n      var r = n.next();\n      this.findCollapseIndex(i, r, e) && t.add(new M(e[0])), i = r;\n    }\n  }, cn.prototype.getEdge = function () {\n    return this._edge;\n  }, cn.prototype.addEndpoints = function () {\n    var t = this._edge.size() - 1;\n    this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t), t);\n  }, cn.prototype.createSplitEdge = function (t, e) {\n    var n = e.segmentIndex - t.segmentIndex + 2,\n        i = this._edge.getCoordinate(e.segmentIndex),\n        r = e.isInterior() || !e.coord.equals2D(i);\n\n    r || n--;\n    var o = new Array(n).fill(null),\n        s = 0;\n    o[s++] = new C(t.coord);\n\n    for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) o[s++] = this._edge.getCoordinate(a);\n\n    return r && (o[s] = new C(e.coord)), new gn(o, this._edge.getData());\n  }, cn.prototype.add = function (t, e) {\n    var n = new ln(this._edge, t, e, this._edge.getSegmentOctant(e)),\n        i = this._nodeMap.get(n);\n\n    return null !== i ? (et.isTrue(i.coord.equals2D(t), \"Found equal nodes with different coordinates\"), i) : (this._nodeMap.put(n, n), n);\n  }, cn.prototype.checkSplitEdgesCorrectness = function (t) {\n    var e = this._edge.getCoordinates(),\n        n = t.get(0).getCoordinate(0);\n\n    if (!n.equals2D(e[0])) throw new $(\"bad split edge start point at \" + n);\n    var i = t.get(t.size() - 1).getCoordinates(),\n        r = i[i.length - 1];\n    if (!r.equals2D(e[e.length - 1])) throw new $(\"bad split edge end point at \" + r);\n  }, cn.prototype.interfaces_ = function () {\n    return [];\n  }, cn.prototype.getClass = function () {\n    return cn;\n  };\n\n  var pn = function () {};\n\n  pn.prototype.interfaces_ = function () {\n    return [];\n  }, pn.prototype.getClass = function () {\n    return pn;\n  }, pn.octant = function () {\n    if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n      var t = arguments[0],\n          e = arguments[1];\n      if (0 === t && 0 === e) throw new m(\"Cannot compute the octant for point ( \" + t + \", \" + e + \" )\");\n      var n = Math.abs(t),\n          i = Math.abs(e);\n      return t >= 0 ? e >= 0 ? n >= i ? 0 : 1 : n >= i ? 7 : 6 : e >= 0 ? n >= i ? 3 : 2 : n >= i ? 4 : 5;\n    }\n\n    if (arguments[0] instanceof C && arguments[1] instanceof C) {\n      var r = arguments[0],\n          o = arguments[1],\n          s = o.x - r.x,\n          a = o.y - r.y;\n      if (0 === s && 0 === a) throw new m(\"Cannot compute the octant for two identical points \" + r);\n      return pn.octant(s, a);\n    }\n  };\n\n  var hn = function () {};\n\n  hn.prototype.getCoordinates = function () {}, hn.prototype.size = function () {}, hn.prototype.getCoordinate = function (t) {}, hn.prototype.isClosed = function () {}, hn.prototype.setData = function (t) {}, hn.prototype.getData = function () {}, hn.prototype.interfaces_ = function () {\n    return [];\n  }, hn.prototype.getClass = function () {\n    return hn;\n  };\n\n  var fn = function () {};\n\n  fn.prototype.addIntersection = function (t, e) {}, fn.prototype.interfaces_ = function () {\n    return [hn];\n  }, fn.prototype.getClass = function () {\n    return fn;\n  };\n\n  var gn = function () {\n    this._nodeList = new cn(this), this._pts = null, this._data = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this._pts = t, this._data = e;\n  };\n\n  gn.prototype.getCoordinates = function () {\n    return this._pts;\n  }, gn.prototype.size = function () {\n    return this._pts.length;\n  }, gn.prototype.getCoordinate = function (t) {\n    return this._pts[t];\n  }, gn.prototype.isClosed = function () {\n    return this._pts[0].equals(this._pts[this._pts.length - 1]);\n  }, gn.prototype.getSegmentOctant = function (t) {\n    return t === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1));\n  }, gn.prototype.setData = function (t) {\n    this._data = t;\n  }, gn.prototype.safeOctant = function (t, e) {\n    return t.equals2D(e) ? 0 : pn.octant(t, e);\n  }, gn.prototype.getData = function () {\n    return this._data;\n  }, gn.prototype.addIntersection = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      this.addIntersectionNode(t, e);\n    } else if (4 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[3],\n          o = new C(n.getIntersection(r));\n      this.addIntersection(o, i);\n    }\n  }, gn.prototype.toString = function () {\n    return Z.toLineString(new ue(this._pts));\n  }, gn.prototype.getNodeList = function () {\n    return this._nodeList;\n  }, gn.prototype.addIntersectionNode = function (t, e) {\n    var n = e,\n        i = n + 1;\n\n    if (i < this._pts.length) {\n      var r = this._pts[i];\n      t.equals2D(r) && (n = i);\n    }\n\n    return this._nodeList.add(t, n);\n  }, gn.prototype.addIntersections = function (t, e, n) {\n    for (var i = 0; i < t.getIntersectionNum(); i++) this.addIntersection(t, e, n, i);\n  }, gn.prototype.interfaces_ = function () {\n    return [fn];\n  }, gn.prototype.getClass = function () {\n    return gn;\n  }, gn.getNodedSubstrings = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n          e = new Nt();\n      return gn.getNodedSubstrings(t, e), e;\n    }\n\n    if (2 === arguments.length) for (var n = arguments[0], i = arguments[1], r = n.iterator(); r.hasNext();) {\n      r.next().getNodeList().addSplitEdges(i);\n    }\n  };\n\n  var dn = function () {\n    if (this.p0 = null, this.p1 = null, 0 === arguments.length) this.p0 = new C(), this.p1 = new C();else if (1 === arguments.length) {\n      var t = arguments[0];\n      this.p0 = new C(t.p0), this.p1 = new C(t.p1);\n    } else if (2 === arguments.length) this.p0 = arguments[0], this.p1 = arguments[1];else if (4 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1],\n          i = arguments[2],\n          r = arguments[3];\n      this.p0 = new C(e, n), this.p1 = new C(i, r);\n    }\n  },\n      yn = {\n    serialVersionUID: {\n      configurable: !0\n    }\n  };\n\n  dn.prototype.minX = function () {\n    return Math.min(this.p0.x, this.p1.x);\n  }, dn.prototype.orientationIndex = function () {\n    if (arguments[0] instanceof dn) {\n      var t = arguments[0],\n          e = at.orientationIndex(this.p0, this.p1, t.p0),\n          n = at.orientationIndex(this.p0, this.p1, t.p1);\n      return e >= 0 && n >= 0 ? Math.max(e, n) : e <= 0 && n <= 0 ? Math.max(e, n) : 0;\n    }\n\n    if (arguments[0] instanceof C) {\n      var i = arguments[0];\n      return at.orientationIndex(this.p0, this.p1, i);\n    }\n  }, dn.prototype.toGeometry = function (t) {\n    return t.createLineString([this.p0, this.p1]);\n  }, dn.prototype.isVertical = function () {\n    return this.p0.x === this.p1.x;\n  }, dn.prototype.equals = function (t) {\n    if (!(t instanceof dn)) return !1;\n    var e = t;\n    return this.p0.equals(e.p0) && this.p1.equals(e.p1);\n  }, dn.prototype.intersection = function (t) {\n    var e = new rt();\n    return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null;\n  }, dn.prototype.project = function () {\n    if (arguments[0] instanceof C) {\n      var t = arguments[0];\n      if (t.equals(this.p0) || t.equals(this.p1)) return new C(t);\n      var e = this.projectionFactor(t),\n          n = new C();\n      return n.x = this.p0.x + e * (this.p1.x - this.p0.x), n.y = this.p0.y + e * (this.p1.y - this.p0.y), n;\n    }\n\n    if (arguments[0] instanceof dn) {\n      var i = arguments[0],\n          r = this.projectionFactor(i.p0),\n          o = this.projectionFactor(i.p1);\n      if (r >= 1 && o >= 1) return null;\n      if (r <= 0 && o <= 0) return null;\n      var s = this.project(i.p0);\n      r < 0 && (s = this.p0), r > 1 && (s = this.p1);\n      var a = this.project(i.p1);\n      return o < 0 && (a = this.p0), o > 1 && (a = this.p1), new dn(s, a);\n    }\n  }, dn.prototype.normalize = function () {\n    this.p1.compareTo(this.p0) < 0 && this.reverse();\n  }, dn.prototype.angle = function () {\n    return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);\n  }, dn.prototype.getCoordinate = function (t) {\n    return 0 === t ? this.p0 : this.p1;\n  }, dn.prototype.distancePerpendicular = function (t) {\n    return at.distancePointLinePerpendicular(t, this.p0, this.p1);\n  }, dn.prototype.minY = function () {\n    return Math.min(this.p0.y, this.p1.y);\n  }, dn.prototype.midPoint = function () {\n    return dn.midPoint(this.p0, this.p1);\n  }, dn.prototype.projectionFactor = function (t) {\n    if (t.equals(this.p0)) return 0;\n    if (t.equals(this.p1)) return 1;\n    var e = this.p1.x - this.p0.x,\n        n = this.p1.y - this.p0.y,\n        i = e * e + n * n;\n    if (i <= 0) return v.NaN;\n    return ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / i;\n  }, dn.prototype.closestPoints = function (t) {\n    var e = this.intersection(t);\n    if (null !== e) return [e, e];\n    var n = new Array(2).fill(null),\n        i = v.MAX_VALUE,\n        r = null,\n        o = this.closestPoint(t.p0);\n    i = o.distance(t.p0), n[0] = o, n[1] = t.p0;\n    var s = this.closestPoint(t.p1);\n    (r = s.distance(t.p1)) < i && (i = r, n[0] = s, n[1] = t.p1);\n    var a = t.closestPoint(this.p0);\n    (r = a.distance(this.p0)) < i && (i = r, n[0] = this.p0, n[1] = a);\n    var u = t.closestPoint(this.p1);\n    return (r = u.distance(this.p1)) < i && (i = r, n[0] = this.p1, n[1] = u), n;\n  }, dn.prototype.closestPoint = function (t) {\n    var e = this.projectionFactor(t);\n    if (e > 0 && e < 1) return this.project(t);\n    return this.p0.distance(t) < this.p1.distance(t) ? this.p0 : this.p1;\n  }, dn.prototype.maxX = function () {\n    return Math.max(this.p0.x, this.p1.x);\n  }, dn.prototype.getLength = function () {\n    return this.p0.distance(this.p1);\n  }, dn.prototype.compareTo = function (t) {\n    var e = t,\n        n = this.p0.compareTo(e.p0);\n    return 0 !== n ? n : this.p1.compareTo(e.p1);\n  }, dn.prototype.reverse = function () {\n    var t = this.p0;\n    this.p0 = this.p1, this.p1 = t;\n  }, dn.prototype.equalsTopo = function (t) {\n    return this.p0.equals(t.p0) && (this.p1.equals(t.p1) || this.p0.equals(t.p1)) && this.p1.equals(t.p0);\n  }, dn.prototype.lineIntersection = function (t) {\n    try {\n      return k.intersection(this.p0, this.p1, t.p0, t.p1);\n    } catch (t) {\n      if (!(t instanceof X)) throw t;\n    }\n\n    return null;\n  }, dn.prototype.maxY = function () {\n    return Math.max(this.p0.y, this.p1.y);\n  }, dn.prototype.pointAlongOffset = function (t, e) {\n    var n = this.p0.x + t * (this.p1.x - this.p0.x),\n        i = this.p0.y + t * (this.p1.y - this.p0.y),\n        r = this.p1.x - this.p0.x,\n        o = this.p1.y - this.p0.y,\n        s = Math.sqrt(r * r + o * o),\n        a = 0,\n        u = 0;\n\n    if (0 !== e) {\n      if (s <= 0) throw new Error(\"Cannot compute offset from zero-length line segment\");\n      a = e * r / s, u = e * o / s;\n    }\n\n    return new C(n - u, i + a);\n  }, dn.prototype.setCoordinates = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setCoordinates(t.p0, t.p1);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.p0.x = e.x, this.p0.y = e.y, this.p1.x = n.x, this.p1.y = n.y;\n    }\n  }, dn.prototype.segmentFraction = function (t) {\n    var e = this.projectionFactor(t);\n    return e < 0 ? e = 0 : (e > 1 || v.isNaN(e)) && (e = 1), e;\n  }, dn.prototype.toString = function () {\n    return \"LINESTRING( \" + this.p0.x + \" \" + this.p0.y + \", \" + this.p1.x + \" \" + this.p1.y + \")\";\n  }, dn.prototype.isHorizontal = function () {\n    return this.p0.y === this.p1.y;\n  }, dn.prototype.distance = function () {\n    if (arguments[0] instanceof dn) {\n      var t = arguments[0];\n      return at.distanceLineLine(this.p0, this.p1, t.p0, t.p1);\n    }\n\n    if (arguments[0] instanceof C) {\n      var e = arguments[0];\n      return at.distancePointLine(e, this.p0, this.p1);\n    }\n  }, dn.prototype.pointAlong = function (t) {\n    var e = new C();\n    return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e;\n  }, dn.prototype.hashCode = function () {\n    var t = v.doubleToLongBits(this.p0.x);\n    t ^= 31 * v.doubleToLongBits(this.p0.y);\n    var e = Math.trunc(t) ^ Math.trunc(t >> 32),\n        n = v.doubleToLongBits(this.p1.x);\n    n ^= 31 * v.doubleToLongBits(this.p1.y);\n    return e ^ (Math.trunc(n) ^ Math.trunc(n >> 32));\n  }, dn.prototype.interfaces_ = function () {\n    return [E, e];\n  }, dn.prototype.getClass = function () {\n    return dn;\n  }, dn.midPoint = function (t, e) {\n    return new C((t.x + e.x) / 2, (t.y + e.y) / 2);\n  }, yn.serialVersionUID.get = function () {\n    return 0x2d2172135f411c00;\n  }, Object.defineProperties(dn, yn);\n\n  var _n = function () {\n    this.tempEnv1 = new j(), this.tempEnv2 = new j(), this._overlapSeg1 = new dn(), this._overlapSeg2 = new dn();\n  };\n\n  _n.prototype.overlap = function () {\n    if (2 === arguments.length) ;else if (4 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1],\n          n = arguments[2],\n          i = arguments[3];\n      t.getLineSegment(e, this._overlapSeg1), n.getLineSegment(i, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);\n    }\n  }, _n.prototype.interfaces_ = function () {\n    return [];\n  }, _n.prototype.getClass = function () {\n    return _n;\n  };\n\n  var mn = function () {\n    this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2],\n        i = arguments[3];\n    this._pts = t, this._start = e, this._end = n, this._context = i;\n  };\n\n  mn.prototype.getLineSegment = function (t, e) {\n    e.p0 = this._pts[t], e.p1 = this._pts[t + 1];\n  }, mn.prototype.computeSelect = function (t, e, n, i) {\n    var r = this._pts[e],\n        o = this._pts[n];\n    if (i.tempEnv1.init(r, o), n - e == 1) return i.select(this, e), null;\n    if (!t.intersects(i.tempEnv1)) return null;\n    var s = Math.trunc((e + n) / 2);\n    e < s && this.computeSelect(t, e, s, i), s < n && this.computeSelect(t, s, n, i);\n  }, mn.prototype.getCoordinates = function () {\n    for (var t = new Array(this._end - this._start + 1).fill(null), e = 0, n = this._start; n <= this._end; n++) t[e++] = this._pts[n];\n\n    return t;\n  }, mn.prototype.computeOverlaps = function (t, e) {\n    this.computeOverlapsInternal(this._start, this._end, t, t._start, t._end, e);\n  }, mn.prototype.setId = function (t) {\n    this._id = t;\n  }, mn.prototype.select = function (t, e) {\n    this.computeSelect(t, this._start, this._end, e);\n  }, mn.prototype.getEnvelope = function () {\n    if (null === this._env) {\n      var t = this._pts[this._start],\n          e = this._pts[this._end];\n      this._env = new j(t, e);\n    }\n\n    return this._env;\n  }, mn.prototype.getEndIndex = function () {\n    return this._end;\n  }, mn.prototype.getStartIndex = function () {\n    return this._start;\n  }, mn.prototype.getContext = function () {\n    return this._context;\n  }, mn.prototype.getId = function () {\n    return this._id;\n  }, mn.prototype.computeOverlapsInternal = function (t, e, n, i, r, o) {\n    var s = this._pts[t],\n        a = this._pts[e],\n        u = n._pts[i],\n        l = n._pts[r];\n    if (e - t == 1 && r - i == 1) return o.overlap(this, t, n, i), null;\n    if (o.tempEnv1.init(s, a), o.tempEnv2.init(u, l), !o.tempEnv1.intersects(o.tempEnv2)) return null;\n    var c = Math.trunc((t + e) / 2),\n        p = Math.trunc((i + r) / 2);\n    t < c && (i < p && this.computeOverlapsInternal(t, c, n, i, p, o), p < r && this.computeOverlapsInternal(t, c, n, p, r, o)), c < e && (i < p && this.computeOverlapsInternal(c, e, n, i, p, o), p < r && this.computeOverlapsInternal(c, e, n, p, r, o));\n  }, mn.prototype.interfaces_ = function () {\n    return [];\n  }, mn.prototype.getClass = function () {\n    return mn;\n  };\n\n  var vn = function () {};\n\n  vn.prototype.interfaces_ = function () {\n    return [];\n  }, vn.prototype.getClass = function () {\n    return vn;\n  }, vn.getChainStartIndices = function (t) {\n    var e = 0,\n        n = new Nt();\n    n.add(new M(e));\n\n    do {\n      var i = vn.findChainEnd(t, e);\n      n.add(new M(i)), e = i;\n    } while (e < t.length - 1);\n\n    return vn.toIntArray(n);\n  }, vn.findChainEnd = function (t, e) {\n    for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]);) n++;\n\n    if (n >= t.length - 1) return t.length - 1;\n\n    for (var i = Be.quadrant(t[n], t[n + 1]), r = e + 1; r < t.length;) {\n      if (!t[r - 1].equals2D(t[r])) {\n        if (Be.quadrant(t[r - 1], t[r]) !== i) break;\n      }\n\n      r++;\n    }\n\n    return r - 1;\n  }, vn.getChains = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return vn.getChains(t, null);\n    }\n\n    if (2 === arguments.length) {\n      for (var e = arguments[0], n = arguments[1], i = new Nt(), r = vn.getChainStartIndices(e), o = 0; o < r.length - 1; o++) {\n        var s = new mn(e, r[o], r[o + 1], n);\n        i.add(s);\n      }\n\n      return i;\n    }\n  }, vn.toIntArray = function (t) {\n    for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) e[n] = t.get(n).intValue();\n\n    return e;\n  };\n\n  var In = function () {};\n\n  In.prototype.computeNodes = function (t) {}, In.prototype.getNodedSubstrings = function () {}, In.prototype.interfaces_ = function () {\n    return [];\n  }, In.prototype.getClass = function () {\n    return In;\n  };\n\n  var En = function () {\n    if (this._segInt = null, 0 === arguments.length) ;else if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setSegmentIntersector(t);\n    }\n  };\n\n  En.prototype.setSegmentIntersector = function (t) {\n    this._segInt = t;\n  }, En.prototype.interfaces_ = function () {\n    return [In];\n  }, En.prototype.getClass = function () {\n    return En;\n  };\n\n  var xn = function (t) {\n    function e(e) {\n      e ? t.call(this, e) : t.call(this), this._monoChains = new Nt(), this._index = new sn(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0;\n    }\n\n    t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n    var n = {\n      SegmentOverlapAction: {\n        configurable: !0\n      }\n    };\n    return e.prototype.getMonotoneChains = function () {\n      return this._monoChains;\n    }, e.prototype.getNodedSubstrings = function () {\n      return gn.getNodedSubstrings(this._nodedSegStrings);\n    }, e.prototype.getIndex = function () {\n      return this._index;\n    }, e.prototype.add = function (t) {\n      for (var e = vn.getChains(t.getCoordinates(), t).iterator(); e.hasNext();) {\n        var n = e.next();\n        n.setId(this._idCounter++), this._index.insert(n.getEnvelope(), n), this._monoChains.add(n);\n      }\n    }, e.prototype.computeNodes = function (t) {\n      this._nodedSegStrings = t;\n\n      for (var e = t.iterator(); e.hasNext();) this.add(e.next());\n\n      this.intersectChains();\n    }, e.prototype.intersectChains = function () {\n      for (var t = new Nn(this._segInt), e = this._monoChains.iterator(); e.hasNext();) for (var n = e.next(), i = this._index.query(n.getEnvelope()).iterator(); i.hasNext();) {\n        var r = i.next();\n        if (r.getId() > n.getId() && (n.computeOverlaps(r, t), this._nOverlaps++), this._segInt.isDone()) return null;\n      }\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, n.SegmentOverlapAction.get = function () {\n      return Nn;\n    }, Object.defineProperties(e, n), e;\n  }(En),\n      Nn = function (t) {\n    function e() {\n      t.call(this), this._si = null;\n      var e = arguments[0];\n      this._si = e;\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.overlap = function () {\n      if (4 !== arguments.length) return t.prototype.overlap.apply(this, arguments);\n      var e = arguments[0],\n          n = arguments[1],\n          i = arguments[2],\n          r = arguments[3],\n          o = e.getContext(),\n          s = i.getContext();\n\n      this._si.processIntersections(o, n, s, r);\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e;\n  }(_n),\n      Cn = function t() {\n    if (this._quadrantSegments = t.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = t.CAP_ROUND, this._joinStyle = t.JOIN_ROUND, this._mitreLimit = t.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = t.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length) ;else if (1 === arguments.length) {\n      var e = arguments[0];\n      this.setQuadrantSegments(e);\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1];\n      this.setQuadrantSegments(n), this.setEndCapStyle(i);\n    } else if (4 === arguments.length) {\n      var r = arguments[0],\n          o = arguments[1],\n          s = arguments[2],\n          a = arguments[3];\n      this.setQuadrantSegments(r), this.setEndCapStyle(o), this.setJoinStyle(s), this.setMitreLimit(a);\n    }\n  },\n      Sn = {\n    CAP_ROUND: {\n      configurable: !0\n    },\n    CAP_FLAT: {\n      configurable: !0\n    },\n    CAP_SQUARE: {\n      configurable: !0\n    },\n    JOIN_ROUND: {\n      configurable: !0\n    },\n    JOIN_MITRE: {\n      configurable: !0\n    },\n    JOIN_BEVEL: {\n      configurable: !0\n    },\n    DEFAULT_QUADRANT_SEGMENTS: {\n      configurable: !0\n    },\n    DEFAULT_MITRE_LIMIT: {\n      configurable: !0\n    },\n    DEFAULT_SIMPLIFY_FACTOR: {\n      configurable: !0\n    }\n  };\n\n  Cn.prototype.getEndCapStyle = function () {\n    return this._endCapStyle;\n  }, Cn.prototype.isSingleSided = function () {\n    return this._isSingleSided;\n  }, Cn.prototype.setQuadrantSegments = function (t) {\n    this._quadrantSegments = t, 0 === this._quadrantSegments && (this._joinStyle = Cn.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = Cn.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t <= 0 && (this._quadrantSegments = 1), this._joinStyle !== Cn.JOIN_ROUND && (this._quadrantSegments = Cn.DEFAULT_QUADRANT_SEGMENTS);\n  }, Cn.prototype.getJoinStyle = function () {\n    return this._joinStyle;\n  }, Cn.prototype.setJoinStyle = function (t) {\n    this._joinStyle = t;\n  }, Cn.prototype.setSimplifyFactor = function (t) {\n    this._simplifyFactor = t < 0 ? 0 : t;\n  }, Cn.prototype.getSimplifyFactor = function () {\n    return this._simplifyFactor;\n  }, Cn.prototype.getQuadrantSegments = function () {\n    return this._quadrantSegments;\n  }, Cn.prototype.setEndCapStyle = function (t) {\n    this._endCapStyle = t;\n  }, Cn.prototype.getMitreLimit = function () {\n    return this._mitreLimit;\n  }, Cn.prototype.setMitreLimit = function (t) {\n    this._mitreLimit = t;\n  }, Cn.prototype.setSingleSided = function (t) {\n    this._isSingleSided = t;\n  }, Cn.prototype.interfaces_ = function () {\n    return [];\n  }, Cn.prototype.getClass = function () {\n    return Cn;\n  }, Cn.bufferDistanceError = function (t) {\n    var e = Math.PI / 2 / t;\n    return 1 - Math.cos(e / 2);\n  }, Sn.CAP_ROUND.get = function () {\n    return 1;\n  }, Sn.CAP_FLAT.get = function () {\n    return 2;\n  }, Sn.CAP_SQUARE.get = function () {\n    return 3;\n  }, Sn.JOIN_ROUND.get = function () {\n    return 1;\n  }, Sn.JOIN_MITRE.get = function () {\n    return 2;\n  }, Sn.JOIN_BEVEL.get = function () {\n    return 3;\n  }, Sn.DEFAULT_QUADRANT_SEGMENTS.get = function () {\n    return 8;\n  }, Sn.DEFAULT_MITRE_LIMIT.get = function () {\n    return 5;\n  }, Sn.DEFAULT_SIMPLIFY_FACTOR.get = function () {\n    return .01;\n  }, Object.defineProperties(Cn, Sn);\n\n  var Ln = function (t) {\n    this._distanceTol = null, this._isDeleted = null, this._angleOrientation = at.COUNTERCLOCKWISE, this._inputLine = t || null;\n  },\n      bn = {\n    INIT: {\n      configurable: !0\n    },\n    DELETE: {\n      configurable: !0\n    },\n    KEEP: {\n      configurable: !0\n    },\n    NUM_PTS_TO_CHECK: {\n      configurable: !0\n    }\n  };\n\n  Ln.prototype.isDeletable = function (t, e, n, i) {\n    var r = this._inputLine[t],\n        o = this._inputLine[e],\n        s = this._inputLine[n];\n    return !!this.isConcave(r, o, s) && !!this.isShallow(r, o, s, i) && this.isShallowSampled(r, o, t, n, i);\n  }, Ln.prototype.deleteShallowConcavities = function () {\n    for (var t = 1, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e), i = !1; n < this._inputLine.length;) {\n      var r = !1;\n      this.isDeletable(t, e, n, this._distanceTol) && (this._isDeleted[e] = Ln.DELETE, r = !0, i = !0), t = r ? n : e, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e);\n    }\n\n    return i;\n  }, Ln.prototype.isShallowConcavity = function (t, e, n, i) {\n    if (!(at.computeOrientation(t, e, n) === this._angleOrientation)) return !1;\n    return at.distancePointLine(e, t, n) < i;\n  }, Ln.prototype.isShallowSampled = function (t, e, n, i, r) {\n    var o = Math.trunc((i - n) / Ln.NUM_PTS_TO_CHECK);\n    o <= 0 && (o = 1);\n\n    for (var s = n; s < i; s += o) if (!this.isShallow(t, e, this._inputLine[s], r)) return !1;\n\n    return !0;\n  }, Ln.prototype.isConcave = function (t, e, n) {\n    var i = at.computeOrientation(t, e, n) === this._angleOrientation;\n\n    return i;\n  }, Ln.prototype.simplify = function (t) {\n    this._distanceTol = Math.abs(t), t < 0 && (this._angleOrientation = at.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);\n    var e = !1;\n\n    do {\n      e = this.deleteShallowConcavities();\n    } while (e);\n\n    return this.collapseLine();\n  }, Ln.prototype.findNextNonDeletedIndex = function (t) {\n    for (var e = t + 1; e < this._inputLine.length && this._isDeleted[e] === Ln.DELETE;) e++;\n\n    return e;\n  }, Ln.prototype.isShallow = function (t, e, n, i) {\n    return at.distancePointLine(e, t, n) < i;\n  }, Ln.prototype.collapseLine = function () {\n    for (var t = new St(), e = 0; e < this._inputLine.length; e++) this._isDeleted[e] !== Ln.DELETE && t.add(this._inputLine[e]);\n\n    return t.toCoordinateArray();\n  }, Ln.prototype.interfaces_ = function () {\n    return [];\n  }, Ln.prototype.getClass = function () {\n    return Ln;\n  }, Ln.simplify = function (t, e) {\n    return new Ln(t).simplify(e);\n  }, bn.INIT.get = function () {\n    return 0;\n  }, bn.DELETE.get = function () {\n    return 1;\n  }, bn.KEEP.get = function () {\n    return 1;\n  }, bn.NUM_PTS_TO_CHECK.get = function () {\n    return 10;\n  }, Object.defineProperties(Ln, bn);\n\n  var wn = function () {\n    this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new Nt();\n  },\n      On = {\n    COORDINATE_ARRAY_TYPE: {\n      configurable: !0\n    }\n  };\n\n  wn.prototype.getCoordinates = function () {\n    return this._ptList.toArray(wn.COORDINATE_ARRAY_TYPE);\n  }, wn.prototype.setPrecisionModel = function (t) {\n    this._precisionModel = t;\n  }, wn.prototype.addPt = function (t) {\n    var e = new C(t);\n    if (this._precisionModel.makePrecise(e), this.isRedundant(e)) return null;\n\n    this._ptList.add(e);\n  }, wn.prototype.revere = function () {}, wn.prototype.addPts = function (t, e) {\n    if (e) for (var n = 0; n < t.length; n++) this.addPt(t[n]);else for (var i = t.length - 1; i >= 0; i--) this.addPt(t[i]);\n  }, wn.prototype.isRedundant = function (t) {\n    if (this._ptList.size() < 1) return !1;\n\n    var e = this._ptList.get(this._ptList.size() - 1);\n\n    return t.distance(e) < this._minimimVertexDistance;\n  }, wn.prototype.toString = function () {\n    return new _e().createLineString(this.getCoordinates()).toString();\n  }, wn.prototype.closeRing = function () {\n    if (this._ptList.size() < 1) return null;\n\n    var t = new C(this._ptList.get(0)),\n        e = this._ptList.get(this._ptList.size() - 1);\n\n    if (t.equals(e)) return null;\n\n    this._ptList.add(t);\n  }, wn.prototype.setMinimumVertexDistance = function (t) {\n    this._minimimVertexDistance = t;\n  }, wn.prototype.interfaces_ = function () {\n    return [];\n  }, wn.prototype.getClass = function () {\n    return wn;\n  }, On.COORDINATE_ARRAY_TYPE.get = function () {\n    return new Array(0).fill(null);\n  }, Object.defineProperties(wn, On);\n\n  var Tn = function () {},\n      Rn = {\n    PI_TIMES_2: {\n      configurable: !0\n    },\n    PI_OVER_2: {\n      configurable: !0\n    },\n    PI_OVER_4: {\n      configurable: !0\n    },\n    COUNTERCLOCKWISE: {\n      configurable: !0\n    },\n    CLOCKWISE: {\n      configurable: !0\n    },\n    NONE: {\n      configurable: !0\n    }\n  };\n\n  Tn.prototype.interfaces_ = function () {\n    return [];\n  }, Tn.prototype.getClass = function () {\n    return Tn;\n  }, Tn.toDegrees = function (t) {\n    return 180 * t / Math.PI;\n  }, Tn.normalize = function (t) {\n    for (; t > Math.PI;) t -= Tn.PI_TIMES_2;\n\n    for (; t <= -Math.PI;) t += Tn.PI_TIMES_2;\n\n    return t;\n  }, Tn.angle = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return Math.atan2(t.y, t.x);\n    }\n\n    if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1],\n          i = n.x - e.x,\n          r = n.y - e.y;\n      return Math.atan2(r, i);\n    }\n  }, Tn.isAcute = function (t, e, n) {\n    var i = t.x - e.x,\n        r = t.y - e.y;\n    return i * (n.x - e.x) + r * (n.y - e.y) > 0;\n  }, Tn.isObtuse = function (t, e, n) {\n    var i = t.x - e.x,\n        r = t.y - e.y;\n    return i * (n.x - e.x) + r * (n.y - e.y) < 0;\n  }, Tn.interiorAngle = function (t, e, n) {\n    var i = Tn.angle(e, t),\n        r = Tn.angle(e, n);\n    return Math.abs(r - i);\n  }, Tn.normalizePositive = function (t) {\n    if (t < 0) {\n      for (; t < 0;) t += Tn.PI_TIMES_2;\n\n      t >= Tn.PI_TIMES_2 && (t = 0);\n    } else {\n      for (; t >= Tn.PI_TIMES_2;) t -= Tn.PI_TIMES_2;\n\n      t < 0 && (t = 0);\n    }\n\n    return t;\n  }, Tn.angleBetween = function (t, e, n) {\n    var i = Tn.angle(e, t),\n        r = Tn.angle(e, n);\n    return Tn.diff(i, r);\n  }, Tn.diff = function (t, e) {\n    var n = null;\n    return (n = t < e ? e - t : t - e) > Math.PI && (n = 2 * Math.PI - n), n;\n  }, Tn.toRadians = function (t) {\n    return t * Math.PI / 180;\n  }, Tn.getTurn = function (t, e) {\n    var n = Math.sin(e - t);\n    return n > 0 ? Tn.COUNTERCLOCKWISE : n < 0 ? Tn.CLOCKWISE : Tn.NONE;\n  }, Tn.angleBetweenOriented = function (t, e, n) {\n    var i = Tn.angle(e, t),\n        r = Tn.angle(e, n) - i;\n    return r <= -Math.PI ? r + Tn.PI_TIMES_2 : r > Math.PI ? r - Tn.PI_TIMES_2 : r;\n  }, Rn.PI_TIMES_2.get = function () {\n    return 2 * Math.PI;\n  }, Rn.PI_OVER_2.get = function () {\n    return Math.PI / 2;\n  }, Rn.PI_OVER_4.get = function () {\n    return Math.PI / 4;\n  }, Rn.COUNTERCLOCKWISE.get = function () {\n    return at.COUNTERCLOCKWISE;\n  }, Rn.CLOCKWISE.get = function () {\n    return at.CLOCKWISE;\n  }, Rn.NONE.get = function () {\n    return at.COLLINEAR;\n  }, Object.defineProperties(Tn, Rn);\n\n  var Pn = function t() {\n    this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new dn(), this._seg1 = new dn(), this._offset0 = new dn(), this._offset1 = new dn(), this._side = 0, this._hasNarrowConcaveAngle = !1;\n    var e = arguments[0],\n        n = arguments[1],\n        i = arguments[2];\n    this._precisionModel = e, this._bufParams = n, this._li = new rt(), this._filletAngleQuantum = Math.PI / 2 / n.getQuadrantSegments(), n.getQuadrantSegments() >= 8 && n.getJoinStyle() === Cn.JOIN_ROUND && (this._closingSegLengthFactor = t.MAX_CLOSING_SEG_LEN_FACTOR), this.init(i);\n  },\n      Dn = {\n    OFFSET_SEGMENT_SEPARATION_FACTOR: {\n      configurable: !0\n    },\n    INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: {\n      configurable: !0\n    },\n    CURVE_VERTEX_SNAP_DISTANCE_FACTOR: {\n      configurable: !0\n    },\n    MAX_CLOSING_SEG_LEN_FACTOR: {\n      configurable: !0\n    }\n  };\n\n  Pn.prototype.addNextSegment = function (t, e) {\n    if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;\n    var n = at.computeOrientation(this._s0, this._s1, this._s2),\n        i = n === at.CLOCKWISE && this._side === Se.LEFT || n === at.COUNTERCLOCKWISE && this._side === Se.RIGHT;\n    0 === n ? this.addCollinear(e) : i ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e);\n  }, Pn.prototype.addLineEndCap = function (t, e) {\n    var n = new dn(t, e),\n        i = new dn();\n    this.computeOffsetSegment(n, Se.LEFT, this._distance, i);\n    var r = new dn();\n    this.computeOffsetSegment(n, Se.RIGHT, this._distance, r);\n    var o = e.x - t.x,\n        s = e.y - t.y,\n        a = Math.atan2(s, o);\n\n    switch (this._bufParams.getEndCapStyle()) {\n      case Cn.CAP_ROUND:\n        this._segList.addPt(i.p1), this.addFilletArc(e, a + Math.PI / 2, a - Math.PI / 2, at.CLOCKWISE, this._distance), this._segList.addPt(r.p1);\n        break;\n\n      case Cn.CAP_FLAT:\n        this._segList.addPt(i.p1), this._segList.addPt(r.p1);\n        break;\n\n      case Cn.CAP_SQUARE:\n        var u = new C();\n        u.x = Math.abs(this._distance) * Math.cos(a), u.y = Math.abs(this._distance) * Math.sin(a);\n        var l = new C(i.p1.x + u.x, i.p1.y + u.y),\n            c = new C(r.p1.x + u.x, r.p1.y + u.y);\n        this._segList.addPt(l), this._segList.addPt(c);\n    }\n  }, Pn.prototype.getCoordinates = function () {\n    return this._segList.getCoordinates();\n  }, Pn.prototype.addMitreJoin = function (t, e, n, i) {\n    var r = !0,\n        o = null;\n\n    try {\n      o = k.intersection(e.p0, e.p1, n.p0, n.p1);\n      (i <= 0 ? 1 : o.distance(t) / Math.abs(i)) > this._bufParams.getMitreLimit() && (r = !1);\n    } catch (t) {\n      if (!(t instanceof X)) throw t;\n      o = new C(0, 0), r = !1;\n    }\n\n    r ? this._segList.addPt(o) : this.addLimitedMitreJoin(e, n, i, this._bufParams.getMitreLimit());\n  }, Pn.prototype.addFilletCorner = function (t, e, n, i, r) {\n    var o = e.x - t.x,\n        s = e.y - t.y,\n        a = Math.atan2(s, o),\n        u = n.x - t.x,\n        l = n.y - t.y,\n        c = Math.atan2(l, u);\n    i === at.CLOCKWISE ? a <= c && (a += 2 * Math.PI) : a >= c && (a -= 2 * Math.PI), this._segList.addPt(e), this.addFilletArc(t, a, c, i, r), this._segList.addPt(n);\n  }, Pn.prototype.addOutsideTurn = function (t, e) {\n    if (this._offset0.p1.distance(this._offset1.p0) < this._distance * Pn.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;\n    this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (e && this._segList.addPt(this._offset0.p1), this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, t, this._distance), this._segList.addPt(this._offset1.p0));\n  }, Pn.prototype.createSquare = function (t) {\n    this._segList.addPt(new C(t.x + this._distance, t.y + this._distance)), this._segList.addPt(new C(t.x + this._distance, t.y - this._distance)), this._segList.addPt(new C(t.x - this._distance, t.y - this._distance)), this._segList.addPt(new C(t.x - this._distance, t.y + this._distance)), this._segList.closeRing();\n  }, Pn.prototype.addSegments = function (t, e) {\n    this._segList.addPts(t, e);\n  }, Pn.prototype.addFirstSegment = function () {\n    this._segList.addPt(this._offset1.p0);\n  }, Pn.prototype.addLastSegment = function () {\n    this._segList.addPt(this._offset1.p1);\n  }, Pn.prototype.initSideSegments = function (t, e, n) {\n    this._s1 = t, this._s2 = e, this._side = n, this._seg1.setCoordinates(t, e), this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1);\n  }, Pn.prototype.addLimitedMitreJoin = function (t, e, n, i) {\n    var r = this._seg0.p1,\n        o = Tn.angle(r, this._seg0.p0),\n        s = Tn.angleBetweenOriented(this._seg0.p0, r, this._seg1.p1) / 2,\n        a = Tn.normalize(o + s),\n        u = Tn.normalize(a + Math.PI),\n        l = i * n,\n        c = n - l * Math.abs(Math.sin(s)),\n        p = r.x + l * Math.cos(u),\n        h = r.y + l * Math.sin(u),\n        f = new C(p, h),\n        g = new dn(r, f),\n        d = g.pointAlongOffset(1, c),\n        y = g.pointAlongOffset(1, -c);\n    this._side === Se.LEFT ? (this._segList.addPt(d), this._segList.addPt(y)) : (this._segList.addPt(y), this._segList.addPt(d));\n  }, Pn.prototype.computeOffsetSegment = function (t, e, n, i) {\n    var r = e === Se.LEFT ? 1 : -1,\n        o = t.p1.x - t.p0.x,\n        s = t.p1.y - t.p0.y,\n        a = Math.sqrt(o * o + s * s),\n        u = r * n * o / a,\n        l = r * n * s / a;\n    i.p0.x = t.p0.x - l, i.p0.y = t.p0.y + u, i.p1.x = t.p1.x - l, i.p1.y = t.p1.y + u;\n  }, Pn.prototype.addFilletArc = function (t, e, n, i, r) {\n    var o = i === at.CLOCKWISE ? -1 : 1,\n        s = Math.abs(e - n),\n        a = Math.trunc(s / this._filletAngleQuantum + .5);\n    if (a < 1) return null;\n\n    for (var u = s / a, l = 0, c = new C(); l < s;) {\n      var p = e + o * l;\n      c.x = t.x + r * Math.cos(p), c.y = t.y + r * Math.sin(p), this._segList.addPt(c), l += u;\n    }\n  }, Pn.prototype.addInsideTurn = function (t, e) {\n    if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * Pn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);else {\n      if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {\n        var n = new C((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n\n        this._segList.addPt(n);\n\n        var i = new C((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n\n        this._segList.addPt(i);\n      } else this._segList.addPt(this._s1);\n\n      this._segList.addPt(this._offset1.p0);\n    }\n  }, Pn.prototype.createCircle = function (t) {\n    var e = new C(t.x + this._distance, t.y);\n    this._segList.addPt(e), this.addFilletArc(t, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();\n  }, Pn.prototype.addBevelJoin = function (t, e) {\n    this._segList.addPt(t.p1), this._segList.addPt(e.p0);\n  }, Pn.prototype.init = function (t) {\n    this._distance = t, this._maxCurveSegmentError = t * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new wn(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t * Pn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);\n  }, Pn.prototype.addCollinear = function (t) {\n    this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);\n\n    this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL || this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? (t && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, at.CLOCKWISE, this._distance));\n  }, Pn.prototype.closeRing = function () {\n    this._segList.closeRing();\n  }, Pn.prototype.hasNarrowConcaveAngle = function () {\n    return this._hasNarrowConcaveAngle;\n  }, Pn.prototype.interfaces_ = function () {\n    return [];\n  }, Pn.prototype.getClass = function () {\n    return Pn;\n  }, Dn.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function () {\n    return .001;\n  }, Dn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function () {\n    return .001;\n  }, Dn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function () {\n    return 1e-6;\n  }, Dn.MAX_CLOSING_SEG_LEN_FACTOR.get = function () {\n    return 80;\n  }, Object.defineProperties(Pn, Dn);\n\n  var Mn = function () {\n    this._distance = 0, this._precisionModel = null, this._bufParams = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this._precisionModel = t, this._bufParams = e;\n  };\n\n  Mn.prototype.getOffsetCurve = function (t, e) {\n    if (this._distance = e, 0 === e) return null;\n    var n = e < 0,\n        i = Math.abs(e),\n        r = this.getSegGen(i);\n    t.length <= 1 ? this.computePointCurve(t[0], r) : this.computeOffsetCurve(t, n, r);\n    var o = r.getCoordinates();\n    return n && Lt.reverse(o), o;\n  }, Mn.prototype.computeSingleSidedBufferCurve = function (t, e, n) {\n    var i = this.simplifyTolerance(this._distance);\n\n    if (e) {\n      n.addSegments(t, !0);\n      var r = Ln.simplify(t, -i),\n          o = r.length - 1;\n      n.initSideSegments(r[o], r[o - 1], Se.LEFT), n.addFirstSegment();\n\n      for (var s = o - 2; s >= 0; s--) n.addNextSegment(r[s], !0);\n    } else {\n      n.addSegments(t, !1);\n      var a = Ln.simplify(t, i),\n          u = a.length - 1;\n      n.initSideSegments(a[0], a[1], Se.LEFT), n.addFirstSegment();\n\n      for (var l = 2; l <= u; l++) n.addNextSegment(a[l], !0);\n    }\n\n    n.addLastSegment(), n.closeRing();\n  }, Mn.prototype.computeRingBufferCurve = function (t, e, n) {\n    var i = this.simplifyTolerance(this._distance);\n    e === Se.RIGHT && (i = -i);\n    var r = Ln.simplify(t, i),\n        o = r.length - 1;\n    n.initSideSegments(r[o - 1], r[0], e);\n\n    for (var s = 1; s <= o; s++) {\n      var a = 1 !== s;\n      n.addNextSegment(r[s], a);\n    }\n\n    n.closeRing();\n  }, Mn.prototype.computeLineBufferCurve = function (t, e) {\n    var n = this.simplifyTolerance(this._distance),\n        i = Ln.simplify(t, n),\n        r = i.length - 1;\n    e.initSideSegments(i[0], i[1], Se.LEFT);\n\n    for (var o = 2; o <= r; o++) e.addNextSegment(i[o], !0);\n\n    e.addLastSegment(), e.addLineEndCap(i[r - 1], i[r]);\n    var s = Ln.simplify(t, -n),\n        a = s.length - 1;\n    e.initSideSegments(s[a], s[a - 1], Se.LEFT);\n\n    for (var u = a - 2; u >= 0; u--) e.addNextSegment(s[u], !0);\n\n    e.addLastSegment(), e.addLineEndCap(s[1], s[0]), e.closeRing();\n  }, Mn.prototype.computePointCurve = function (t, e) {\n    switch (this._bufParams.getEndCapStyle()) {\n      case Cn.CAP_ROUND:\n        e.createCircle(t);\n        break;\n\n      case Cn.CAP_SQUARE:\n        e.createSquare(t);\n    }\n  }, Mn.prototype.getLineCurve = function (t, e) {\n    if (this._distance = e, e < 0 && !this._bufParams.isSingleSided()) return null;\n    if (0 === e) return null;\n    var n = Math.abs(e),\n        i = this.getSegGen(n);\n    if (t.length <= 1) this.computePointCurve(t[0], i);else if (this._bufParams.isSingleSided()) {\n      var r = e < 0;\n      this.computeSingleSidedBufferCurve(t, r, i);\n    } else this.computeLineBufferCurve(t, i);\n    return i.getCoordinates();\n  }, Mn.prototype.getBufferParameters = function () {\n    return this._bufParams;\n  }, Mn.prototype.simplifyTolerance = function (t) {\n    return t * this._bufParams.getSimplifyFactor();\n  }, Mn.prototype.getRingCurve = function (t, e, n) {\n    if (this._distance = n, t.length <= 2) return this.getLineCurve(t, n);\n    if (0 === n) return Mn.copyCoordinates(t);\n    var i = this.getSegGen(n);\n    return this.computeRingBufferCurve(t, e, i), i.getCoordinates();\n  }, Mn.prototype.computeOffsetCurve = function (t, e, n) {\n    var i = this.simplifyTolerance(this._distance);\n\n    if (e) {\n      var r = Ln.simplify(t, -i),\n          o = r.length - 1;\n      n.initSideSegments(r[o], r[o - 1], Se.LEFT), n.addFirstSegment();\n\n      for (var s = o - 2; s >= 0; s--) n.addNextSegment(r[s], !0);\n    } else {\n      var a = Ln.simplify(t, i),\n          u = a.length - 1;\n      n.initSideSegments(a[0], a[1], Se.LEFT), n.addFirstSegment();\n\n      for (var l = 2; l <= u; l++) n.addNextSegment(a[l], !0);\n    }\n\n    n.addLastSegment();\n  }, Mn.prototype.getSegGen = function (t) {\n    return new Pn(this._precisionModel, this._bufParams, t);\n  }, Mn.prototype.interfaces_ = function () {\n    return [];\n  }, Mn.prototype.getClass = function () {\n    return Mn;\n  }, Mn.copyCoordinates = function (t) {\n    for (var e = new Array(t.length).fill(null), n = 0; n < e.length; n++) e[n] = new C(t[n]);\n\n    return e;\n  };\n\n  var An = function () {\n    this._subgraphs = null, this._seg = new dn(), this._cga = new at();\n    var t = arguments[0];\n    this._subgraphs = t;\n  },\n      Fn = {\n    DepthSegment: {\n      configurable: !0\n    }\n  };\n\n  An.prototype.findStabbedSegments = function () {\n    if (1 === arguments.length) {\n      for (var t = arguments[0], e = new Nt(), n = this._subgraphs.iterator(); n.hasNext();) {\n        var i = n.next(),\n            r = i.getEnvelope();\n        t.y < r.getMinY() || t.y > r.getMaxY() || this.findStabbedSegments(t, i.getDirectedEdges(), e);\n      }\n\n      return e;\n    }\n\n    if (3 === arguments.length) if (T(arguments[2], xt) && arguments[0] instanceof C && arguments[1] instanceof ze) for (var o = arguments[0], s = arguments[1], a = arguments[2], u = s.getEdge().getCoordinates(), l = 0; l < u.length - 1; l++) {\n      this._seg.p0 = u[l], this._seg.p1 = u[l + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse();\n\n      if (!(Math.max(this._seg.p0.x, this._seg.p1.x) < o.x) && !(this._seg.isHorizontal() || o.y < this._seg.p0.y || o.y > this._seg.p1.y || at.computeOrientation(this._seg.p0, this._seg.p1, o) === at.RIGHT)) {\n        var c = s.getDepth(Se.LEFT);\n        this._seg.p0.equals(u[l]) || (c = s.getDepth(Se.RIGHT));\n        var p = new Gn(this._seg, c);\n        a.add(p);\n      }\n    } else if (T(arguments[2], xt) && arguments[0] instanceof C && T(arguments[1], xt)) for (var h = arguments[0], f = arguments[1], g = arguments[2], d = f.iterator(); d.hasNext();) {\n      var y = d.next();\n      y.isForward() && this.findStabbedSegments(h, y, g);\n    }\n  }, An.prototype.getDepth = function (t) {\n    var e = this.findStabbedSegments(t);\n    if (0 === e.size()) return 0;\n    return $e.min(e)._leftDepth;\n  }, An.prototype.interfaces_ = function () {\n    return [];\n  }, An.prototype.getClass = function () {\n    return An;\n  }, Fn.DepthSegment.get = function () {\n    return Gn;\n  }, Object.defineProperties(An, Fn);\n\n  var Gn = function () {\n    this._upwardSeg = null, this._leftDepth = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this._upwardSeg = new dn(t), this._leftDepth = e;\n  };\n\n  Gn.prototype.compareTo = function (t) {\n    var e = t;\n    if (this._upwardSeg.minX() >= e._upwardSeg.maxX()) return 1;\n    if (this._upwardSeg.maxX() <= e._upwardSeg.minX()) return -1;\n\n    var n = this._upwardSeg.orientationIndex(e._upwardSeg);\n\n    return 0 !== n ? n : 0 != (n = -1 * e._upwardSeg.orientationIndex(this._upwardSeg)) ? n : this._upwardSeg.compareTo(e._upwardSeg);\n  }, Gn.prototype.compareX = function (t, e) {\n    var n = t.p0.compareTo(e.p0);\n    return 0 !== n ? n : t.p1.compareTo(e.p1);\n  }, Gn.prototype.toString = function () {\n    return this._upwardSeg.toString();\n  }, Gn.prototype.interfaces_ = function () {\n    return [E];\n  }, Gn.prototype.getClass = function () {\n    return Gn;\n  };\n\n  var qn = function (t, e, n) {\n    this.p0 = t || null, this.p1 = e || null, this.p2 = n || null;\n  };\n\n  qn.prototype.area = function () {\n    return qn.area(this.p0, this.p1, this.p2);\n  }, qn.prototype.signedArea = function () {\n    return qn.signedArea(this.p0, this.p1, this.p2);\n  }, qn.prototype.interpolateZ = function (t) {\n    if (null === t) throw new m(\"Supplied point is null.\");\n    return qn.interpolateZ(t, this.p0, this.p1, this.p2);\n  }, qn.prototype.longestSideLength = function () {\n    return qn.longestSideLength(this.p0, this.p1, this.p2);\n  }, qn.prototype.isAcute = function () {\n    return qn.isAcute(this.p0, this.p1, this.p2);\n  }, qn.prototype.circumcentre = function () {\n    return qn.circumcentre(this.p0, this.p1, this.p2);\n  }, qn.prototype.area3D = function () {\n    return qn.area3D(this.p0, this.p1, this.p2);\n  }, qn.prototype.centroid = function () {\n    return qn.centroid(this.p0, this.p1, this.p2);\n  }, qn.prototype.inCentre = function () {\n    return qn.inCentre(this.p0, this.p1, this.p2);\n  }, qn.prototype.interfaces_ = function () {\n    return [];\n  }, qn.prototype.getClass = function () {\n    return qn;\n  }, qn.area = function (t, e, n) {\n    return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2);\n  }, qn.signedArea = function (t, e, n) {\n    return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2;\n  }, qn.det = function (t, e, n, i) {\n    return t * i - e * n;\n  }, qn.interpolateZ = function (t, e, n, i) {\n    var r = e.x,\n        o = e.y,\n        s = n.x - r,\n        a = i.x - r,\n        u = n.y - o,\n        l = i.y - o,\n        c = s * l - a * u,\n        p = t.x - r,\n        h = t.y - o,\n        f = (l * p - a * h) / c,\n        g = (-u * p + s * h) / c;\n    return e.z + f * (n.z - e.z) + g * (i.z - e.z);\n  }, qn.longestSideLength = function (t, e, n) {\n    var i = t.distance(e),\n        r = e.distance(n),\n        o = n.distance(t),\n        s = i;\n    return r > s && (s = r), o > s && (s = o), s;\n  }, qn.isAcute = function (t, e, n) {\n    return !!Tn.isAcute(t, e, n) && !!Tn.isAcute(e, n, t) && !!Tn.isAcute(n, t, e);\n  }, qn.circumcentre = function (t, e, n) {\n    var i = n.x,\n        r = n.y,\n        o = t.x - i,\n        s = t.y - r,\n        a = e.x - i,\n        u = e.y - r,\n        l = 2 * qn.det(o, s, a, u),\n        c = qn.det(s, o * o + s * s, u, a * a + u * u),\n        p = qn.det(o, o * o + s * s, a, a * a + u * u);\n    return new C(i - c / l, r + p / l);\n  }, qn.perpendicularBisector = function (t, e) {\n    var n = e.x - t.x,\n        i = e.y - t.y,\n        r = new k(t.x + n / 2, t.y + i / 2, 1),\n        o = new k(t.x - i + n / 2, t.y + n + i / 2, 1);\n    return new k(r, o);\n  }, qn.angleBisector = function (t, e, n) {\n    var i = e.distance(t),\n        r = i / (i + e.distance(n)),\n        o = n.x - t.x,\n        s = n.y - t.y;\n    return new C(t.x + r * o, t.y + r * s);\n  }, qn.area3D = function (t, e, n) {\n    var i = e.x - t.x,\n        r = e.y - t.y,\n        o = e.z - t.z,\n        s = n.x - t.x,\n        a = n.y - t.y,\n        u = n.z - t.z,\n        l = r * u - o * a,\n        c = o * s - i * u,\n        p = i * a - r * s,\n        h = l * l + c * c + p * p,\n        f = Math.sqrt(h) / 2;\n    return f;\n  }, qn.centroid = function (t, e, n) {\n    var i = (t.x + e.x + n.x) / 3,\n        r = (t.y + e.y + n.y) / 3;\n    return new C(i, r);\n  }, qn.inCentre = function (t, e, n) {\n    var i = e.distance(n),\n        r = t.distance(n),\n        o = t.distance(e),\n        s = i + r + o,\n        a = (i * t.x + r * e.x + o * n.x) / s,\n        u = (i * t.y + r * e.y + o * n.y) / s;\n    return new C(a, u);\n  };\n\n  var Bn = function () {\n    this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new Nt();\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n    this._inputGeom = t, this._distance = e, this._curveBuilder = n;\n  };\n\n  Bn.prototype.addPoint = function (t) {\n    if (this._distance <= 0) return null;\n\n    var e = t.getCoordinates(),\n        n = this._curveBuilder.getLineCurve(e, this._distance);\n\n    this.addCurve(n, w.EXTERIOR, w.INTERIOR);\n  }, Bn.prototype.addPolygon = function (t) {\n    var e = this._distance,\n        n = Se.LEFT;\n    this._distance < 0 && (e = -this._distance, n = Se.RIGHT);\n    var i = t.getExteriorRing(),\n        r = Lt.removeRepeatedPoints(i.getCoordinates());\n    if (this._distance < 0 && this.isErodedCompletely(i, this._distance)) return null;\n    if (this._distance <= 0 && r.length < 3) return null;\n    this.addPolygonRing(r, e, n, w.EXTERIOR, w.INTERIOR);\n\n    for (var o = 0; o < t.getNumInteriorRing(); o++) {\n      var s = t.getInteriorRingN(o),\n          a = Lt.removeRepeatedPoints(s.getCoordinates());\n      this._distance > 0 && this.isErodedCompletely(s, -this._distance) || this.addPolygonRing(a, e, Se.opposite(n), w.INTERIOR, w.EXTERIOR);\n    }\n  }, Bn.prototype.isTriangleErodedCompletely = function (t, e) {\n    var n = new qn(t[0], t[1], t[2]),\n        i = n.inCentre();\n    return at.distancePointLine(i, n.p0, n.p1) < Math.abs(e);\n  }, Bn.prototype.addLineString = function (t) {\n    if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided()) return null;\n\n    var e = Lt.removeRepeatedPoints(t.getCoordinates()),\n        n = this._curveBuilder.getLineCurve(e, this._distance);\n\n    this.addCurve(n, w.EXTERIOR, w.INTERIOR);\n  }, Bn.prototype.addCurve = function (t, e, n) {\n    if (null === t || t.length < 2) return null;\n    var i = new gn(t, new Pe(0, w.BOUNDARY, e, n));\n\n    this._curveList.add(i);\n  }, Bn.prototype.getCurves = function () {\n    return this.add(this._inputGeom), this._curveList;\n  }, Bn.prototype.addPolygonRing = function (t, e, n, i, r) {\n    if (0 === e && t.length < ee.MINIMUM_VALID_SIZE) return null;\n    var o = i,\n        s = r;\n    t.length >= ee.MINIMUM_VALID_SIZE && at.isCCW(t) && (o = r, s = i, n = Se.opposite(n));\n\n    var a = this._curveBuilder.getRingCurve(t, n, e);\n\n    this.addCurve(a, o, s);\n  }, Bn.prototype.add = function (t) {\n    if (t.isEmpty()) return null;\n    t instanceof $t ? this.addPolygon(t) : t instanceof Kt ? this.addLineString(t) : t instanceof Qt ? this.addPoint(t) : t instanceof te ? this.addCollection(t) : t instanceof Xt ? this.addCollection(t) : t instanceof ne ? this.addCollection(t) : t instanceof zt && this.addCollection(t);\n  }, Bn.prototype.isErodedCompletely = function (t, e) {\n    var n = t.getCoordinates();\n    if (n.length < 4) return e < 0;\n    if (4 === n.length) return this.isTriangleErodedCompletely(n, e);\n    var i = t.getEnvelopeInternal(),\n        r = Math.min(i.getHeight(), i.getWidth());\n    return e < 0 && 2 * Math.abs(e) > r;\n  }, Bn.prototype.addCollection = function (t) {\n    for (var e = 0; e < t.getNumGeometries(); e++) {\n      var n = t.getGeometryN(e);\n      this.add(n);\n    }\n  }, Bn.prototype.interfaces_ = function () {\n    return [];\n  }, Bn.prototype.getClass = function () {\n    return Bn;\n  };\n\n  var Vn = function () {};\n\n  Vn.prototype.locate = function (t) {}, Vn.prototype.interfaces_ = function () {\n    return [];\n  }, Vn.prototype.getClass = function () {\n    return Vn;\n  };\n\n  var Un = function () {\n    this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;\n    var t = arguments[0];\n    this._parent = t, this._atStart = !0, this._index = 0, this._max = t.getNumGeometries();\n  };\n\n  Un.prototype.next = function () {\n    if (this._atStart) return this._atStart = !1, Un.isAtomic(this._parent) && this._index++, this._parent;\n\n    if (null !== this._subcollectionIterator) {\n      if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();\n      this._subcollectionIterator = null;\n    }\n\n    if (this._index >= this._max) throw new i();\n\n    var t = this._parent.getGeometryN(this._index++);\n\n    return t instanceof zt ? (this._subcollectionIterator = new Un(t), this._subcollectionIterator.next()) : t;\n  }, Un.prototype.remove = function () {\n    throw new Error(this.getClass().getName());\n  }, Un.prototype.hasNext = function () {\n    if (this._atStart) return !0;\n\n    if (null !== this._subcollectionIterator) {\n      if (this._subcollectionIterator.hasNext()) return !0;\n      this._subcollectionIterator = null;\n    }\n\n    return !(this._index >= this._max);\n  }, Un.prototype.interfaces_ = function () {\n    return [Et];\n  }, Un.prototype.getClass = function () {\n    return Un;\n  }, Un.isAtomic = function (t) {\n    return !(t instanceof zt);\n  };\n\n  var zn = function () {\n    this._geom = null;\n    var t = arguments[0];\n    this._geom = t;\n  };\n\n  zn.prototype.locate = function (t) {\n    return zn.locate(t, this._geom);\n  }, zn.prototype.interfaces_ = function () {\n    return [Vn];\n  }, zn.prototype.getClass = function () {\n    return zn;\n  }, zn.isPointInRing = function (t, e) {\n    return !!e.getEnvelopeInternal().intersects(t) && at.isPointInRing(t, e.getCoordinates());\n  }, zn.containsPointInPolygon = function (t, e) {\n    if (e.isEmpty()) return !1;\n    var n = e.getExteriorRing();\n    if (!zn.isPointInRing(t, n)) return !1;\n\n    for (var i = 0; i < e.getNumInteriorRing(); i++) {\n      var r = e.getInteriorRingN(i);\n      if (zn.isPointInRing(t, r)) return !1;\n    }\n\n    return !0;\n  }, zn.containsPoint = function (t, e) {\n    if (e instanceof $t) return zn.containsPointInPolygon(t, e);\n    if (e instanceof zt) for (var n = new Un(e); n.hasNext();) {\n      var i = n.next();\n      if (i !== e && zn.containsPoint(t, i)) return !0;\n    }\n    return !1;\n  }, zn.locate = function (t, e) {\n    return e.isEmpty() ? w.EXTERIOR : zn.containsPoint(t, e) ? w.INTERIOR : w.EXTERIOR;\n  };\n\n  var Xn = function () {\n    this._edgeMap = new p(), this._edgeList = null, this._ptInAreaLocation = [w.NONE, w.NONE];\n  };\n\n  Xn.prototype.getNextCW = function (t) {\n    this.getEdges();\n\n    var e = this._edgeList.indexOf(t),\n        n = e - 1;\n\n    return 0 === e && (n = this._edgeList.size() - 1), this._edgeList.get(n);\n  }, Xn.prototype.propagateSideLabels = function (t) {\n    for (var e = w.NONE, n = this.iterator(); n.hasNext();) {\n      var i = n.next().getLabel();\n      i.isArea(t) && i.getLocation(t, Se.LEFT) !== w.NONE && (e = i.getLocation(t, Se.LEFT));\n    }\n\n    if (e === w.NONE) return null;\n\n    for (var r = e, o = this.iterator(); o.hasNext();) {\n      var s = o.next(),\n          a = s.getLabel();\n\n      if (a.getLocation(t, Se.ON) === w.NONE && a.setLocation(t, Se.ON, r), a.isArea(t)) {\n        var u = a.getLocation(t, Se.LEFT),\n            l = a.getLocation(t, Se.RIGHT);\n\n        if (l !== w.NONE) {\n          if (l !== r) throw new we(\"side location conflict\", s.getCoordinate());\n          u === w.NONE && et.shouldNeverReachHere(\"found single null side (at \" + s.getCoordinate() + \")\"), r = u;\n        } else et.isTrue(a.getLocation(t, Se.LEFT) === w.NONE, \"found single null side\"), a.setLocation(t, Se.RIGHT, r), a.setLocation(t, Se.LEFT, r);\n      }\n    }\n  }, Xn.prototype.getCoordinate = function () {\n    var t = this.iterator();\n    if (!t.hasNext()) return null;\n    return t.next().getCoordinate();\n  }, Xn.prototype.print = function (t) {\n    Y.out.println(\"EdgeEndStar:   \" + this.getCoordinate());\n\n    for (var e = this.iterator(); e.hasNext();) {\n      e.next().print(t);\n    }\n  }, Xn.prototype.isAreaLabelsConsistent = function (t) {\n    return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);\n  }, Xn.prototype.checkAreaLabelsConsistent = function (t) {\n    var e = this.getEdges();\n    if (e.size() <= 0) return !0;\n    var n = e.size() - 1,\n        i = e.get(n).getLabel().getLocation(t, Se.LEFT);\n    et.isTrue(i !== w.NONE, \"Found unlabelled area edge\");\n\n    for (var r = i, o = this.iterator(); o.hasNext();) {\n      var s = o.next().getLabel();\n      et.isTrue(s.isArea(t), \"Found non-area edge\");\n      var a = s.getLocation(t, Se.LEFT),\n          u = s.getLocation(t, Se.RIGHT);\n      if (a === u) return !1;\n      if (u !== r) return !1;\n      r = a;\n    }\n\n    return !0;\n  }, Xn.prototype.findIndex = function (t) {\n    this.iterator();\n\n    for (var e = 0; e < this._edgeList.size(); e++) {\n      if (this._edgeList.get(e) === t) return e;\n    }\n\n    return -1;\n  }, Xn.prototype.iterator = function () {\n    return this.getEdges().iterator();\n  }, Xn.prototype.getEdges = function () {\n    return null === this._edgeList && (this._edgeList = new Nt(this._edgeMap.values())), this._edgeList;\n  }, Xn.prototype.getLocation = function (t, e, n) {\n    return this._ptInAreaLocation[t] === w.NONE && (this._ptInAreaLocation[t] = zn.locate(e, n[t].getGeometry())), this._ptInAreaLocation[t];\n  }, Xn.prototype.toString = function () {\n    var t = new D();\n    t.append(\"EdgeEndStar:   \" + this.getCoordinate()), t.append(\"\\n\");\n\n    for (var e = this.iterator(); e.hasNext();) {\n      var n = e.next();\n      t.append(n), t.append(\"\\n\");\n    }\n\n    return t.toString();\n  }, Xn.prototype.computeEdgeEndLabels = function (t) {\n    for (var e = this.iterator(); e.hasNext();) {\n      e.next().computeLabel(t);\n    }\n  }, Xn.prototype.computeLabelling = function (t) {\n    this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);\n\n    for (var e = [!1, !1], n = this.iterator(); n.hasNext();) for (var i = n.next().getLabel(), r = 0; r < 2; r++) i.isLine(r) && i.getLocation(r) === w.BOUNDARY && (e[r] = !0);\n\n    for (var o = this.iterator(); o.hasNext();) for (var s = o.next(), a = s.getLabel(), u = 0; u < 2; u++) if (a.isAnyNull(u)) {\n      var l = w.NONE;\n      if (e[u]) l = w.EXTERIOR;else {\n        var c = s.getCoordinate();\n        l = this.getLocation(u, c, t);\n      }\n      a.setAllLocationsIfNull(u, l);\n    }\n  }, Xn.prototype.getDegree = function () {\n    return this._edgeMap.size();\n  }, Xn.prototype.insertEdgeEnd = function (t, e) {\n    this._edgeMap.put(t, e), this._edgeList = null;\n  }, Xn.prototype.interfaces_ = function () {\n    return [];\n  }, Xn.prototype.getClass = function () {\n    return Xn;\n  };\n\n  var Yn = function (t) {\n    function e() {\n      t.call(this), this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.linkResultDirectedEdges = function () {\n      this.getResultAreaEdges();\n\n      for (var t = null, e = null, n = this._SCANNING_FOR_INCOMING, i = 0; i < this._resultAreaEdgeList.size(); i++) {\n        var r = this._resultAreaEdgeList.get(i),\n            o = r.getSym();\n\n        if (r.getLabel().isArea()) switch (null === t && r.isInResult() && (t = r), n) {\n          case this._SCANNING_FOR_INCOMING:\n            if (!o.isInResult()) continue;\n            e = o, n = this._LINKING_TO_OUTGOING;\n            break;\n\n          case this._LINKING_TO_OUTGOING:\n            if (!r.isInResult()) continue;\n            e.setNext(r), n = this._SCANNING_FOR_INCOMING;\n        }\n      }\n\n      if (n === this._LINKING_TO_OUTGOING) {\n        if (null === t) throw new we(\"no outgoing dirEdge found\", this.getCoordinate());\n        et.isTrue(t.isInResult(), \"unable to link last incoming dirEdge\"), e.setNext(t);\n      }\n    }, e.prototype.insert = function (t) {\n      var e = t;\n      this.insertEdgeEnd(e, e);\n    }, e.prototype.getRightmostEdge = function () {\n      var t = this.getEdges(),\n          e = t.size();\n      if (e < 1) return null;\n      var n = t.get(0);\n      if (1 === e) return n;\n      var i = t.get(e - 1),\n          r = n.getQuadrant(),\n          o = i.getQuadrant();\n      return Be.isNorthern(r) && Be.isNorthern(o) ? n : Be.isNorthern(r) || Be.isNorthern(o) ? 0 !== n.getDy() ? n : 0 !== i.getDy() ? i : (et.shouldNeverReachHere(\"found two horizontal edges incident on node\"), null) : i;\n    }, e.prototype.print = function (t) {\n      Y.out.println(\"DirectedEdgeStar: \" + this.getCoordinate());\n\n      for (var e = this.iterator(); e.hasNext();) {\n        var n = e.next();\n        t.print(\"out \"), n.print(t), t.println(), t.print(\"in \"), n.getSym().print(t), t.println();\n      }\n    }, e.prototype.getResultAreaEdges = function () {\n      if (null !== this._resultAreaEdgeList) return this._resultAreaEdgeList;\n      this._resultAreaEdgeList = new Nt();\n\n      for (var t = this.iterator(); t.hasNext();) {\n        var e = t.next();\n        (e.isInResult() || e.getSym().isInResult()) && this._resultAreaEdgeList.add(e);\n      }\n\n      return this._resultAreaEdgeList;\n    }, e.prototype.updateLabelling = function (t) {\n      for (var e = this.iterator(); e.hasNext();) {\n        var n = e.next().getLabel();\n        n.setAllLocationsIfNull(0, t.getLocation(0)), n.setAllLocationsIfNull(1, t.getLocation(1));\n      }\n    }, e.prototype.linkAllDirectedEdges = function () {\n      this.getEdges();\n\n      for (var t = null, e = null, n = this._edgeList.size() - 1; n >= 0; n--) {\n        var i = this._edgeList.get(n),\n            r = i.getSym();\n\n        null === e && (e = r), null !== t && r.setNext(t), t = i;\n      }\n\n      e.setNext(t);\n    }, e.prototype.computeDepths = function () {\n      if (1 === arguments.length) {\n        var t = arguments[0],\n            e = this.findIndex(t),\n            n = t.getDepth(Se.LEFT),\n            i = t.getDepth(Se.RIGHT),\n            r = this.computeDepths(e + 1, this._edgeList.size(), n);\n        if (this.computeDepths(0, e, r) !== i) throw new we(\"depth mismatch at \" + t.getCoordinate());\n      } else if (3 === arguments.length) {\n        for (var o = arguments[0], s = arguments[1], a = arguments[2], u = o; u < s; u++) {\n          var l = this._edgeList.get(u);\n\n          l.setEdgeDepths(Se.RIGHT, a), a = l.getDepth(Se.LEFT);\n        }\n\n        return a;\n      }\n    }, e.prototype.mergeSymLabels = function () {\n      for (var t = this.iterator(); t.hasNext();) {\n        var e = t.next();\n        e.getLabel().merge(e.getSym().getLabel());\n      }\n    }, e.prototype.linkMinimalDirectedEdges = function (t) {\n      for (var e = null, n = null, i = this._SCANNING_FOR_INCOMING, r = this._resultAreaEdgeList.size() - 1; r >= 0; r--) {\n        var o = this._resultAreaEdgeList.get(r),\n            s = o.getSym();\n\n        switch (null === e && o.getEdgeRing() === t && (e = o), i) {\n          case this._SCANNING_FOR_INCOMING:\n            if (s.getEdgeRing() !== t) continue;\n            n = s, i = this._LINKING_TO_OUTGOING;\n            break;\n\n          case this._LINKING_TO_OUTGOING:\n            if (o.getEdgeRing() !== t) continue;\n            n.setNextMin(o), i = this._SCANNING_FOR_INCOMING;\n        }\n      }\n\n      i === this._LINKING_TO_OUTGOING && (et.isTrue(null !== e, \"found null for first outgoing dirEdge\"), et.isTrue(e.getEdgeRing() === t, \"unable to link last incoming dirEdge\"), n.setNextMin(e));\n    }, e.prototype.getOutgoingDegree = function () {\n      if (0 === arguments.length) {\n        for (var t = 0, e = this.iterator(); e.hasNext();) {\n          e.next().isInResult() && t++;\n        }\n\n        return t;\n      }\n\n      if (1 === arguments.length) {\n        for (var n = arguments[0], i = 0, r = this.iterator(); r.hasNext();) {\n          r.next().getEdgeRing() === n && i++;\n        }\n\n        return i;\n      }\n    }, e.prototype.getLabel = function () {\n      return this._label;\n    }, e.prototype.findCoveredLineEdges = function () {\n      for (var t = w.NONE, e = this.iterator(); e.hasNext();) {\n        var n = e.next(),\n            i = n.getSym();\n\n        if (!n.isLineEdge()) {\n          if (n.isInResult()) {\n            t = w.INTERIOR;\n            break;\n          }\n\n          if (i.isInResult()) {\n            t = w.EXTERIOR;\n            break;\n          }\n        }\n      }\n\n      if (t === w.NONE) return null;\n\n      for (var r = t, o = this.iterator(); o.hasNext();) {\n        var s = o.next(),\n            a = s.getSym();\n        s.isLineEdge() ? s.getEdge().setCovered(r === w.INTERIOR) : (s.isInResult() && (r = w.EXTERIOR), a.isInResult() && (r = w.INTERIOR));\n      }\n    }, e.prototype.computeLabelling = function (e) {\n      t.prototype.computeLabelling.call(this, e), this._label = new Pe(w.NONE);\n\n      for (var n = this.iterator(); n.hasNext();) for (var i = n.next().getEdge().getLabel(), r = 0; r < 2; r++) {\n        var o = i.getLocation(r);\n        o !== w.INTERIOR && o !== w.BOUNDARY || this._label.setLocation(r, w.INTERIOR);\n      }\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e;\n  }(Xn),\n      kn = function (t) {\n    function e() {\n      t.apply(this, arguments);\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.createNode = function (t) {\n      return new Ge(t, new Yn());\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e;\n  }(Xe),\n      jn = function t() {\n    this._pts = null, this._orientation = null;\n    var e = arguments[0];\n    this._pts = e, this._orientation = t.orientation(e);\n  };\n\n  jn.prototype.compareTo = function (t) {\n    var e = t;\n    return jn.compareOriented(this._pts, this._orientation, e._pts, e._orientation);\n  }, jn.prototype.interfaces_ = function () {\n    return [E];\n  }, jn.prototype.getClass = function () {\n    return jn;\n  }, jn.orientation = function (t) {\n    return 1 === Lt.increasingDirection(t);\n  }, jn.compareOriented = function (t, e, n, i) {\n    for (var r = e ? 1 : -1, o = i ? 1 : -1, s = e ? t.length : -1, a = i ? n.length : -1, u = e ? 0 : t.length - 1, l = i ? 0 : n.length - 1;;) {\n      var c = t[u].compareTo(n[l]);\n      if (0 !== c) return c;\n      var p = (u += r) === s,\n          h = (l += o) === a;\n      if (p && !h) return -1;\n      if (!p && h) return 1;\n      if (p && h) return 0;\n    }\n  };\n\n  var Hn = function () {\n    this._edges = new Nt(), this._ocaMap = new p();\n  };\n\n  Hn.prototype.print = function (t) {\n    t.print(\"MULTILINESTRING ( \");\n\n    for (var e = 0; e < this._edges.size(); e++) {\n      var n = this._edges.get(e);\n\n      e > 0 && t.print(\",\"), t.print(\"(\");\n\n      for (var i = n.getCoordinates(), r = 0; r < i.length; r++) r > 0 && t.print(\",\"), t.print(i[r].x + \" \" + i[r].y);\n\n      t.println(\")\");\n    }\n\n    t.print(\")  \");\n  }, Hn.prototype.addAll = function (t) {\n    for (var e = t.iterator(); e.hasNext();) this.add(e.next());\n  }, Hn.prototype.findEdgeIndex = function (t) {\n    for (var e = 0; e < this._edges.size(); e++) if (this._edges.get(e).equals(t)) return e;\n\n    return -1;\n  }, Hn.prototype.iterator = function () {\n    return this._edges.iterator();\n  }, Hn.prototype.getEdges = function () {\n    return this._edges;\n  }, Hn.prototype.get = function (t) {\n    return this._edges.get(t);\n  }, Hn.prototype.findEqualEdge = function (t) {\n    var e = new jn(t.getCoordinates());\n    return this._ocaMap.get(e);\n  }, Hn.prototype.add = function (t) {\n    this._edges.add(t);\n\n    var e = new jn(t.getCoordinates());\n\n    this._ocaMap.put(e, t);\n  }, Hn.prototype.interfaces_ = function () {\n    return [];\n  }, Hn.prototype.getClass = function () {\n    return Hn;\n  };\n\n  var Wn = function () {};\n\n  Wn.prototype.processIntersections = function (t, e, n, i) {}, Wn.prototype.isDone = function () {}, Wn.prototype.interfaces_ = function () {\n    return [];\n  }, Wn.prototype.getClass = function () {\n    return Wn;\n  };\n\n  var Kn = function () {\n    this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;\n    var t = arguments[0];\n    this._li = t;\n  };\n\n  Kn.prototype.isTrivialIntersection = function (t, e, n, i) {\n    if (t === n && 1 === this._li.getIntersectionNum()) {\n      if (Kn.isAdjacentSegments(e, i)) return !0;\n\n      if (t.isClosed()) {\n        var r = t.size() - 1;\n        if (0 === e && i === r || 0 === i && e === r) return !0;\n      }\n    }\n\n    return !1;\n  }, Kn.prototype.getProperIntersectionPoint = function () {\n    return this._properIntersectionPoint;\n  }, Kn.prototype.hasProperInteriorIntersection = function () {\n    return this._hasProperInterior;\n  }, Kn.prototype.getLineIntersector = function () {\n    return this._li;\n  }, Kn.prototype.hasProperIntersection = function () {\n    return this._hasProper;\n  }, Kn.prototype.processIntersections = function (t, e, n, i) {\n    if (t === n && e === i) return null;\n    this.numTests++;\n    var r = t.getCoordinates()[e],\n        o = t.getCoordinates()[e + 1],\n        s = n.getCoordinates()[i],\n        a = n.getCoordinates()[i + 1];\n    this._li.computeIntersection(r, o, s, a), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)));\n  }, Kn.prototype.hasIntersection = function () {\n    return this._hasIntersection;\n  }, Kn.prototype.isDone = function () {\n    return !1;\n  }, Kn.prototype.hasInteriorIntersection = function () {\n    return this._hasInterior;\n  }, Kn.prototype.interfaces_ = function () {\n    return [Wn];\n  }, Kn.prototype.getClass = function () {\n    return Kn;\n  }, Kn.isAdjacentSegments = function (t, e) {\n    return 1 === Math.abs(t - e);\n  };\n\n  var Jn = function () {\n    this.coord = null, this.segmentIndex = null, this.dist = null;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n    this.coord = new C(t), this.segmentIndex = e, this.dist = n;\n  };\n\n  Jn.prototype.getSegmentIndex = function () {\n    return this.segmentIndex;\n  }, Jn.prototype.getCoordinate = function () {\n    return this.coord;\n  }, Jn.prototype.print = function (t) {\n    t.print(this.coord), t.print(\" seg # = \" + this.segmentIndex), t.println(\" dist = \" + this.dist);\n  }, Jn.prototype.compareTo = function (t) {\n    var e = t;\n    return this.compare(e.segmentIndex, e.dist);\n  }, Jn.prototype.isEndPoint = function (t) {\n    return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t;\n  }, Jn.prototype.toString = function () {\n    return this.coord + \" seg # = \" + this.segmentIndex + \" dist = \" + this.dist;\n  }, Jn.prototype.getDistance = function () {\n    return this.dist;\n  }, Jn.prototype.compare = function (t, e) {\n    return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0;\n  }, Jn.prototype.interfaces_ = function () {\n    return [E];\n  }, Jn.prototype.getClass = function () {\n    return Jn;\n  };\n\n  var Qn = function () {\n    this._nodeMap = new p(), this.edge = null;\n    var t = arguments[0];\n    this.edge = t;\n  };\n\n  Qn.prototype.print = function (t) {\n    t.println(\"Intersections:\");\n\n    for (var e = this.iterator(); e.hasNext();) {\n      e.next().print(t);\n    }\n  }, Qn.prototype.iterator = function () {\n    return this._nodeMap.values().iterator();\n  }, Qn.prototype.addSplitEdges = function (t) {\n    this.addEndpoints();\n\n    for (var e = this.iterator(), n = e.next(); e.hasNext();) {\n      var i = e.next(),\n          r = this.createSplitEdge(n, i);\n      t.add(r), n = i;\n    }\n  }, Qn.prototype.addEndpoints = function () {\n    var t = this.edge.pts.length - 1;\n    this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0);\n  }, Qn.prototype.createSplitEdge = function (t, e) {\n    var n = e.segmentIndex - t.segmentIndex + 2,\n        i = this.edge.pts[e.segmentIndex],\n        r = e.dist > 0 || !e.coord.equals2D(i);\n    r || n--;\n    var o = new Array(n).fill(null),\n        s = 0;\n    o[s++] = new C(t.coord);\n\n    for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) o[s++] = this.edge.pts[a];\n\n    return r && (o[s] = e.coord), new ni(o, new Pe(this.edge._label));\n  }, Qn.prototype.add = function (t, e, n) {\n    var i = new Jn(t, e, n),\n        r = this._nodeMap.get(i);\n\n    return null !== r ? r : (this._nodeMap.put(i, i), i);\n  }, Qn.prototype.isIntersection = function (t) {\n    for (var e = this.iterator(); e.hasNext();) {\n      if (e.next().coord.equals(t)) return !0;\n    }\n\n    return !1;\n  }, Qn.prototype.interfaces_ = function () {\n    return [];\n  }, Qn.prototype.getClass = function () {\n    return Qn;\n  };\n\n  var Zn = function () {};\n\n  Zn.prototype.getChainStartIndices = function (t) {\n    var e = 0,\n        n = new Nt();\n    n.add(new M(e));\n\n    do {\n      var i = this.findChainEnd(t, e);\n      n.add(new M(i)), e = i;\n    } while (e < t.length - 1);\n\n    return Zn.toIntArray(n);\n  }, Zn.prototype.findChainEnd = function (t, e) {\n    for (var n = Be.quadrant(t[e], t[e + 1]), i = e + 1; i < t.length;) {\n      if (Be.quadrant(t[i - 1], t[i]) !== n) break;\n      i++;\n    }\n\n    return i - 1;\n  }, Zn.prototype.interfaces_ = function () {\n    return [];\n  }, Zn.prototype.getClass = function () {\n    return Zn;\n  }, Zn.toIntArray = function (t) {\n    for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) e[n] = t.get(n).intValue();\n\n    return e;\n  };\n\n  var $n = function () {\n    this.e = null, this.pts = null, this.startIndex = null, this.env1 = new j(), this.env2 = new j();\n    var t = arguments[0];\n    this.e = t, this.pts = t.getCoordinates();\n    var e = new Zn();\n    this.startIndex = e.getChainStartIndices(this.pts);\n  };\n\n  $n.prototype.getCoordinates = function () {\n    return this.pts;\n  }, $n.prototype.getMaxX = function (t) {\n    var e = this.pts[this.startIndex[t]].x,\n        n = this.pts[this.startIndex[t + 1]].x;\n    return e > n ? e : n;\n  }, $n.prototype.getMinX = function (t) {\n    var e = this.pts[this.startIndex[t]].x,\n        n = this.pts[this.startIndex[t + 1]].x;\n    return e < n ? e : n;\n  }, $n.prototype.computeIntersectsForChain = function () {\n    if (4 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1],\n          n = arguments[2],\n          i = arguments[3];\n      this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], i);\n    } else if (6 === arguments.length) {\n      var r = arguments[0],\n          o = arguments[1],\n          s = arguments[2],\n          a = arguments[3],\n          u = arguments[4],\n          l = arguments[5],\n          c = this.pts[r],\n          p = this.pts[o],\n          h = s.pts[a],\n          f = s.pts[u];\n      if (o - r == 1 && u - a == 1) return l.addIntersections(this.e, r, s.e, a), null;\n      if (this.env1.init(c, p), this.env2.init(h, f), !this.env1.intersects(this.env2)) return null;\n      var g = Math.trunc((r + o) / 2),\n          d = Math.trunc((a + u) / 2);\n      r < g && (a < d && this.computeIntersectsForChain(r, g, s, a, d, l), d < u && this.computeIntersectsForChain(r, g, s, d, u, l)), g < o && (a < d && this.computeIntersectsForChain(g, o, s, a, d, l), d < u && this.computeIntersectsForChain(g, o, s, d, u, l));\n    }\n  }, $n.prototype.getStartIndexes = function () {\n    return this.startIndex;\n  }, $n.prototype.computeIntersects = function (t, e) {\n    for (var n = 0; n < this.startIndex.length - 1; n++) for (var i = 0; i < t.startIndex.length - 1; i++) this.computeIntersectsForChain(n, t, i, e);\n  }, $n.prototype.interfaces_ = function () {\n    return [];\n  }, $n.prototype.getClass = function () {\n    return $n;\n  };\n\n  var ti = function t() {\n    this._depth = Array(2).fill().map(function () {\n      return Array(3);\n    });\n\n    for (var e = 0; e < 2; e++) for (var n = 0; n < 3; n++) this._depth[e][n] = t.NULL_VALUE;\n  },\n      ei = {\n    NULL_VALUE: {\n      configurable: !0\n    }\n  };\n\n  ti.prototype.getDepth = function (t, e) {\n    return this._depth[t][e];\n  }, ti.prototype.setDepth = function (t, e, n) {\n    this._depth[t][e] = n;\n  }, ti.prototype.isNull = function () {\n    if (0 === arguments.length) {\n      for (var t = 0; t < 2; t++) for (var e = 0; e < 3; e++) if (this._depth[t][e] !== ti.NULL_VALUE) return !1;\n\n      return !0;\n    }\n\n    if (1 === arguments.length) {\n      var n = arguments[0];\n      return this._depth[n][1] === ti.NULL_VALUE;\n    }\n\n    if (2 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1];\n      return this._depth[i][r] === ti.NULL_VALUE;\n    }\n  }, ti.prototype.normalize = function () {\n    for (var t = 0; t < 2; t++) if (!this.isNull(t)) {\n      var e = this._depth[t][1];\n      this._depth[t][2] < e && (e = this._depth[t][2]), e < 0 && (e = 0);\n\n      for (var n = 1; n < 3; n++) {\n        var i = 0;\n        this._depth[t][n] > e && (i = 1), this._depth[t][n] = i;\n      }\n    }\n  }, ti.prototype.getDelta = function (t) {\n    return this._depth[t][Se.RIGHT] - this._depth[t][Se.LEFT];\n  }, ti.prototype.getLocation = function (t, e) {\n    return this._depth[t][e] <= 0 ? w.EXTERIOR : w.INTERIOR;\n  }, ti.prototype.toString = function () {\n    return \"A: \" + this._depth[0][1] + \",\" + this._depth[0][2] + \" B: \" + this._depth[1][1] + \",\" + this._depth[1][2];\n  }, ti.prototype.add = function () {\n    if (1 === arguments.length) for (var t = arguments[0], e = 0; e < 2; e++) for (var n = 1; n < 3; n++) {\n      var i = t.getLocation(e, n);\n      i !== w.EXTERIOR && i !== w.INTERIOR || (this.isNull(e, n) ? this._depth[e][n] = ti.depthAtLocation(i) : this._depth[e][n] += ti.depthAtLocation(i));\n    } else if (3 === arguments.length) {\n      var r = arguments[0],\n          o = arguments[1];\n      arguments[2] === w.INTERIOR && this._depth[r][o]++;\n    }\n  }, ti.prototype.interfaces_ = function () {\n    return [];\n  }, ti.prototype.getClass = function () {\n    return ti;\n  }, ti.depthAtLocation = function (t) {\n    return t === w.EXTERIOR ? 0 : t === w.INTERIOR ? 1 : ti.NULL_VALUE;\n  }, ei.NULL_VALUE.get = function () {\n    return -1;\n  }, Object.defineProperties(ti, ei);\n\n  var ni = function (t) {\n    function e() {\n      if (t.call(this), this.pts = null, this._env = null, this.eiList = new Qn(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new ti(), this._depthDelta = 0, 1 === arguments.length) {\n        var n = arguments[0];\n        e.call(this, n, null);\n      } else if (2 === arguments.length) {\n        var i = arguments[0],\n            r = arguments[1];\n        this.pts = i, this._label = r;\n      }\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getDepth = function () {\n      return this._depth;\n    }, e.prototype.getCollapsedEdge = function () {\n      var t = new Array(2).fill(null);\n      t[0] = this.pts[0], t[1] = this.pts[1];\n      return new e(t, Pe.toLineLabel(this._label));\n    }, e.prototype.isIsolated = function () {\n      return this._isIsolated;\n    }, e.prototype.getCoordinates = function () {\n      return this.pts;\n    }, e.prototype.setIsolated = function (t) {\n      this._isIsolated = t;\n    }, e.prototype.setName = function (t) {\n      this._name = t;\n    }, e.prototype.equals = function (t) {\n      if (!(t instanceof e)) return !1;\n      var n = t;\n      if (this.pts.length !== n.pts.length) return !1;\n\n      for (var i = !0, r = !0, o = this.pts.length, s = 0; s < this.pts.length; s++) if (this.pts[s].equals2D(n.pts[s]) || (i = !1), this.pts[s].equals2D(n.pts[--o]) || (r = !1), !i && !r) return !1;\n\n      return !0;\n    }, e.prototype.getCoordinate = function () {\n      if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null;\n\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return this.pts[t];\n      }\n    }, e.prototype.print = function (t) {\n      t.print(\"edge \" + this._name + \": \"), t.print(\"LINESTRING (\");\n\n      for (var e = 0; e < this.pts.length; e++) e > 0 && t.print(\",\"), t.print(this.pts[e].x + \" \" + this.pts[e].y);\n\n      t.print(\")  \" + this._label + \" \" + this._depthDelta);\n    }, e.prototype.computeIM = function (t) {\n      e.updateIM(this._label, t);\n    }, e.prototype.isCollapsed = function () {\n      return !!this._label.isArea() && 3 === this.pts.length && !!this.pts[0].equals(this.pts[2]);\n    }, e.prototype.isClosed = function () {\n      return this.pts[0].equals(this.pts[this.pts.length - 1]);\n    }, e.prototype.getMaximumSegmentIndex = function () {\n      return this.pts.length - 1;\n    }, e.prototype.getDepthDelta = function () {\n      return this._depthDelta;\n    }, e.prototype.getNumPoints = function () {\n      return this.pts.length;\n    }, e.prototype.printReverse = function (t) {\n      t.print(\"edge \" + this._name + \": \");\n\n      for (var e = this.pts.length - 1; e >= 0; e--) t.print(this.pts[e] + \" \");\n\n      t.println(\"\");\n    }, e.prototype.getMonotoneChainEdge = function () {\n      return null === this._mce && (this._mce = new $n(this)), this._mce;\n    }, e.prototype.getEnvelope = function () {\n      if (null === this._env) {\n        this._env = new j();\n\n        for (var t = 0; t < this.pts.length; t++) this._env.expandToInclude(this.pts[t]);\n      }\n\n      return this._env;\n    }, e.prototype.addIntersection = function (t, e, n, i) {\n      var r = new C(t.getIntersection(i)),\n          o = e,\n          s = t.getEdgeDistance(n, i),\n          a = o + 1;\n\n      if (a < this.pts.length) {\n        var u = this.pts[a];\n        r.equals2D(u) && (o = a, s = 0);\n      }\n\n      this.eiList.add(r, o, s);\n    }, e.prototype.toString = function () {\n      var t = new D();\n      t.append(\"edge \" + this._name + \": \"), t.append(\"LINESTRING (\");\n\n      for (var e = 0; e < this.pts.length; e++) e > 0 && t.append(\",\"), t.append(this.pts[e].x + \" \" + this.pts[e].y);\n\n      return t.append(\")  \" + this._label + \" \" + this._depthDelta), t.toString();\n    }, e.prototype.isPointwiseEqual = function (t) {\n      if (this.pts.length !== t.pts.length) return !1;\n\n      for (var e = 0; e < this.pts.length; e++) if (!this.pts[e].equals2D(t.pts[e])) return !1;\n\n      return !0;\n    }, e.prototype.setDepthDelta = function (t) {\n      this._depthDelta = t;\n    }, e.prototype.getEdgeIntersectionList = function () {\n      return this.eiList;\n    }, e.prototype.addIntersections = function (t, e, n) {\n      for (var i = 0; i < t.getIntersectionNum(); i++) this.addIntersection(t, e, n, i);\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e.updateIM = function () {\n      if (2 !== arguments.length) return t.prototype.updateIM.apply(this, arguments);\n      var e = arguments[0],\n          n = arguments[1];\n      n.setAtLeastIfValid(e.getLocation(0, Se.ON), e.getLocation(1, Se.ON), 1), e.isArea() && (n.setAtLeastIfValid(e.getLocation(0, Se.LEFT), e.getLocation(1, Se.LEFT), 2), n.setAtLeastIfValid(e.getLocation(0, Se.RIGHT), e.getLocation(1, Se.RIGHT), 2));\n    }, e;\n  }(Fe),\n      ii = function (t) {\n    this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Hn(), this._bufParams = t || null;\n  };\n\n  ii.prototype.setWorkingPrecisionModel = function (t) {\n    this._workingPrecisionModel = t;\n  }, ii.prototype.insertUniqueEdge = function (t) {\n    var e = this._edgeList.findEqualEdge(t);\n\n    if (null !== e) {\n      var n = e.getLabel(),\n          i = t.getLabel();\n      e.isPointwiseEqual(t) || (i = new Pe(t.getLabel())).flip(), n.merge(i);\n      var r = ii.depthDelta(i),\n          o = e.getDepthDelta() + r;\n      e.setDepthDelta(o);\n    } else this._edgeList.add(t), t.setDepthDelta(ii.depthDelta(t.getLabel()));\n  }, ii.prototype.buildSubgraphs = function (t, e) {\n    for (var n = new Nt(), i = t.iterator(); i.hasNext();) {\n      var r = i.next(),\n          o = r.getRightmostCoordinate(),\n          s = new An(n).getDepth(o);\n      r.computeDepth(s), r.findResultEdges(), n.add(r), e.add(r.getDirectedEdges(), r.getNodes());\n    }\n  }, ii.prototype.createSubgraphs = function (t) {\n    for (var e = new Nt(), n = t.getNodes().iterator(); n.hasNext();) {\n      var i = n.next();\n\n      if (!i.isVisited()) {\n        var r = new Te();\n        r.create(i), e.add(r);\n      }\n    }\n\n    return $e.sort(e, $e.reverseOrder()), e;\n  }, ii.prototype.createEmptyResultGeometry = function () {\n    return this._geomFact.createPolygon();\n  }, ii.prototype.getNoder = function (t) {\n    if (null !== this._workingNoder) return this._workingNoder;\n    var e = new xn(),\n        n = new rt();\n    return n.setPrecisionModel(t), e.setSegmentIntersector(new Kn(n)), e;\n  }, ii.prototype.buffer = function (t, e) {\n    var n = this._workingPrecisionModel;\n    null === n && (n = t.getPrecisionModel()), this._geomFact = t.getFactory();\n    var i = new Mn(n, this._bufParams),\n        r = new Bn(t, e, i).getCurves();\n    if (r.size() <= 0) return this.createEmptyResultGeometry();\n    this.computeNodedEdges(r, n), this._graph = new Ye(new kn()), this._graph.addEdges(this._edgeList.getEdges());\n    var o = this.createSubgraphs(this._graph),\n        s = new ke(this._geomFact);\n    this.buildSubgraphs(o, s);\n    var a = s.getPolygons();\n    if (a.size() <= 0) return this.createEmptyResultGeometry();\n    return this._geomFact.buildGeometry(a);\n  }, ii.prototype.computeNodedEdges = function (t, e) {\n    var n = this.getNoder(e);\n    n.computeNodes(t);\n\n    for (var i = n.getNodedSubstrings().iterator(); i.hasNext();) {\n      var r = i.next(),\n          o = r.getCoordinates();\n\n      if (2 !== o.length || !o[0].equals2D(o[1])) {\n        var s = r.getData(),\n            a = new ni(r.getCoordinates(), new Pe(s));\n        this.insertUniqueEdge(a);\n      }\n    }\n  }, ii.prototype.setNoder = function (t) {\n    this._workingNoder = t;\n  }, ii.prototype.interfaces_ = function () {\n    return [];\n  }, ii.prototype.getClass = function () {\n    return ii;\n  }, ii.depthDelta = function (t) {\n    var e = t.getLocation(0, Se.LEFT),\n        n = t.getLocation(0, Se.RIGHT);\n    return e === w.INTERIOR && n === w.EXTERIOR ? 1 : e === w.EXTERIOR && n === w.INTERIOR ? -1 : 0;\n  }, ii.convertSegStrings = function (t) {\n    for (var e = new _e(), n = new Nt(); t.hasNext();) {\n      var i = t.next(),\n          r = e.createLineString(i.getCoordinates());\n      n.add(r);\n    }\n\n    return e.buildGeometry(n);\n  };\n\n  var ri = function () {\n    if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, 2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      this._noder = t, this._scaleFactor = e, this._offsetX = 0, this._offsetY = 0, this._isScaled = !this.isIntegerPrecision();\n    } else if (4 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2],\n          o = arguments[3];\n      this._noder = n, this._scaleFactor = i, this._offsetX = r, this._offsetY = o, this._isScaled = !this.isIntegerPrecision();\n    }\n  };\n\n  ri.prototype.rescale = function () {\n    if (T(arguments[0], It)) for (var t = arguments[0].iterator(); t.hasNext();) {\n      var e = t.next();\n      this.rescale(e.getCoordinates());\n    } else if (arguments[0] instanceof Array) {\n      for (var n = arguments[0], i = 0; i < n.length; i++) n[i].x = n[i].x / this._scaleFactor + this._offsetX, n[i].y = n[i].y / this._scaleFactor + this._offsetY;\n\n      2 === n.length && n[0].equals2D(n[1]) && Y.out.println(n);\n    }\n  }, ri.prototype.scale = function () {\n    if (T(arguments[0], It)) {\n      for (var t = arguments[0], e = new Nt(), n = t.iterator(); n.hasNext();) {\n        var i = n.next();\n        e.add(new gn(this.scale(i.getCoordinates()), i.getData()));\n      }\n\n      return e;\n    }\n\n    if (arguments[0] instanceof Array) {\n      for (var r = arguments[0], o = new Array(r.length).fill(null), s = 0; s < r.length; s++) o[s] = new C(Math.round((r[s].x - this._offsetX) * this._scaleFactor), Math.round((r[s].y - this._offsetY) * this._scaleFactor), r[s].z);\n\n      return Lt.removeRepeatedPoints(o);\n    }\n  }, ri.prototype.isIntegerPrecision = function () {\n    return 1 === this._scaleFactor;\n  }, ri.prototype.getNodedSubstrings = function () {\n    var t = this._noder.getNodedSubstrings();\n\n    return this._isScaled && this.rescale(t), t;\n  }, ri.prototype.computeNodes = function (t) {\n    var e = t;\n    this._isScaled && (e = this.scale(t)), this._noder.computeNodes(e);\n  }, ri.prototype.interfaces_ = function () {\n    return [In];\n  }, ri.prototype.getClass = function () {\n    return ri;\n  };\n\n  var oi = function () {\n    this._li = new rt(), this._segStrings = null;\n    var t = arguments[0];\n    this._segStrings = t;\n  },\n      si = {\n    fact: {\n      configurable: !0\n    }\n  };\n\n  oi.prototype.checkEndPtVertexIntersections = function () {\n    if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) {\n      var e = t.next().getCoordinates();\n      this.checkEndPtVertexIntersections(e[0], this._segStrings), this.checkEndPtVertexIntersections(e[e.length - 1], this._segStrings);\n    } else if (2 === arguments.length) for (var n = arguments[0], i = arguments[1].iterator(); i.hasNext();) for (var r = i.next().getCoordinates(), o = 1; o < r.length - 1; o++) if (r[o].equals(n)) throw new $(\"found endpt/interior pt intersection at index \" + o + \" :pt \" + n);\n  }, oi.prototype.checkInteriorIntersections = function () {\n    if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) for (var e = t.next(), n = this._segStrings.iterator(); n.hasNext();) {\n      var i = n.next();\n      this.checkInteriorIntersections(e, i);\n    } else if (2 === arguments.length) for (var r = arguments[0], o = arguments[1], s = r.getCoordinates(), a = o.getCoordinates(), u = 0; u < s.length - 1; u++) for (var l = 0; l < a.length - 1; l++) this.checkInteriorIntersections(r, u, o, l);else if (4 === arguments.length) {\n      var c = arguments[0],\n          p = arguments[1],\n          h = arguments[2],\n          f = arguments[3];\n      if (c === h && p === f) return null;\n      var g = c.getCoordinates()[p],\n          d = c.getCoordinates()[p + 1],\n          y = h.getCoordinates()[f],\n          _ = h.getCoordinates()[f + 1];\n      if (this._li.computeIntersection(g, d, y, _), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, g, d) || this.hasInteriorIntersection(this._li, y, _))) throw new $(\"found non-noded intersection at \" + g + \"-\" + d + \" and \" + y + \"-\" + _);\n    }\n  }, oi.prototype.checkValid = function () {\n    this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();\n  }, oi.prototype.checkCollapses = function () {\n    if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) {\n      var e = t.next();\n      this.checkCollapses(e);\n    } else if (1 === arguments.length) for (var n = arguments[0].getCoordinates(), i = 0; i < n.length - 2; i++) this.checkCollapse(n[i], n[i + 1], n[i + 2]);\n  }, oi.prototype.hasInteriorIntersection = function (t, e, n) {\n    for (var i = 0; i < t.getIntersectionNum(); i++) {\n      var r = t.getIntersection(i);\n      if (!r.equals(e) && !r.equals(n)) return !0;\n    }\n\n    return !1;\n  }, oi.prototype.checkCollapse = function (t, e, n) {\n    if (t.equals(n)) throw new $(\"found non-noded collapse at \" + oi.fact.createLineString([t, e, n]));\n  }, oi.prototype.interfaces_ = function () {\n    return [];\n  }, oi.prototype.getClass = function () {\n    return oi;\n  }, si.fact.get = function () {\n    return new _e();\n  }, Object.defineProperties(oi, si);\n\n  var ai = function () {\n    this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n    if (this._originalPt = t, this._pt = t, this._scaleFactor = e, this._li = n, e <= 0) throw new m(\"Scale factor must be non-zero\");\n    1 !== e && (this._pt = new C(this.scale(t.x), this.scale(t.y)), this._p0Scaled = new C(), this._p1Scaled = new C()), this.initCorners(this._pt);\n  },\n      ui = {\n    SAFE_ENV_EXPANSION_FACTOR: {\n      configurable: !0\n    }\n  };\n\n  ai.prototype.intersectsScaled = function (t, e) {\n    var n = Math.min(t.x, e.x),\n        i = Math.max(t.x, e.x),\n        r = Math.min(t.y, e.y),\n        o = Math.max(t.y, e.y),\n        s = this._maxx < n || this._minx > i || this._maxy < r || this._miny > o;\n    if (s) return !1;\n    var a = this.intersectsToleranceSquare(t, e);\n    return et.isTrue(!(s && a), \"Found bad envelope test\"), a;\n  }, ai.prototype.initCorners = function (t) {\n    this._minx = t.x - .5, this._maxx = t.x + .5, this._miny = t.y - .5, this._maxy = t.y + .5, this._corner[0] = new C(this._maxx, this._maxy), this._corner[1] = new C(this._minx, this._maxy), this._corner[2] = new C(this._minx, this._miny), this._corner[3] = new C(this._maxx, this._miny);\n  }, ai.prototype.intersects = function (t, e) {\n    return 1 === this._scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this._p0Scaled), this.copyScaled(e, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));\n  }, ai.prototype.scale = function (t) {\n    return Math.round(t * this._scaleFactor);\n  }, ai.prototype.getCoordinate = function () {\n    return this._originalPt;\n  }, ai.prototype.copyScaled = function (t, e) {\n    e.x = this.scale(t.x), e.y = this.scale(t.y);\n  }, ai.prototype.getSafeEnvelope = function () {\n    if (null === this._safeEnv) {\n      var t = ai.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;\n      this._safeEnv = new j(this._originalPt.x - t, this._originalPt.x + t, this._originalPt.y - t, this._originalPt.y + t);\n    }\n\n    return this._safeEnv;\n  }, ai.prototype.intersectsPixelClosure = function (t, e) {\n    return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));\n  }, ai.prototype.intersectsToleranceSquare = function (t, e) {\n    var n = !1,\n        i = !1;\n    return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (n = !0), this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (i = !0), this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), !!this._li.isProper() || !(!n || !i) || !!t.equals(this._pt) || !!e.equals(this._pt))));\n  }, ai.prototype.addSnappedNode = function (t, e) {\n    var n = t.getCoordinate(e),\n        i = t.getCoordinate(e + 1);\n    return !!this.intersects(n, i) && (t.addIntersection(this.getCoordinate(), e), !0);\n  }, ai.prototype.interfaces_ = function () {\n    return [];\n  }, ai.prototype.getClass = function () {\n    return ai;\n  }, ui.SAFE_ENV_EXPANSION_FACTOR.get = function () {\n    return .75;\n  }, Object.defineProperties(ai, ui);\n\n  var li = function () {\n    this.tempEnv1 = new j(), this.selectedSegment = new dn();\n  };\n\n  li.prototype.select = function () {\n    if (1 === arguments.length) ;else if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      t.getLineSegment(e, this.selectedSegment), this.select(this.selectedSegment);\n    }\n  }, li.prototype.interfaces_ = function () {\n    return [];\n  }, li.prototype.getClass = function () {\n    return li;\n  };\n\n  var ci = function () {\n    this._index = null;\n    var t = arguments[0];\n    this._index = t;\n  },\n      pi = {\n    HotPixelSnapAction: {\n      configurable: !0\n    }\n  };\n\n  ci.prototype.snap = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return this.snap(t, null, -1);\n    }\n\n    if (3 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1],\n          i = arguments[2],\n          r = e.getSafeEnvelope(),\n          o = new hi(e, n, i);\n      return this._index.query(r, {\n        interfaces_: function () {\n          return [Ke];\n        },\n        visitItem: function (t) {\n          t.select(r, o);\n        }\n      }), o.isNodeAdded();\n    }\n  }, ci.prototype.interfaces_ = function () {\n    return [];\n  }, ci.prototype.getClass = function () {\n    return ci;\n  }, pi.HotPixelSnapAction.get = function () {\n    return hi;\n  }, Object.defineProperties(ci, pi);\n\n  var hi = function (t) {\n    function e() {\n      t.call(this), this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1;\n      var e = arguments[0],\n          n = arguments[1],\n          i = arguments[2];\n      this._hotPixel = e, this._parentEdge = n, this._hotPixelVertexIndex = i;\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isNodeAdded = function () {\n      return this._isNodeAdded;\n    }, e.prototype.select = function () {\n      if (2 !== arguments.length) return t.prototype.select.apply(this, arguments);\n      var e = arguments[0],\n          n = arguments[1],\n          i = e.getContext();\n      if (null !== this._parentEdge && i === this._parentEdge && n === this._hotPixelVertexIndex) return null;\n      this._isNodeAdded = this._hotPixel.addSnappedNode(i, n);\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e;\n  }(li),\n      fi = function () {\n    this._li = null, this._interiorIntersections = null;\n    var t = arguments[0];\n    this._li = t, this._interiorIntersections = new Nt();\n  };\n\n  fi.prototype.processIntersections = function (t, e, n, i) {\n    if (t === n && e === i) return null;\n    var r = t.getCoordinates()[e],\n        o = t.getCoordinates()[e + 1],\n        s = n.getCoordinates()[i],\n        a = n.getCoordinates()[i + 1];\n\n    if (this._li.computeIntersection(r, o, s, a), this._li.hasIntersection() && this._li.isInteriorIntersection()) {\n      for (var u = 0; u < this._li.getIntersectionNum(); u++) this._interiorIntersections.add(this._li.getIntersection(u));\n\n      t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1);\n    }\n  }, fi.prototype.isDone = function () {\n    return !1;\n  }, fi.prototype.getInteriorIntersections = function () {\n    return this._interiorIntersections;\n  }, fi.prototype.interfaces_ = function () {\n    return [Wn];\n  }, fi.prototype.getClass = function () {\n    return fi;\n  };\n\n  var gi = function () {\n    this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;\n    var t = arguments[0];\n    this._pm = t, this._li = new rt(), this._li.setPrecisionModel(t), this._scaleFactor = t.getScale();\n  };\n\n  gi.prototype.checkCorrectness = function (t) {\n    var e = gn.getNodedSubstrings(t),\n        n = new oi(e);\n\n    try {\n      n.checkValid();\n    } catch (t) {\n      if (!(t instanceof z)) throw t;\n      t.printStackTrace();\n    }\n  }, gi.prototype.getNodedSubstrings = function () {\n    return gn.getNodedSubstrings(this._nodedSegStrings);\n  }, gi.prototype.snapRound = function (t, e) {\n    var n = this.findInteriorIntersections(t, e);\n    this.computeIntersectionSnaps(n), this.computeVertexSnaps(t);\n  }, gi.prototype.findInteriorIntersections = function (t, e) {\n    var n = new fi(e);\n    return this._noder.setSegmentIntersector(n), this._noder.computeNodes(t), n.getInteriorIntersections();\n  }, gi.prototype.computeVertexSnaps = function () {\n    if (T(arguments[0], It)) for (var t = arguments[0].iterator(); t.hasNext();) {\n      var e = t.next();\n      this.computeVertexSnaps(e);\n    } else if (arguments[0] instanceof gn) for (var n = arguments[0], i = n.getCoordinates(), r = 0; r < i.length; r++) {\n      var o = new ai(i[r], this._scaleFactor, this._li);\n      this._pointSnapper.snap(o, n, r) && n.addIntersection(i[r], r);\n    }\n  }, gi.prototype.computeNodes = function (t) {\n    this._nodedSegStrings = t, this._noder = new xn(), this._pointSnapper = new ci(this._noder.getIndex()), this.snapRound(t, this._li);\n  }, gi.prototype.computeIntersectionSnaps = function (t) {\n    for (var e = t.iterator(); e.hasNext();) {\n      var n = e.next(),\n          i = new ai(n, this._scaleFactor, this._li);\n\n      this._pointSnapper.snap(i);\n    }\n  }, gi.prototype.interfaces_ = function () {\n    return [In];\n  }, gi.prototype.getClass = function () {\n    return gi;\n  };\n\n  var di = function () {\n    if (this._argGeom = null, this._distance = null, this._bufParams = new Cn(), this._resultGeometry = null, this._saveException = null, 1 === arguments.length) {\n      var t = arguments[0];\n      this._argGeom = t;\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this._argGeom = e, this._bufParams = n;\n    }\n  },\n      yi = {\n    CAP_ROUND: {\n      configurable: !0\n    },\n    CAP_BUTT: {\n      configurable: !0\n    },\n    CAP_FLAT: {\n      configurable: !0\n    },\n    CAP_SQUARE: {\n      configurable: !0\n    },\n    MAX_PRECISION_DIGITS: {\n      configurable: !0\n    }\n  };\n\n  di.prototype.bufferFixedPrecision = function (t) {\n    var e = new ri(new gi(new fe(1)), t.getScale()),\n        n = new ii(this._bufParams);\n    n.setWorkingPrecisionModel(t), n.setNoder(e), this._resultGeometry = n.buffer(this._argGeom, this._distance);\n  }, di.prototype.bufferReducedPrecision = function () {\n    var t = this;\n\n    if (0 === arguments.length) {\n      for (var e = di.MAX_PRECISION_DIGITS; e >= 0; e--) {\n        try {\n          t.bufferReducedPrecision(e);\n        } catch (e) {\n          if (!(e instanceof we)) throw e;\n          t._saveException = e;\n        }\n\n        if (null !== t._resultGeometry) return null;\n      }\n\n      throw this._saveException;\n    }\n\n    if (1 === arguments.length) {\n      var n = arguments[0],\n          i = di.precisionScaleFactor(this._argGeom, this._distance, n),\n          r = new fe(i);\n      this.bufferFixedPrecision(r);\n    }\n  }, di.prototype.computeGeometry = function () {\n    if (this.bufferOriginalPrecision(), null !== this._resultGeometry) return null;\n\n    var t = this._argGeom.getFactory().getPrecisionModel();\n\n    t.getType() === fe.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision();\n  }, di.prototype.setQuadrantSegments = function (t) {\n    this._bufParams.setQuadrantSegments(t);\n  }, di.prototype.bufferOriginalPrecision = function () {\n    try {\n      var t = new ii(this._bufParams);\n      this._resultGeometry = t.buffer(this._argGeom, this._distance);\n    } catch (t) {\n      if (!(t instanceof $)) throw t;\n      this._saveException = t;\n    }\n  }, di.prototype.getResultGeometry = function (t) {\n    return this._distance = t, this.computeGeometry(), this._resultGeometry;\n  }, di.prototype.setEndCapStyle = function (t) {\n    this._bufParams.setEndCapStyle(t);\n  }, di.prototype.interfaces_ = function () {\n    return [];\n  }, di.prototype.getClass = function () {\n    return di;\n  }, di.bufferOp = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      return new di(t).getResultGeometry(e);\n    }\n\n    if (3 === arguments.length) {\n      if (Number.isInteger(arguments[2]) && arguments[0] instanceof ct && \"number\" == typeof arguments[1]) {\n        var n = arguments[0],\n            i = arguments[1],\n            r = arguments[2],\n            o = new di(n);\n        o.setQuadrantSegments(r);\n        return o.getResultGeometry(i);\n      }\n\n      if (arguments[2] instanceof Cn && arguments[0] instanceof ct && \"number\" == typeof arguments[1]) {\n        var s = arguments[0],\n            a = arguments[1],\n            u = arguments[2];\n        return new di(s, u).getResultGeometry(a);\n      }\n    } else if (4 === arguments.length) {\n      var l = arguments[0],\n          c = arguments[1],\n          p = arguments[2],\n          h = arguments[3],\n          f = new di(l);\n      f.setQuadrantSegments(p), f.setEndCapStyle(h);\n      return f.getResultGeometry(c);\n    }\n  }, di.precisionScaleFactor = function (t, e, n) {\n    var i = t.getEnvelopeInternal(),\n        r = R.max(Math.abs(i.getMaxX()), Math.abs(i.getMaxY()), Math.abs(i.getMinX()), Math.abs(i.getMinY())) + 2 * (e > 0 ? e : 0),\n        o = n - Math.trunc(Math.log(r) / Math.log(10) + 1);\n    return Math.pow(10, o);\n  }, yi.CAP_ROUND.get = function () {\n    return Cn.CAP_ROUND;\n  }, yi.CAP_BUTT.get = function () {\n    return Cn.CAP_FLAT;\n  }, yi.CAP_FLAT.get = function () {\n    return Cn.CAP_FLAT;\n  }, yi.CAP_SQUARE.get = function () {\n    return Cn.CAP_SQUARE;\n  }, yi.MAX_PRECISION_DIGITS.get = function () {\n    return 12;\n  }, Object.defineProperties(di, yi);\n\n  var _i = function () {\n    this._pt = [new C(), new C()], this._distance = v.NaN, this._isNull = !0;\n  };\n\n  _i.prototype.getCoordinates = function () {\n    return this._pt;\n  }, _i.prototype.getCoordinate = function (t) {\n    return this._pt[t];\n  }, _i.prototype.setMinimum = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setMinimum(t._pt[0], t._pt[1]);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      if (this._isNull) return this.initialize(e, n), null;\n      var i = e.distance(n);\n      i < this._distance && this.initialize(e, n, i);\n    }\n  }, _i.prototype.initialize = function () {\n    if (0 === arguments.length) this._isNull = !0;else if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      this._pt[0].setCoordinate(t), this._pt[1].setCoordinate(e), this._distance = t.distance(e), this._isNull = !1;\n    } else if (3 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2];\n      this._pt[0].setCoordinate(n), this._pt[1].setCoordinate(i), this._distance = r, this._isNull = !1;\n    }\n  }, _i.prototype.getDistance = function () {\n    return this._distance;\n  }, _i.prototype.setMaximum = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setMaximum(t._pt[0], t._pt[1]);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      if (this._isNull) return this.initialize(e, n), null;\n      var i = e.distance(n);\n      i > this._distance && this.initialize(e, n, i);\n    }\n  }, _i.prototype.interfaces_ = function () {\n    return [];\n  }, _i.prototype.getClass = function () {\n    return _i;\n  };\n\n  var mi = function () {};\n\n  mi.prototype.interfaces_ = function () {\n    return [];\n  }, mi.prototype.getClass = function () {\n    return mi;\n  }, mi.computeDistance = function () {\n    if (arguments[2] instanceof _i && arguments[0] instanceof Kt && arguments[1] instanceof C) for (var t = arguments[0], e = arguments[1], n = arguments[2], i = t.getCoordinates(), r = new dn(), o = 0; o < i.length - 1; o++) {\n      r.setCoordinates(i[o], i[o + 1]);\n      var s = r.closestPoint(e);\n      n.setMinimum(s, e);\n    } else if (arguments[2] instanceof _i && arguments[0] instanceof $t && arguments[1] instanceof C) {\n      var a = arguments[0],\n          u = arguments[1],\n          l = arguments[2];\n      mi.computeDistance(a.getExteriorRing(), u, l);\n\n      for (var c = 0; c < a.getNumInteriorRing(); c++) mi.computeDistance(a.getInteriorRingN(c), u, l);\n    } else if (arguments[2] instanceof _i && arguments[0] instanceof ct && arguments[1] instanceof C) {\n      var p = arguments[0],\n          h = arguments[1],\n          f = arguments[2];\n      if (p instanceof Kt) mi.computeDistance(p, h, f);else if (p instanceof $t) mi.computeDistance(p, h, f);else if (p instanceof zt) for (var g = p, d = 0; d < g.getNumGeometries(); d++) {\n        var y = g.getGeometryN(d);\n        mi.computeDistance(y, h, f);\n      } else f.setMinimum(p.getCoordinate(), h);\n    } else if (arguments[2] instanceof _i && arguments[0] instanceof dn && arguments[1] instanceof C) {\n      var _ = arguments[0],\n          m = arguments[1],\n          v = arguments[2],\n          I = _.closestPoint(m);\n\n      v.setMinimum(I, m);\n    }\n  };\n\n  var vi = function (t) {\n    this._maxPtDist = new _i(), this._inputGeom = t || null;\n  },\n      Ii = {\n    MaxPointDistanceFilter: {\n      configurable: !0\n    },\n    MaxMidpointDistanceFilter: {\n      configurable: !0\n    }\n  };\n\n  vi.prototype.computeMaxMidpointDistance = function (t) {\n    var e = new xi(this._inputGeom);\n    t.apply(e), this._maxPtDist.setMaximum(e.getMaxPointDistance());\n  }, vi.prototype.computeMaxVertexDistance = function (t) {\n    var e = new Ei(this._inputGeom);\n    t.apply(e), this._maxPtDist.setMaximum(e.getMaxPointDistance());\n  }, vi.prototype.findDistance = function (t) {\n    return this.computeMaxVertexDistance(t), this.computeMaxMidpointDistance(t), this._maxPtDist.getDistance();\n  }, vi.prototype.getDistancePoints = function () {\n    return this._maxPtDist;\n  }, vi.prototype.interfaces_ = function () {\n    return [];\n  }, vi.prototype.getClass = function () {\n    return vi;\n  }, Ii.MaxPointDistanceFilter.get = function () {\n    return Ei;\n  }, Ii.MaxMidpointDistanceFilter.get = function () {\n    return xi;\n  }, Object.defineProperties(vi, Ii);\n\n  var Ei = function (t) {\n    this._maxPtDist = new _i(), this._minPtDist = new _i(), this._geom = t || null;\n  };\n\n  Ei.prototype.filter = function (t) {\n    this._minPtDist.initialize(), mi.computeDistance(this._geom, t, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);\n  }, Ei.prototype.getMaxPointDistance = function () {\n    return this._maxPtDist;\n  }, Ei.prototype.interfaces_ = function () {\n    return [ft];\n  }, Ei.prototype.getClass = function () {\n    return Ei;\n  };\n\n  var xi = function (t) {\n    this._maxPtDist = new _i(), this._minPtDist = new _i(), this._geom = t || null;\n  };\n\n  xi.prototype.filter = function (t, e) {\n    if (0 === e) return null;\n    var n = t.getCoordinate(e - 1),\n        i = t.getCoordinate(e),\n        r = new C((n.x + i.x) / 2, (n.y + i.y) / 2);\n    this._minPtDist.initialize(), mi.computeDistance(this._geom, r, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);\n  }, xi.prototype.isDone = function () {\n    return !1;\n  }, xi.prototype.isGeometryChanged = function () {\n    return !1;\n  }, xi.prototype.getMaxPointDistance = function () {\n    return this._maxPtDist;\n  }, xi.prototype.interfaces_ = function () {\n    return [Ut];\n  }, xi.prototype.getClass = function () {\n    return xi;\n  };\n\n  var Ni = function (t) {\n    this._comps = t || null;\n  };\n\n  Ni.prototype.filter = function (t) {\n    t instanceof $t && this._comps.add(t);\n  }, Ni.prototype.interfaces_ = function () {\n    return [Vt];\n  }, Ni.prototype.getClass = function () {\n    return Ni;\n  }, Ni.getPolygons = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return Ni.getPolygons(t, new Nt());\n    }\n\n    if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      return e instanceof $t ? n.add(e) : e instanceof zt && e.apply(new Ni(n)), n;\n    }\n  };\n\n  var Ci = function () {\n    if (this._lines = null, this._isForcedToLineString = !1, 1 === arguments.length) {\n      var t = arguments[0];\n      this._lines = t;\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this._lines = e, this._isForcedToLineString = n;\n    }\n  };\n\n  Ci.prototype.filter = function (t) {\n    if (this._isForcedToLineString && t instanceof ee) {\n      var e = t.getFactory().createLineString(t.getCoordinateSequence());\n      return this._lines.add(e), null;\n    }\n\n    t instanceof Kt && this._lines.add(t);\n  }, Ci.prototype.setForceToLineString = function (t) {\n    this._isForcedToLineString = t;\n  }, Ci.prototype.interfaces_ = function () {\n    return [lt];\n  }, Ci.prototype.getClass = function () {\n    return Ci;\n  }, Ci.getGeometry = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return t.getFactory().buildGeometry(Ci.getLines(t));\n    }\n\n    if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      return e.getFactory().buildGeometry(Ci.getLines(e, n));\n    }\n  }, Ci.getLines = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return Ci.getLines(t, !1);\n    }\n\n    if (2 === arguments.length) {\n      if (T(arguments[0], It) && T(arguments[1], It)) {\n        for (var e = arguments[0], n = arguments[1], i = e.iterator(); i.hasNext();) {\n          var r = i.next();\n          Ci.getLines(r, n);\n        }\n\n        return n;\n      }\n\n      if (arguments[0] instanceof ct && \"boolean\" == typeof arguments[1]) {\n        var o = arguments[0],\n            s = arguments[1],\n            a = new Nt();\n        return o.apply(new Ci(a, s)), a;\n      }\n\n      if (arguments[0] instanceof ct && T(arguments[1], It)) {\n        var u = arguments[0],\n            l = arguments[1];\n        return u instanceof Kt ? l.add(u) : u.apply(new Ci(l)), l;\n      }\n    } else if (3 === arguments.length) {\n      if (\"boolean\" == typeof arguments[2] && T(arguments[0], It) && T(arguments[1], It)) {\n        for (var c = arguments[0], p = arguments[1], h = arguments[2], f = c.iterator(); f.hasNext();) {\n          var g = f.next();\n          Ci.getLines(g, p, h);\n        }\n\n        return p;\n      }\n\n      if (\"boolean\" == typeof arguments[2] && arguments[0] instanceof ct && T(arguments[1], It)) {\n        var d = arguments[0],\n            y = arguments[1],\n            _ = arguments[2];\n        return d.apply(new Ci(y, _)), y;\n      }\n    }\n  };\n\n  var Si = function () {\n    if (this._boundaryRule = gt.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, 0 === arguments.length) ;else if (1 === arguments.length) {\n      var t = arguments[0];\n      if (null === t) throw new m(\"Rule must be non-null\");\n      this._boundaryRule = t;\n    }\n  };\n\n  Si.prototype.locateInternal = function () {\n    if (arguments[0] instanceof C && arguments[1] instanceof $t) {\n      var t = arguments[0],\n          e = arguments[1];\n      if (e.isEmpty()) return w.EXTERIOR;\n      var n = e.getExteriorRing(),\n          i = this.locateInPolygonRing(t, n);\n      if (i === w.EXTERIOR) return w.EXTERIOR;\n      if (i === w.BOUNDARY) return w.BOUNDARY;\n\n      for (var r = 0; r < e.getNumInteriorRing(); r++) {\n        var o = e.getInteriorRingN(r),\n            s = this.locateInPolygonRing(t, o);\n        if (s === w.INTERIOR) return w.EXTERIOR;\n        if (s === w.BOUNDARY) return w.BOUNDARY;\n      }\n\n      return w.INTERIOR;\n    }\n\n    if (arguments[0] instanceof C && arguments[1] instanceof Kt) {\n      var a = arguments[0],\n          u = arguments[1];\n      if (!u.getEnvelopeInternal().intersects(a)) return w.EXTERIOR;\n      var l = u.getCoordinates();\n      return u.isClosed() || !a.equals(l[0]) && !a.equals(l[l.length - 1]) ? at.isOnLine(a, l) ? w.INTERIOR : w.EXTERIOR : w.BOUNDARY;\n    }\n\n    if (arguments[0] instanceof C && arguments[1] instanceof Qt) {\n      var c = arguments[0];\n      return arguments[1].getCoordinate().equals2D(c) ? w.INTERIOR : w.EXTERIOR;\n    }\n  }, Si.prototype.locateInPolygonRing = function (t, e) {\n    return e.getEnvelopeInternal().intersects(t) ? at.locatePointInRing(t, e.getCoordinates()) : w.EXTERIOR;\n  }, Si.prototype.intersects = function (t, e) {\n    return this.locate(t, e) !== w.EXTERIOR;\n  }, Si.prototype.updateLocationInfo = function (t) {\n    t === w.INTERIOR && (this._isIn = !0), t === w.BOUNDARY && this._numBoundaries++;\n  }, Si.prototype.computeLocation = function (t, e) {\n    if (e instanceof Qt && this.updateLocationInfo(this.locateInternal(t, e)), e instanceof Kt) this.updateLocationInfo(this.locateInternal(t, e));else if (e instanceof $t) this.updateLocationInfo(this.locateInternal(t, e));else if (e instanceof Xt) for (var n = e, i = 0; i < n.getNumGeometries(); i++) {\n      var r = n.getGeometryN(i);\n      this.updateLocationInfo(this.locateInternal(t, r));\n    } else if (e instanceof ne) for (var o = e, s = 0; s < o.getNumGeometries(); s++) {\n      var a = o.getGeometryN(s);\n      this.updateLocationInfo(this.locateInternal(t, a));\n    } else if (e instanceof zt) for (var u = new Un(e); u.hasNext();) {\n      var l = u.next();\n      l !== e && this.computeLocation(t, l);\n    }\n  }, Si.prototype.locate = function (t, e) {\n    return e.isEmpty() ? w.EXTERIOR : e instanceof Kt ? this.locateInternal(t, e) : e instanceof $t ? this.locateInternal(t, e) : (this._isIn = !1, this._numBoundaries = 0, this.computeLocation(t, e), this._boundaryRule.isInBoundary(this._numBoundaries) ? w.BOUNDARY : this._numBoundaries > 0 || this._isIn ? w.INTERIOR : w.EXTERIOR);\n  }, Si.prototype.interfaces_ = function () {\n    return [];\n  }, Si.prototype.getClass = function () {\n    return Si;\n  };\n\n  var Li = function t() {\n    if (this._component = null, this._segIndex = null, this._pt = null, 2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      t.call(this, e, t.INSIDE_AREA, n);\n    } else if (3 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1],\n          o = arguments[2];\n      this._component = i, this._segIndex = r, this._pt = o;\n    }\n  },\n      bi = {\n    INSIDE_AREA: {\n      configurable: !0\n    }\n  };\n\n  Li.prototype.isInsideArea = function () {\n    return this._segIndex === Li.INSIDE_AREA;\n  }, Li.prototype.getCoordinate = function () {\n    return this._pt;\n  }, Li.prototype.getGeometryComponent = function () {\n    return this._component;\n  }, Li.prototype.getSegmentIndex = function () {\n    return this._segIndex;\n  }, Li.prototype.interfaces_ = function () {\n    return [];\n  }, Li.prototype.getClass = function () {\n    return Li;\n  }, bi.INSIDE_AREA.get = function () {\n    return -1;\n  }, Object.defineProperties(Li, bi);\n\n  var wi = function (t) {\n    this._pts = t || null;\n  };\n\n  wi.prototype.filter = function (t) {\n    t instanceof Qt && this._pts.add(t);\n  }, wi.prototype.interfaces_ = function () {\n    return [Vt];\n  }, wi.prototype.getClass = function () {\n    return wi;\n  }, wi.getPoints = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return t instanceof Qt ? $e.singletonList(t) : wi.getPoints(t, new Nt());\n    }\n\n    if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      return e instanceof Qt ? n.add(e) : e instanceof zt && e.apply(new wi(n)), n;\n    }\n  };\n\n  var Oi = function () {\n    this._locations = null;\n    var t = arguments[0];\n    this._locations = t;\n  };\n\n  Oi.prototype.filter = function (t) {\n    (t instanceof Qt || t instanceof Kt || t instanceof $t) && this._locations.add(new Li(t, 0, t.getCoordinate()));\n  }, Oi.prototype.interfaces_ = function () {\n    return [Vt];\n  }, Oi.prototype.getClass = function () {\n    return Oi;\n  }, Oi.getLocations = function (t) {\n    var e = new Nt();\n    return t.apply(new Oi(e)), e;\n  };\n\n  var Ti = function () {\n    if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new Si(), this._minDistanceLocation = null, this._minDistance = v.MAX_VALUE, 2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      this._geom = [t, e], this._terminateDistance = 0;\n    } else if (3 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2];\n      this._geom = new Array(2).fill(null), this._geom[0] = n, this._geom[1] = i, this._terminateDistance = r;\n    }\n  };\n\n  Ti.prototype.computeContainmentDistance = function () {\n    if (0 === arguments.length) {\n      var t = new Array(2).fill(null);\n      if (this.computeContainmentDistance(0, t), this._minDistance <= this._terminateDistance) return null;\n      this.computeContainmentDistance(1, t);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1],\n          i = 1 - e,\n          r = Ni.getPolygons(this._geom[e]);\n\n      if (r.size() > 0) {\n        var o = Oi.getLocations(this._geom[i]);\n        if (this.computeContainmentDistance(o, r, n), this._minDistance <= this._terminateDistance) return this._minDistanceLocation[i] = n[0], this._minDistanceLocation[e] = n[1], null;\n      }\n    } else if (3 === arguments.length) if (arguments[2] instanceof Array && T(arguments[0], xt) && T(arguments[1], xt)) {\n      for (var s = arguments[0], a = arguments[1], u = arguments[2], l = 0; l < s.size(); l++) for (var c = s.get(l), p = 0; p < a.size(); p++) if (this.computeContainmentDistance(c, a.get(p), u), this._minDistance <= this._terminateDistance) return null;\n    } else if (arguments[2] instanceof Array && arguments[0] instanceof Li && arguments[1] instanceof $t) {\n      var h = arguments[0],\n          f = arguments[1],\n          g = arguments[2],\n          d = h.getCoordinate();\n      if (w.EXTERIOR !== this._ptLocator.locate(d, f)) return this._minDistance = 0, g[0] = h, g[1] = new Li(f, d), null;\n    }\n  }, Ti.prototype.computeMinDistanceLinesPoints = function (t, e, n) {\n    for (var i = 0; i < t.size(); i++) for (var r = t.get(i), o = 0; o < e.size(); o++) {\n      var s = e.get(o);\n      if (this.computeMinDistance(r, s, n), this._minDistance <= this._terminateDistance) return null;\n    }\n  }, Ti.prototype.computeFacetDistance = function () {\n    var t = new Array(2).fill(null),\n        e = Ci.getLines(this._geom[0]),\n        n = Ci.getLines(this._geom[1]),\n        i = wi.getPoints(this._geom[0]),\n        r = wi.getPoints(this._geom[1]);\n    return this.computeMinDistanceLines(e, n, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(e, r, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(n, i, t), this.updateMinDistance(t, !0), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistancePoints(i, r, t), void this.updateMinDistance(t, !1))));\n  }, Ti.prototype.nearestLocations = function () {\n    return this.computeMinDistance(), this._minDistanceLocation;\n  }, Ti.prototype.updateMinDistance = function (t, e) {\n    if (null === t[0]) return null;\n    e ? (this._minDistanceLocation[0] = t[1], this._minDistanceLocation[1] = t[0]) : (this._minDistanceLocation[0] = t[0], this._minDistanceLocation[1] = t[1]);\n  }, Ti.prototype.nearestPoints = function () {\n    this.computeMinDistance();\n    return [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];\n  }, Ti.prototype.computeMinDistance = function () {\n    if (0 === arguments.length) {\n      if (null !== this._minDistanceLocation) return null;\n      if (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance) return null;\n      this.computeFacetDistance();\n    } else if (3 === arguments.length) if (arguments[2] instanceof Array && arguments[0] instanceof Kt && arguments[1] instanceof Qt) {\n      var t = arguments[0],\n          e = arguments[1],\n          n = arguments[2];\n      if (t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > this._minDistance) return null;\n\n      for (var i = t.getCoordinates(), r = e.getCoordinate(), o = 0; o < i.length - 1; o++) {\n        var s = at.distancePointLine(r, i[o], i[o + 1]);\n\n        if (s < this._minDistance) {\n          this._minDistance = s;\n          var a = new dn(i[o], i[o + 1]).closestPoint(r);\n          n[0] = new Li(t, o, a), n[1] = new Li(e, 0, r);\n        }\n\n        if (this._minDistance <= this._terminateDistance) return null;\n      }\n    } else if (arguments[2] instanceof Array && arguments[0] instanceof Kt && arguments[1] instanceof Kt) {\n      var u = arguments[0],\n          l = arguments[1],\n          c = arguments[2];\n      if (u.getEnvelopeInternal().distance(l.getEnvelopeInternal()) > this._minDistance) return null;\n\n      for (var p = u.getCoordinates(), h = l.getCoordinates(), f = 0; f < p.length - 1; f++) for (var g = 0; g < h.length - 1; g++) {\n        var d = at.distanceLineLine(p[f], p[f + 1], h[g], h[g + 1]);\n\n        if (d < this._minDistance) {\n          this._minDistance = d;\n\n          var y = new dn(p[f], p[f + 1]),\n              _ = new dn(h[g], h[g + 1]),\n              m = y.closestPoints(_);\n\n          c[0] = new Li(u, f, m[0]), c[1] = new Li(l, g, m[1]);\n        }\n\n        if (this._minDistance <= this._terminateDistance) return null;\n      }\n    }\n  }, Ti.prototype.computeMinDistancePoints = function (t, e, n) {\n    for (var i = 0; i < t.size(); i++) for (var r = t.get(i), o = 0; o < e.size(); o++) {\n      var s = e.get(o),\n          a = r.getCoordinate().distance(s.getCoordinate());\n      if (a < this._minDistance && (this._minDistance = a, n[0] = new Li(r, 0, r.getCoordinate()), n[1] = new Li(s, 0, s.getCoordinate())), this._minDistance <= this._terminateDistance) return null;\n    }\n  }, Ti.prototype.distance = function () {\n    if (null === this._geom[0] || null === this._geom[1]) throw new m(\"null geometries are not supported\");\n    return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance);\n  }, Ti.prototype.computeMinDistanceLines = function (t, e, n) {\n    for (var i = 0; i < t.size(); i++) for (var r = t.get(i), o = 0; o < e.size(); o++) {\n      var s = e.get(o);\n      if (this.computeMinDistance(r, s, n), this._minDistance <= this._terminateDistance) return null;\n    }\n  }, Ti.prototype.interfaces_ = function () {\n    return [];\n  }, Ti.prototype.getClass = function () {\n    return Ti;\n  }, Ti.distance = function (t, e) {\n    return new Ti(t, e).distance();\n  }, Ti.isWithinDistance = function (t, e, n) {\n    return new Ti(t, e, n).distance() <= n;\n  }, Ti.nearestPoints = function (t, e) {\n    return new Ti(t, e).nearestPoints();\n  };\n\n  var Ri = function () {\n    this._pt = [new C(), new C()], this._distance = v.NaN, this._isNull = !0;\n  };\n\n  Ri.prototype.getCoordinates = function () {\n    return this._pt;\n  }, Ri.prototype.getCoordinate = function (t) {\n    return this._pt[t];\n  }, Ri.prototype.setMinimum = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setMinimum(t._pt[0], t._pt[1]);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      if (this._isNull) return this.initialize(e, n), null;\n      var i = e.distance(n);\n      i < this._distance && this.initialize(e, n, i);\n    }\n  }, Ri.prototype.initialize = function () {\n    if (0 === arguments.length) this._isNull = !0;else if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      this._pt[0].setCoordinate(t), this._pt[1].setCoordinate(e), this._distance = t.distance(e), this._isNull = !1;\n    } else if (3 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2];\n      this._pt[0].setCoordinate(n), this._pt[1].setCoordinate(i), this._distance = r, this._isNull = !1;\n    }\n  }, Ri.prototype.toString = function () {\n    return Z.toLineString(this._pt[0], this._pt[1]);\n  }, Ri.prototype.getDistance = function () {\n    return this._distance;\n  }, Ri.prototype.setMaximum = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setMaximum(t._pt[0], t._pt[1]);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      if (this._isNull) return this.initialize(e, n), null;\n      var i = e.distance(n);\n      i > this._distance && this.initialize(e, n, i);\n    }\n  }, Ri.prototype.interfaces_ = function () {\n    return [];\n  }, Ri.prototype.getClass = function () {\n    return Ri;\n  };\n\n  var Pi = function () {};\n\n  Pi.prototype.interfaces_ = function () {\n    return [];\n  }, Pi.prototype.getClass = function () {\n    return Pi;\n  }, Pi.computeDistance = function () {\n    if (arguments[2] instanceof Ri && arguments[0] instanceof Kt && arguments[1] instanceof C) for (var t = arguments[0], e = arguments[1], n = arguments[2], i = new dn(), r = t.getCoordinates(), o = 0; o < r.length - 1; o++) {\n      i.setCoordinates(r[o], r[o + 1]);\n      var s = i.closestPoint(e);\n      n.setMinimum(s, e);\n    } else if (arguments[2] instanceof Ri && arguments[0] instanceof $t && arguments[1] instanceof C) {\n      var a = arguments[0],\n          u = arguments[1],\n          l = arguments[2];\n      Pi.computeDistance(a.getExteriorRing(), u, l);\n\n      for (var c = 0; c < a.getNumInteriorRing(); c++) Pi.computeDistance(a.getInteriorRingN(c), u, l);\n    } else if (arguments[2] instanceof Ri && arguments[0] instanceof ct && arguments[1] instanceof C) {\n      var p = arguments[0],\n          h = arguments[1],\n          f = arguments[2];\n      if (p instanceof Kt) Pi.computeDistance(p, h, f);else if (p instanceof $t) Pi.computeDistance(p, h, f);else if (p instanceof zt) for (var g = p, d = 0; d < g.getNumGeometries(); d++) {\n        var y = g.getGeometryN(d);\n        Pi.computeDistance(y, h, f);\n      } else f.setMinimum(p.getCoordinate(), h);\n    } else if (arguments[2] instanceof Ri && arguments[0] instanceof dn && arguments[1] instanceof C) {\n      var _ = arguments[0],\n          m = arguments[1],\n          v = arguments[2],\n          I = _.closestPoint(m);\n\n      v.setMinimum(I, m);\n    }\n  };\n\n  var Di = function () {\n    this._g0 = null, this._g1 = null, this._ptDist = new Ri(), this._densifyFrac = 0;\n    var t = arguments[0],\n        e = arguments[1];\n    this._g0 = t, this._g1 = e;\n  },\n      Mi = {\n    MaxPointDistanceFilter: {\n      configurable: !0\n    },\n    MaxDensifiedByFractionDistanceFilter: {\n      configurable: !0\n    }\n  };\n\n  Di.prototype.getCoordinates = function () {\n    return this._ptDist.getCoordinates();\n  }, Di.prototype.setDensifyFraction = function (t) {\n    if (t > 1 || t <= 0) throw new m(\"Fraction is not in range (0.0 - 1.0]\");\n    this._densifyFrac = t;\n  }, Di.prototype.compute = function (t, e) {\n    this.computeOrientedDistance(t, e, this._ptDist), this.computeOrientedDistance(e, t, this._ptDist);\n  }, Di.prototype.distance = function () {\n    return this.compute(this._g0, this._g1), this._ptDist.getDistance();\n  }, Di.prototype.computeOrientedDistance = function (t, e, n) {\n    var i = new Ai(e);\n\n    if (t.apply(i), n.setMaximum(i.getMaxPointDistance()), this._densifyFrac > 0) {\n      var r = new Fi(e, this._densifyFrac);\n      t.apply(r), n.setMaximum(r.getMaxPointDistance());\n    }\n  }, Di.prototype.orientedDistance = function () {\n    return this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance();\n  }, Di.prototype.interfaces_ = function () {\n    return [];\n  }, Di.prototype.getClass = function () {\n    return Di;\n  }, Di.distance = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      return new Di(t, e).distance();\n    }\n\n    if (3 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2],\n          o = new Di(n, i);\n      return o.setDensifyFraction(r), o.distance();\n    }\n  }, Mi.MaxPointDistanceFilter.get = function () {\n    return Ai;\n  }, Mi.MaxDensifiedByFractionDistanceFilter.get = function () {\n    return Fi;\n  }, Object.defineProperties(Di, Mi);\n\n  var Ai = function () {\n    this._maxPtDist = new Ri(), this._minPtDist = new Ri(), this._euclideanDist = new Pi(), this._geom = null;\n    var t = arguments[0];\n    this._geom = t;\n  };\n\n  Ai.prototype.filter = function (t) {\n    this._minPtDist.initialize(), Pi.computeDistance(this._geom, t, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);\n  }, Ai.prototype.getMaxPointDistance = function () {\n    return this._maxPtDist;\n  }, Ai.prototype.interfaces_ = function () {\n    return [ft];\n  }, Ai.prototype.getClass = function () {\n    return Ai;\n  };\n\n  var Fi = function () {\n    this._maxPtDist = new Ri(), this._minPtDist = new Ri(), this._geom = null, this._numSubSegs = 0;\n    var t = arguments[0],\n        e = arguments[1];\n    this._geom = t, this._numSubSegs = Math.trunc(Math.round(1 / e));\n  };\n\n  Fi.prototype.filter = function (t, e) {\n    if (0 === e) return null;\n\n    for (var n = t.getCoordinate(e - 1), i = t.getCoordinate(e), r = (i.x - n.x) / this._numSubSegs, o = (i.y - n.y) / this._numSubSegs, s = 0; s < this._numSubSegs; s++) {\n      var a = n.x + s * r,\n          u = n.y + s * o,\n          l = new C(a, u);\n      this._minPtDist.initialize(), Pi.computeDistance(this._geom, l, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);\n    }\n  }, Fi.prototype.isDone = function () {\n    return !1;\n  }, Fi.prototype.isGeometryChanged = function () {\n    return !1;\n  }, Fi.prototype.getMaxPointDistance = function () {\n    return this._maxPtDist;\n  }, Fi.prototype.interfaces_ = function () {\n    return [Ut];\n  }, Fi.prototype.getClass = function () {\n    return Fi;\n  };\n\n  var Gi = function (t, e, n) {\n    this._minValidDistance = null, this._maxValidDistance = null, this._minDistanceFound = null, this._maxDistanceFound = null, this._isValid = !0, this._errMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t || null, this._bufDistance = e || null, this._result = n || null;\n  },\n      qi = {\n    VERBOSE: {\n      configurable: !0\n    },\n    MAX_DISTANCE_DIFF_FRAC: {\n      configurable: !0\n    }\n  };\n\n  Gi.prototype.checkMaximumDistance = function (t, e, n) {\n    var i = new Di(e, t);\n\n    if (i.setDensifyFraction(.25), this._maxDistanceFound = i.orientedDistance(), this._maxDistanceFound > n) {\n      this._isValid = !1;\n      var r = i.getCoordinates();\n      this._errorLocation = r[1], this._errorIndicator = t.getFactory().createLineString(r), this._errMsg = \"Distance between buffer curve and input is too large (\" + this._maxDistanceFound + \" at \" + Z.toLineString(r[0], r[1]) + \")\";\n    }\n  }, Gi.prototype.isValid = function () {\n    var t = Math.abs(this._bufDistance),\n        e = Gi.MAX_DISTANCE_DIFF_FRAC * t;\n    return this._minValidDistance = t - e, this._maxValidDistance = t + e, !(!this._input.isEmpty() && !this._result.isEmpty()) || (this._bufDistance > 0 ? this.checkPositiveValid() : this.checkNegativeValid(), Gi.VERBOSE && Y.out.println(\"Min Dist= \" + this._minDistanceFound + \"  err= \" + (1 - this._minDistanceFound / this._bufDistance) + \"  Max Dist= \" + this._maxDistanceFound + \"  err= \" + (this._maxDistanceFound / this._bufDistance - 1)), this._isValid);\n  }, Gi.prototype.checkNegativeValid = function () {\n    if (!(this._input instanceof $t || this._input instanceof ne || this._input instanceof zt)) return null;\n    var t = this.getPolygonLines(this._input);\n    if (this.checkMinimumDistance(t, this._result, this._minValidDistance), !this._isValid) return null;\n    this.checkMaximumDistance(t, this._result, this._maxValidDistance);\n  }, Gi.prototype.getErrorIndicator = function () {\n    return this._errorIndicator;\n  }, Gi.prototype.checkMinimumDistance = function (t, e, n) {\n    var i = new Ti(t, e, n);\n\n    if (this._minDistanceFound = i.distance(), this._minDistanceFound < n) {\n      this._isValid = !1;\n      var r = i.nearestPoints();\n      this._errorLocation = i.nearestPoints()[1], this._errorIndicator = t.getFactory().createLineString(r), this._errMsg = \"Distance between buffer curve and input is too small (\" + this._minDistanceFound + \" at \" + Z.toLineString(r[0], r[1]) + \" )\";\n    }\n  }, Gi.prototype.checkPositiveValid = function () {\n    var t = this._result.getBoundary();\n\n    if (this.checkMinimumDistance(this._input, t, this._minValidDistance), !this._isValid) return null;\n    this.checkMaximumDistance(this._input, t, this._maxValidDistance);\n  }, Gi.prototype.getErrorLocation = function () {\n    return this._errorLocation;\n  }, Gi.prototype.getPolygonLines = function (t) {\n    for (var e = new Nt(), n = new Ci(e), i = Ni.getPolygons(t).iterator(); i.hasNext();) {\n      i.next().apply(n);\n    }\n\n    return t.getFactory().buildGeometry(e);\n  }, Gi.prototype.getErrorMessage = function () {\n    return this._errMsg;\n  }, Gi.prototype.interfaces_ = function () {\n    return [];\n  }, Gi.prototype.getClass = function () {\n    return Gi;\n  }, qi.VERBOSE.get = function () {\n    return !1;\n  }, qi.MAX_DISTANCE_DIFF_FRAC.get = function () {\n    return .012;\n  }, Object.defineProperties(Gi, qi);\n\n  var Bi = function (t, e, n) {\n    this._isValid = !0, this._errorMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t || null, this._distance = e || null, this._result = n || null;\n  },\n      Vi = {\n    VERBOSE: {\n      configurable: !0\n    },\n    MAX_ENV_DIFF_FRAC: {\n      configurable: !0\n    }\n  };\n\n  Bi.prototype.isValid = function () {\n    return this.checkPolygonal(), this._isValid ? (this.checkExpectedEmpty(), this._isValid ? (this.checkEnvelope(), this._isValid ? (this.checkArea(), this._isValid ? (this.checkDistance(), this._isValid) : this._isValid) : this._isValid) : this._isValid) : this._isValid;\n  }, Bi.prototype.checkEnvelope = function () {\n    if (this._distance < 0) return null;\n    var t = this._distance * Bi.MAX_ENV_DIFF_FRAC;\n    0 === t && (t = .001);\n    var e = new j(this._input.getEnvelopeInternal());\n    e.expandBy(this._distance);\n    var n = new j(this._result.getEnvelopeInternal());\n    n.expandBy(t), n.contains(e) || (this._isValid = !1, this._errorMsg = \"Buffer envelope is incorrect\", this._errorIndicator = this._input.getFactory().toGeometry(n)), this.report(\"Envelope\");\n  }, Bi.prototype.checkDistance = function () {\n    var t = new Gi(this._input, this._distance, this._result);\n    t.isValid() || (this._isValid = !1, this._errorMsg = t.getErrorMessage(), this._errorLocation = t.getErrorLocation(), this._errorIndicator = t.getErrorIndicator()), this.report(\"Distance\");\n  }, Bi.prototype.checkArea = function () {\n    var t = this._input.getArea(),\n        e = this._result.getArea();\n\n    this._distance > 0 && t > e && (this._isValid = !1, this._errorMsg = \"Area of positive buffer is smaller than input\", this._errorIndicator = this._result), this._distance < 0 && t < e && (this._isValid = !1, this._errorMsg = \"Area of negative buffer is larger than input\", this._errorIndicator = this._result), this.report(\"Area\");\n  }, Bi.prototype.checkPolygonal = function () {\n    this._result instanceof $t || this._result instanceof ne || (this._isValid = !1), this._errorMsg = \"Result is not polygonal\", this._errorIndicator = this._result, this.report(\"Polygonal\");\n  }, Bi.prototype.getErrorIndicator = function () {\n    return this._errorIndicator;\n  }, Bi.prototype.getErrorLocation = function () {\n    return this._errorLocation;\n  }, Bi.prototype.checkExpectedEmpty = function () {\n    return this._input.getDimension() >= 2 ? null : this._distance > 0 ? null : (this._result.isEmpty() || (this._isValid = !1, this._errorMsg = \"Result is non-empty\", this._errorIndicator = this._result), void this.report(\"ExpectedEmpty\"));\n  }, Bi.prototype.report = function (t) {\n    if (!Bi.VERBOSE) return null;\n    Y.out.println(\"Check \" + t + \": \" + (this._isValid ? \"passed\" : \"FAILED\"));\n  }, Bi.prototype.getErrorMessage = function () {\n    return this._errorMsg;\n  }, Bi.prototype.interfaces_ = function () {\n    return [];\n  }, Bi.prototype.getClass = function () {\n    return Bi;\n  }, Bi.isValidMsg = function (t, e, n) {\n    var i = new Bi(t, e, n);\n    return i.isValid() ? null : i.getErrorMessage();\n  }, Bi.isValid = function (t, e, n) {\n    return !!new Bi(t, e, n).isValid();\n  }, Vi.VERBOSE.get = function () {\n    return !1;\n  }, Vi.MAX_ENV_DIFF_FRAC.get = function () {\n    return .012;\n  }, Object.defineProperties(Bi, Vi);\n\n  var Ui = function () {\n    this._pts = null, this._data = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this._pts = t, this._data = e;\n  };\n\n  Ui.prototype.getCoordinates = function () {\n    return this._pts;\n  }, Ui.prototype.size = function () {\n    return this._pts.length;\n  }, Ui.prototype.getCoordinate = function (t) {\n    return this._pts[t];\n  }, Ui.prototype.isClosed = function () {\n    return this._pts[0].equals(this._pts[this._pts.length - 1]);\n  }, Ui.prototype.getSegmentOctant = function (t) {\n    return t === this._pts.length - 1 ? -1 : pn.octant(this.getCoordinate(t), this.getCoordinate(t + 1));\n  }, Ui.prototype.setData = function (t) {\n    this._data = t;\n  }, Ui.prototype.getData = function () {\n    return this._data;\n  }, Ui.prototype.toString = function () {\n    return Z.toLineString(new ue(this._pts));\n  }, Ui.prototype.interfaces_ = function () {\n    return [hn];\n  }, Ui.prototype.getClass = function () {\n    return Ui;\n  };\n\n  var zi = function () {\n    this._findAllIntersections = !1, this._isCheckEndSegmentsOnly = !1, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new Nt(), this._intersectionCount = 0, this._keepIntersections = !0;\n    var t = arguments[0];\n    this._li = t, this._interiorIntersection = null;\n  };\n\n  zi.prototype.getInteriorIntersection = function () {\n    return this._interiorIntersection;\n  }, zi.prototype.setCheckEndSegmentsOnly = function (t) {\n    this._isCheckEndSegmentsOnly = t;\n  }, zi.prototype.getIntersectionSegments = function () {\n    return this._intSegments;\n  }, zi.prototype.count = function () {\n    return this._intersectionCount;\n  }, zi.prototype.getIntersections = function () {\n    return this._intersections;\n  }, zi.prototype.setFindAllIntersections = function (t) {\n    this._findAllIntersections = t;\n  }, zi.prototype.setKeepIntersections = function (t) {\n    this._keepIntersections = t;\n  }, zi.prototype.processIntersections = function (t, e, n, i) {\n    if (!this._findAllIntersections && this.hasIntersection()) return null;\n    if (t === n && e === i) return null;\n\n    if (this._isCheckEndSegmentsOnly) {\n      if (!(this.isEndSegment(t, e) || this.isEndSegment(n, i))) return null;\n    }\n\n    var r = t.getCoordinates()[e],\n        o = t.getCoordinates()[e + 1],\n        s = n.getCoordinates()[i],\n        a = n.getCoordinates()[i + 1];\n    this._li.computeIntersection(r, o, s, a), this._li.hasIntersection() && this._li.isInteriorIntersection() && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = r, this._intSegments[1] = o, this._intSegments[2] = s, this._intSegments[3] = a, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++);\n  }, zi.prototype.isEndSegment = function (t, e) {\n    return 0 === e || e >= t.size() - 2;\n  }, zi.prototype.hasIntersection = function () {\n    return null !== this._interiorIntersection;\n  }, zi.prototype.isDone = function () {\n    return !this._findAllIntersections && null !== this._interiorIntersection;\n  }, zi.prototype.interfaces_ = function () {\n    return [Wn];\n  }, zi.prototype.getClass = function () {\n    return zi;\n  }, zi.createAllIntersectionsFinder = function (t) {\n    var e = new zi(t);\n    return e.setFindAllIntersections(!0), e;\n  }, zi.createAnyIntersectionFinder = function (t) {\n    return new zi(t);\n  }, zi.createIntersectionCounter = function (t) {\n    var e = new zi(t);\n    return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e;\n  };\n\n  var Xi = function () {\n    this._li = new rt(), this._segStrings = null, this._findAllIntersections = !1, this._segInt = null, this._isValid = !0;\n    var t = arguments[0];\n    this._segStrings = t;\n  };\n\n  Xi.prototype.execute = function () {\n    if (null !== this._segInt) return null;\n    this.checkInteriorIntersections();\n  }, Xi.prototype.getIntersections = function () {\n    return this._segInt.getIntersections();\n  }, Xi.prototype.isValid = function () {\n    return this.execute(), this._isValid;\n  }, Xi.prototype.setFindAllIntersections = function (t) {\n    this._findAllIntersections = t;\n  }, Xi.prototype.checkInteriorIntersections = function () {\n    this._isValid = !0, this._segInt = new zi(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections);\n    var t = new xn();\n    if (t.setSegmentIntersector(this._segInt), t.computeNodes(this._segStrings), this._segInt.hasIntersection()) return this._isValid = !1, null;\n  }, Xi.prototype.checkValid = function () {\n    if (this.execute(), !this._isValid) throw new we(this.getErrorMessage(), this._segInt.getInteriorIntersection());\n  }, Xi.prototype.getErrorMessage = function () {\n    if (this._isValid) return \"no intersections found\";\n\n    var t = this._segInt.getIntersectionSegments();\n\n    return \"found non-noded intersection between \" + Z.toLineString(t[0], t[1]) + \" and \" + Z.toLineString(t[2], t[3]);\n  }, Xi.prototype.interfaces_ = function () {\n    return [];\n  }, Xi.prototype.getClass = function () {\n    return Xi;\n  }, Xi.computeIntersections = function (t) {\n    var e = new Xi(t);\n    return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections();\n  };\n\n  var Yi = function t() {\n    this._nv = null;\n    var e = arguments[0];\n    this._nv = new Xi(t.toSegmentStrings(e));\n  };\n\n  Yi.prototype.checkValid = function () {\n    this._nv.checkValid();\n  }, Yi.prototype.interfaces_ = function () {\n    return [];\n  }, Yi.prototype.getClass = function () {\n    return Yi;\n  }, Yi.toSegmentStrings = function (t) {\n    for (var e = new Nt(), n = t.iterator(); n.hasNext();) {\n      var i = n.next();\n      e.add(new Ui(i.getCoordinates(), i));\n    }\n\n    return e;\n  }, Yi.checkValid = function (t) {\n    new Yi(t).checkValid();\n  };\n\n  var ki = function (t) {\n    this._mapOp = t;\n  };\n\n  ki.prototype.map = function (t) {\n    for (var e = new Nt(), n = 0; n < t.getNumGeometries(); n++) {\n      var i = this._mapOp.map(t.getGeometryN(n));\n\n      i.isEmpty() || e.add(i);\n    }\n\n    return t.getFactory().createGeometryCollection(_e.toGeometryArray(e));\n  }, ki.prototype.interfaces_ = function () {\n    return [];\n  }, ki.prototype.getClass = function () {\n    return ki;\n  }, ki.map = function (t, e) {\n    return new ki(e).map(t);\n  };\n\n  var ji = function () {\n    this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new Nt(), this._resultLineList = new Nt();\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n    this._op = t, this._geometryFactory = e, this._ptLocator = n;\n  };\n\n  ji.prototype.collectLines = function (t) {\n    for (var e = this._op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {\n      var n = e.next();\n      this.collectLineEdge(n, t, this._lineEdgesList), this.collectBoundaryTouchEdge(n, t, this._lineEdgesList);\n    }\n  }, ji.prototype.labelIsolatedLine = function (t, e) {\n    var n = this._ptLocator.locate(t.getCoordinate(), this._op.getArgGeometry(e));\n\n    t.getLabel().setLocation(e, n);\n  }, ji.prototype.build = function (t) {\n    return this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this._resultLineList;\n  }, ji.prototype.collectLineEdge = function (t, e, n) {\n    var i = t.getLabel(),\n        r = t.getEdge();\n    t.isLineEdge() && (t.isVisited() || !Lr.isResultOfOp(i, e) || r.isCovered() || (n.add(r), t.setVisitedEdge(!0)));\n  }, ji.prototype.findCoveredLineEdges = function () {\n    for (var t = this._op.getGraph().getNodes().iterator(); t.hasNext();) {\n      t.next().getEdges().findCoveredLineEdges();\n    }\n\n    for (var e = this._op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {\n      var n = e.next(),\n          i = n.getEdge();\n\n      if (n.isLineEdge() && !i.isCoveredSet()) {\n        var r = this._op.isCoveredByA(n.getCoordinate());\n\n        i.setCovered(r);\n      }\n    }\n  }, ji.prototype.labelIsolatedLines = function (t) {\n    for (var e = t.iterator(); e.hasNext();) {\n      var n = e.next(),\n          i = n.getLabel();\n      n.isIsolated() && (i.isNull(0) ? this.labelIsolatedLine(n, 0) : this.labelIsolatedLine(n, 1));\n    }\n  }, ji.prototype.buildLines = function (t) {\n    for (var e = this._lineEdgesList.iterator(); e.hasNext();) {\n      var n = e.next(),\n          i = this._geometryFactory.createLineString(n.getCoordinates());\n\n      this._resultLineList.add(i), n.setInResult(!0);\n    }\n  }, ji.prototype.collectBoundaryTouchEdge = function (t, e, n) {\n    var i = t.getLabel();\n    return t.isLineEdge() ? null : t.isVisited() ? null : t.isInteriorAreaEdge() ? null : t.getEdge().isInResult() ? null : (et.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()), void (Lr.isResultOfOp(i, e) && e === Lr.INTERSECTION && (n.add(t.getEdge()), t.setVisitedEdge(!0))));\n  }, ji.prototype.interfaces_ = function () {\n    return [];\n  }, ji.prototype.getClass = function () {\n    return ji;\n  };\n\n  var Hi = function () {\n    this._op = null, this._geometryFactory = null, this._resultPointList = new Nt();\n    var t = arguments[0],\n        e = arguments[1];\n    this._op = t, this._geometryFactory = e;\n  };\n\n  Hi.prototype.filterCoveredNodeToPoint = function (t) {\n    var e = t.getCoordinate();\n\n    if (!this._op.isCoveredByLA(e)) {\n      var n = this._geometryFactory.createPoint(e);\n\n      this._resultPointList.add(n);\n    }\n  }, Hi.prototype.extractNonCoveredResultNodes = function (t) {\n    for (var e = this._op.getGraph().getNodes().iterator(); e.hasNext();) {\n      var n = e.next();\n\n      if (!n.isInResult() && !n.isIncidentEdgeInResult() && (0 === n.getEdges().getDegree() || t === Lr.INTERSECTION)) {\n        var i = n.getLabel();\n        Lr.isResultOfOp(i, t) && this.filterCoveredNodeToPoint(n);\n      }\n    }\n  }, Hi.prototype.build = function (t) {\n    return this.extractNonCoveredResultNodes(t), this._resultPointList;\n  }, Hi.prototype.interfaces_ = function () {\n    return [];\n  }, Hi.prototype.getClass = function () {\n    return Hi;\n  };\n\n  var Wi = function () {\n    this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = !0, this._preserveGeometryCollectionType = !0, this._preserveCollections = !1, this._preserveType = !1;\n  };\n\n  Wi.prototype.transformPoint = function (t, e) {\n    return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t));\n  }, Wi.prototype.transformPolygon = function (t, e) {\n    var n = !0,\n        i = this.transformLinearRing(t.getExteriorRing(), t);\n    null !== i && i instanceof ee && !i.isEmpty() || (n = !1);\n\n    for (var r = new Nt(), o = 0; o < t.getNumInteriorRing(); o++) {\n      var s = this.transformLinearRing(t.getInteriorRingN(o), t);\n      null === s || s.isEmpty() || (s instanceof ee || (n = !1), r.add(s));\n    }\n\n    if (n) return this._factory.createPolygon(i, r.toArray([]));\n    var a = new Nt();\n    return null !== i && a.add(i), a.addAll(r), this._factory.buildGeometry(a);\n  }, Wi.prototype.createCoordinateSequence = function (t) {\n    return this._factory.getCoordinateSequenceFactory().create(t);\n  }, Wi.prototype.getInputGeometry = function () {\n    return this._inputGeom;\n  }, Wi.prototype.transformMultiLineString = function (t, e) {\n    for (var n = new Nt(), i = 0; i < t.getNumGeometries(); i++) {\n      var r = this.transformLineString(t.getGeometryN(i), t);\n      null !== r && (r.isEmpty() || n.add(r));\n    }\n\n    return this._factory.buildGeometry(n);\n  }, Wi.prototype.transformCoordinates = function (t, e) {\n    return this.copy(t);\n  }, Wi.prototype.transformLineString = function (t, e) {\n    return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t));\n  }, Wi.prototype.transformMultiPoint = function (t, e) {\n    for (var n = new Nt(), i = 0; i < t.getNumGeometries(); i++) {\n      var r = this.transformPoint(t.getGeometryN(i), t);\n      null !== r && (r.isEmpty() || n.add(r));\n    }\n\n    return this._factory.buildGeometry(n);\n  }, Wi.prototype.transformMultiPolygon = function (t, e) {\n    for (var n = new Nt(), i = 0; i < t.getNumGeometries(); i++) {\n      var r = this.transformPolygon(t.getGeometryN(i), t);\n      null !== r && (r.isEmpty() || n.add(r));\n    }\n\n    return this._factory.buildGeometry(n);\n  }, Wi.prototype.copy = function (t) {\n    return t.copy();\n  }, Wi.prototype.transformGeometryCollection = function (t, e) {\n    for (var n = new Nt(), i = 0; i < t.getNumGeometries(); i++) {\n      var r = this.transform(t.getGeometryN(i));\n      null !== r && (this._pruneEmptyGeometry && r.isEmpty() || n.add(r));\n    }\n\n    return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(_e.toGeometryArray(n)) : this._factory.buildGeometry(n);\n  }, Wi.prototype.transform = function (t) {\n    if (this._inputGeom = t, this._factory = t.getFactory(), t instanceof Qt) return this.transformPoint(t, null);\n    if (t instanceof te) return this.transformMultiPoint(t, null);\n    if (t instanceof ee) return this.transformLinearRing(t, null);\n    if (t instanceof Kt) return this.transformLineString(t, null);\n    if (t instanceof Xt) return this.transformMultiLineString(t, null);\n    if (t instanceof $t) return this.transformPolygon(t, null);\n    if (t instanceof ne) return this.transformMultiPolygon(t, null);\n    if (t instanceof zt) return this.transformGeometryCollection(t, null);\n    throw new m(\"Unknown Geometry subtype: \" + t.getClass().getName());\n  }, Wi.prototype.transformLinearRing = function (t, e) {\n    var n = this.transformCoordinates(t.getCoordinateSequence(), t);\n    if (null === n) return this._factory.createLinearRing(null);\n    var i = n.size();\n    return i > 0 && i < 4 && !this._preserveType ? this._factory.createLineString(n) : this._factory.createLinearRing(n);\n  }, Wi.prototype.interfaces_ = function () {\n    return [];\n  }, Wi.prototype.getClass = function () {\n    return Wi;\n  };\n\n  var Ki = function t() {\n    if (this._snapTolerance = 0, this._srcPts = null, this._seg = new dn(), this._allowSnappingToSourceVertices = !1, this._isClosed = !1, arguments[0] instanceof Kt && \"number\" == typeof arguments[1]) {\n      var e = arguments[0],\n          n = arguments[1];\n      t.call(this, e.getCoordinates(), n);\n    } else if (arguments[0] instanceof Array && \"number\" == typeof arguments[1]) {\n      var i = arguments[0],\n          r = arguments[1];\n      this._srcPts = i, this._isClosed = t.isClosed(i), this._snapTolerance = r;\n    }\n  };\n\n  Ki.prototype.snapVertices = function (t, e) {\n    for (var n = this._isClosed ? t.size() - 1 : t.size(), i = 0; i < n; i++) {\n      var r = t.get(i),\n          o = this.findSnapForVertex(r, e);\n      null !== o && (t.set(i, new C(o)), 0 === i && this._isClosed && t.set(t.size() - 1, new C(o)));\n    }\n  }, Ki.prototype.findSnapForVertex = function (t, e) {\n    for (var n = 0; n < e.length; n++) {\n      if (t.equals2D(e[n])) return null;\n      if (t.distance(e[n]) < this._snapTolerance) return e[n];\n    }\n\n    return null;\n  }, Ki.prototype.snapTo = function (t) {\n    var e = new St(this._srcPts);\n    this.snapVertices(e, t), this.snapSegments(e, t);\n    return e.toCoordinateArray();\n  }, Ki.prototype.snapSegments = function (t, e) {\n    if (0 === e.length) return null;\n    var n = e.length;\n    e[0].equals2D(e[e.length - 1]) && (n = e.length - 1);\n\n    for (var i = 0; i < n; i++) {\n      var r = e[i],\n          o = this.findSegmentIndexToSnap(r, t);\n      o >= 0 && t.add(o + 1, new C(r), !1);\n    }\n  }, Ki.prototype.findSegmentIndexToSnap = function (t, e) {\n    for (var n = v.MAX_VALUE, i = -1, r = 0; r < e.size() - 1; r++) {\n      if (this._seg.p0 = e.get(r), this._seg.p1 = e.get(r + 1), this._seg.p0.equals2D(t) || this._seg.p1.equals2D(t)) {\n        if (this._allowSnappingToSourceVertices) continue;\n        return -1;\n      }\n\n      var o = this._seg.distance(t);\n\n      o < this._snapTolerance && o < n && (n = o, i = r);\n    }\n\n    return i;\n  }, Ki.prototype.setAllowSnappingToSourceVertices = function (t) {\n    this._allowSnappingToSourceVertices = t;\n  }, Ki.prototype.interfaces_ = function () {\n    return [];\n  }, Ki.prototype.getClass = function () {\n    return Ki;\n  }, Ki.isClosed = function (t) {\n    return !(t.length <= 1) && t[0].equals2D(t[t.length - 1]);\n  };\n\n  var Ji = function (t) {\n    this._srcGeom = t || null;\n  },\n      Qi = {\n    SNAP_PRECISION_FACTOR: {\n      configurable: !0\n    }\n  };\n\n  Ji.prototype.snapTo = function (t, e) {\n    var n = this.extractTargetCoordinates(t);\n    return new Zi(e, n).transform(this._srcGeom);\n  }, Ji.prototype.snapToSelf = function (t, e) {\n    var n = this.extractTargetCoordinates(this._srcGeom),\n        i = new Zi(t, n, !0).transform(this._srcGeom),\n        r = i;\n    return e && T(r, Zt) && (r = i.buffer(0)), r;\n  }, Ji.prototype.computeSnapTolerance = function (t) {\n    return this.computeMinimumSegmentLength(t) / 10;\n  }, Ji.prototype.extractTargetCoordinates = function (t) {\n    for (var e = new f(), n = t.getCoordinates(), i = 0; i < n.length; i++) e.add(n[i]);\n\n    return e.toArray(new Array(0).fill(null));\n  }, Ji.prototype.computeMinimumSegmentLength = function (t) {\n    for (var e = v.MAX_VALUE, n = 0; n < t.length - 1; n++) {\n      var i = t[n].distance(t[n + 1]);\n      i < e && (e = i);\n    }\n\n    return e;\n  }, Ji.prototype.interfaces_ = function () {\n    return [];\n  }, Ji.prototype.getClass = function () {\n    return Ji;\n  }, Ji.snap = function (t, e, n) {\n    var i = new Array(2).fill(null),\n        r = new Ji(t);\n    i[0] = r.snapTo(e, n);\n    var o = new Ji(e);\n    return i[1] = o.snapTo(i[0], n), i;\n  }, Ji.computeOverlaySnapTolerance = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n          e = Ji.computeSizeBasedSnapTolerance(t),\n          n = t.getPrecisionModel();\n\n      if (n.getType() === fe.FIXED) {\n        var i = 1 / n.getScale() * 2 / 1.415;\n        i > e && (e = i);\n      }\n\n      return e;\n    }\n\n    if (2 === arguments.length) {\n      var r = arguments[0],\n          o = arguments[1];\n      return Math.min(Ji.computeOverlaySnapTolerance(r), Ji.computeOverlaySnapTolerance(o));\n    }\n  }, Ji.computeSizeBasedSnapTolerance = function (t) {\n    var e = t.getEnvelopeInternal();\n    return Math.min(e.getHeight(), e.getWidth()) * Ji.SNAP_PRECISION_FACTOR;\n  }, Ji.snapToSelf = function (t, e, n) {\n    return new Ji(t).snapToSelf(e, n);\n  }, Qi.SNAP_PRECISION_FACTOR.get = function () {\n    return 1e-9;\n  }, Object.defineProperties(Ji, Qi);\n\n  var Zi = function (t) {\n    function e(e, n, i) {\n      t.call(this), this._snapTolerance = e || null, this._snapPts = n || null, this._isSelfSnap = void 0 !== i && i;\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.snapLine = function (t, e) {\n      var n = new Ki(t, this._snapTolerance);\n      return n.setAllowSnappingToSourceVertices(this._isSelfSnap), n.snapTo(e);\n    }, e.prototype.transformCoordinates = function (t, e) {\n      var n = t.toCoordinateArray(),\n          i = this.snapLine(n, this._snapPts);\n      return this._factory.getCoordinateSequenceFactory().create(i);\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e;\n  }(Wi),\n      $i = function () {\n    this._isFirst = !0, this._commonMantissaBitsCount = 53, this._commonBits = 0, this._commonSignExp = null;\n  };\n\n  $i.prototype.getCommon = function () {\n    return v.longBitsToDouble(this._commonBits);\n  }, $i.prototype.add = function (t) {\n    var e = v.doubleToLongBits(t);\n    if (this._isFirst) return this._commonBits = e, this._commonSignExp = $i.signExpBits(this._commonBits), this._isFirst = !1, null;\n    if ($i.signExpBits(e) !== this._commonSignExp) return this._commonBits = 0, null;\n    this._commonMantissaBitsCount = $i.numCommonMostSigMantissaBits(this._commonBits, e), this._commonBits = $i.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));\n  }, $i.prototype.toString = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n          e = v.longBitsToDouble(t),\n          n = \"0000000000000000000000000000000000000000000000000000000000000000\" + v.toBinaryString(t),\n          i = n.substring(n.length - 64);\n      return i.substring(0, 1) + \"  \" + i.substring(1, 12) + \"(exp) \" + i.substring(12) + \" [ \" + e + \" ]\";\n    }\n  }, $i.prototype.interfaces_ = function () {\n    return [];\n  }, $i.prototype.getClass = function () {\n    return $i;\n  }, $i.getBit = function (t, e) {\n    return 0 != (t & 1 << e) ? 1 : 0;\n  }, $i.signExpBits = function (t) {\n    return t >> 52;\n  }, $i.zeroLowerBits = function (t, e) {\n    return t & ~((1 << e) - 1);\n  }, $i.numCommonMostSigMantissaBits = function (t, e) {\n    for (var n = 0, i = 52; i >= 0; i--) {\n      if ($i.getBit(t, i) !== $i.getBit(e, i)) return n;\n      n++;\n    }\n\n    return 52;\n  };\n\n  var tr = function () {\n    this._commonCoord = null, this._ccFilter = new nr();\n  },\n      er = {\n    CommonCoordinateFilter: {\n      configurable: !0\n    },\n    Translater: {\n      configurable: !0\n    }\n  };\n\n  tr.prototype.addCommonBits = function (t) {\n    var e = new ir(this._commonCoord);\n    t.apply(e), t.geometryChanged();\n  }, tr.prototype.removeCommonBits = function (t) {\n    if (0 === this._commonCoord.x && 0 === this._commonCoord.y) return t;\n    var e = new C(this._commonCoord);\n    e.x = -e.x, e.y = -e.y;\n    var n = new ir(e);\n    return t.apply(n), t.geometryChanged(), t;\n  }, tr.prototype.getCommonCoordinate = function () {\n    return this._commonCoord;\n  }, tr.prototype.add = function (t) {\n    t.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate();\n  }, tr.prototype.interfaces_ = function () {\n    return [];\n  }, tr.prototype.getClass = function () {\n    return tr;\n  }, er.CommonCoordinateFilter.get = function () {\n    return nr;\n  }, er.Translater.get = function () {\n    return ir;\n  }, Object.defineProperties(tr, er);\n\n  var nr = function () {\n    this._commonBitsX = new $i(), this._commonBitsY = new $i();\n  };\n\n  nr.prototype.filter = function (t) {\n    this._commonBitsX.add(t.x), this._commonBitsY.add(t.y);\n  }, nr.prototype.getCommonCoordinate = function () {\n    return new C(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());\n  }, nr.prototype.interfaces_ = function () {\n    return [ft];\n  }, nr.prototype.getClass = function () {\n    return nr;\n  };\n\n  var ir = function () {\n    this.trans = null;\n    var t = arguments[0];\n    this.trans = t;\n  };\n\n  ir.prototype.filter = function (t, e) {\n    var n = t.getOrdinate(e, 0) + this.trans.x,\n        i = t.getOrdinate(e, 1) + this.trans.y;\n    t.setOrdinate(e, 0, n), t.setOrdinate(e, 1, i);\n  }, ir.prototype.isDone = function () {\n    return !1;\n  }, ir.prototype.isGeometryChanged = function () {\n    return !0;\n  }, ir.prototype.interfaces_ = function () {\n    return [Ut];\n  }, ir.prototype.getClass = function () {\n    return ir;\n  };\n\n  var rr = function (t, e) {\n    this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null, this._geom[0] = t, this._geom[1] = e, this.computeSnapTolerance();\n  };\n\n  rr.prototype.selfSnap = function (t) {\n    return new Ji(t).snapTo(t, this._snapTolerance);\n  }, rr.prototype.removeCommonBits = function (t) {\n    this._cbr = new tr(), this._cbr.add(t[0]), this._cbr.add(t[1]);\n    var e = new Array(2).fill(null);\n    return e[0] = this._cbr.removeCommonBits(t[0].copy()), e[1] = this._cbr.removeCommonBits(t[1].copy()), e;\n  }, rr.prototype.prepareResult = function (t) {\n    return this._cbr.addCommonBits(t), t;\n  }, rr.prototype.getResultGeometry = function (t) {\n    var e = this.snap(this._geom),\n        n = Lr.overlayOp(e[0], e[1], t);\n    return this.prepareResult(n);\n  }, rr.prototype.checkValid = function (t) {\n    t.isValid() || Y.out.println(\"Snapped geometry is invalid\");\n  }, rr.prototype.computeSnapTolerance = function () {\n    this._snapTolerance = Ji.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);\n  }, rr.prototype.snap = function (t) {\n    var e = this.removeCommonBits(t);\n    return Ji.snap(e[0], e[1], this._snapTolerance);\n  }, rr.prototype.interfaces_ = function () {\n    return [];\n  }, rr.prototype.getClass = function () {\n    return rr;\n  }, rr.overlayOp = function (t, e, n) {\n    return new rr(t, e).getResultGeometry(n);\n  }, rr.union = function (t, e) {\n    return rr.overlayOp(t, e, Lr.UNION);\n  }, rr.intersection = function (t, e) {\n    return rr.overlayOp(t, e, Lr.INTERSECTION);\n  }, rr.symDifference = function (t, e) {\n    return rr.overlayOp(t, e, Lr.SYMDIFFERENCE);\n  }, rr.difference = function (t, e) {\n    return rr.overlayOp(t, e, Lr.DIFFERENCE);\n  };\n\n  var or = function (t, e) {\n    this._geom = new Array(2).fill(null), this._geom[0] = t, this._geom[1] = e;\n  };\n\n  or.prototype.getResultGeometry = function (t) {\n    var e = null,\n        n = !1,\n        i = null;\n\n    try {\n      e = Lr.overlayOp(this._geom[0], this._geom[1], t);\n      n = !0;\n    } catch (t) {\n      if (!(t instanceof $)) throw t;\n      i = t;\n    }\n\n    if (!n) try {\n      e = rr.overlayOp(this._geom[0], this._geom[1], t);\n    } catch (t) {\n      throw t instanceof $ ? i : t;\n    }\n    return e;\n  }, or.prototype.interfaces_ = function () {\n    return [];\n  }, or.prototype.getClass = function () {\n    return or;\n  }, or.overlayOp = function (t, e, n) {\n    return new or(t, e).getResultGeometry(n);\n  }, or.union = function (t, e) {\n    return or.overlayOp(t, e, Lr.UNION);\n  }, or.intersection = function (t, e) {\n    return or.overlayOp(t, e, Lr.INTERSECTION);\n  }, or.symDifference = function (t, e) {\n    return or.overlayOp(t, e, Lr.SYMDIFFERENCE);\n  }, or.difference = function (t, e) {\n    return or.overlayOp(t, e, Lr.DIFFERENCE);\n  };\n\n  var sr = function () {\n    this.mce = null, this.chainIndex = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.mce = t, this.chainIndex = e;\n  };\n\n  sr.prototype.computeIntersections = function (t, e) {\n    this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e);\n  }, sr.prototype.interfaces_ = function () {\n    return [];\n  }, sr.prototype.getClass = function () {\n    return sr;\n  };\n\n  var ar = function t() {\n    if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, 2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this._eventType = t.DELETE, this._xValue = e, this._insertEvent = n;\n    } else if (3 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1],\n          o = arguments[2];\n      this._eventType = t.INSERT, this._label = i, this._xValue = r, this._obj = o;\n    }\n  },\n      ur = {\n    INSERT: {\n      configurable: !0\n    },\n    DELETE: {\n      configurable: !0\n    }\n  };\n\n  ar.prototype.isDelete = function () {\n    return this._eventType === ar.DELETE;\n  }, ar.prototype.setDeleteEventIndex = function (t) {\n    this._deleteEventIndex = t;\n  }, ar.prototype.getObject = function () {\n    return this._obj;\n  }, ar.prototype.compareTo = function (t) {\n    var e = t;\n    return this._xValue < e._xValue ? -1 : this._xValue > e._xValue ? 1 : this._eventType < e._eventType ? -1 : this._eventType > e._eventType ? 1 : 0;\n  }, ar.prototype.getInsertEvent = function () {\n    return this._insertEvent;\n  }, ar.prototype.isInsert = function () {\n    return this._eventType === ar.INSERT;\n  }, ar.prototype.isSameLabel = function (t) {\n    return null !== this._label && this._label === t._label;\n  }, ar.prototype.getDeleteEventIndex = function () {\n    return this._deleteEventIndex;\n  }, ar.prototype.interfaces_ = function () {\n    return [E];\n  }, ar.prototype.getClass = function () {\n    return ar;\n  }, ur.INSERT.get = function () {\n    return 1;\n  }, ur.DELETE.get = function () {\n    return 2;\n  }, Object.defineProperties(ar, ur);\n\n  var lr = function () {};\n\n  lr.prototype.interfaces_ = function () {\n    return [];\n  }, lr.prototype.getClass = function () {\n    return lr;\n  };\n\n  var cr = function () {\n    this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = !1, this._isDoneWhenProperInt = !1;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n    this._li = t, this._includeProper = e, this._recordIsolated = n;\n  };\n\n  cr.prototype.isTrivialIntersection = function (t, e, n, i) {\n    if (t === n && 1 === this._li.getIntersectionNum()) {\n      if (cr.isAdjacentSegments(e, i)) return !0;\n\n      if (t.isClosed()) {\n        var r = t.getNumPoints() - 1;\n        if (0 === e && i === r || 0 === i && e === r) return !0;\n      }\n    }\n\n    return !1;\n  }, cr.prototype.getProperIntersectionPoint = function () {\n    return this._properIntersectionPoint;\n  }, cr.prototype.setIsDoneIfProperInt = function (t) {\n    this._isDoneWhenProperInt = t;\n  }, cr.prototype.hasProperInteriorIntersection = function () {\n    return this._hasProperInterior;\n  }, cr.prototype.isBoundaryPointInternal = function (t, e) {\n    for (var n = e.iterator(); n.hasNext();) {\n      var i = n.next().getCoordinate();\n      if (t.isIntersection(i)) return !0;\n    }\n\n    return !1;\n  }, cr.prototype.hasProperIntersection = function () {\n    return this._hasProper;\n  }, cr.prototype.hasIntersection = function () {\n    return this._hasIntersection;\n  }, cr.prototype.isDone = function () {\n    return this._isDone;\n  }, cr.prototype.isBoundaryPoint = function (t, e) {\n    return null !== e && (!!this.isBoundaryPointInternal(t, e[0]) || !!this.isBoundaryPointInternal(t, e[1]));\n  }, cr.prototype.setBoundaryNodes = function (t, e) {\n    this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = t, this._bdyNodes[1] = e;\n  }, cr.prototype.addIntersections = function (t, e, n, i) {\n    if (t === n && e === i) return null;\n    this.numTests++;\n    var r = t.getCoordinates()[e],\n        o = t.getCoordinates()[e + 1],\n        s = n.getCoordinates()[i],\n        a = n.getCoordinates()[i + 1];\n    this._li.computeIntersection(r, o, s, a), this._li.hasIntersection() && (this._recordIsolated && (t.setIsolated(!1), n.setIsolated(!1)), this._numIntersections++, this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, !this._includeProper && this._li.isProper() || (t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = !0, this._isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = !0))));\n  }, cr.prototype.interfaces_ = function () {\n    return [];\n  }, cr.prototype.getClass = function () {\n    return cr;\n  }, cr.isAdjacentSegments = function (t, e) {\n    return 1 === Math.abs(t - e);\n  };\n\n  var pr = function (t) {\n    function e() {\n      t.call(this), this.events = new Nt(), this.nOverlaps = null;\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.prepareEvents = function () {\n      $e.sort(this.events);\n\n      for (var t = 0; t < this.events.size(); t++) {\n        var e = this.events.get(t);\n        e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t);\n      }\n    }, e.prototype.computeIntersections = function () {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        this.nOverlaps = 0, this.prepareEvents();\n\n        for (var e = 0; e < this.events.size(); e++) {\n          var n = this.events.get(e);\n          if (n.isInsert() && this.processOverlaps(e, n.getDeleteEventIndex(), n, t), t.isDone()) break;\n        }\n      } else if (3 === arguments.length) if (arguments[2] instanceof cr && T(arguments[0], xt) && T(arguments[1], xt)) {\n        var i = arguments[0],\n            r = arguments[1],\n            o = arguments[2];\n        this.addEdges(i, i), this.addEdges(r, r), this.computeIntersections(o);\n      } else if (\"boolean\" == typeof arguments[2] && T(arguments[0], xt) && arguments[1] instanceof cr) {\n        var s = arguments[0],\n            a = arguments[1];\n        arguments[2] ? this.addEdges(s, null) : this.addEdges(s), this.computeIntersections(a);\n      }\n    }, e.prototype.addEdge = function (t, e) {\n      for (var n = t.getMonotoneChainEdge(), i = n.getStartIndexes(), r = 0; r < i.length - 1; r++) {\n        var o = new sr(n, r),\n            s = new ar(e, n.getMinX(r), o);\n        this.events.add(s), this.events.add(new ar(n.getMaxX(r), s));\n      }\n    }, e.prototype.processOverlaps = function (t, e, n, i) {\n      for (var r = n.getObject(), o = t; o < e; o++) {\n        var s = this.events.get(o);\n\n        if (s.isInsert()) {\n          var a = s.getObject();\n          n.isSameLabel(s) || (r.computeIntersections(a, i), this.nOverlaps++);\n        }\n      }\n    }, e.prototype.addEdges = function () {\n      if (1 === arguments.length) for (var t = arguments[0].iterator(); t.hasNext();) {\n        var e = t.next();\n        this.addEdge(e, e);\n      } else if (2 === arguments.length) for (var n = arguments[0], i = arguments[1], r = n.iterator(); r.hasNext();) {\n        var o = r.next();\n        this.addEdge(o, i);\n      }\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e;\n  }(lr),\n      hr = function () {\n    this._min = v.POSITIVE_INFINITY, this._max = v.NEGATIVE_INFINITY;\n  },\n      fr = {\n    NodeComparator: {\n      configurable: !0\n    }\n  };\n\n  hr.prototype.getMin = function () {\n    return this._min;\n  }, hr.prototype.intersects = function (t, e) {\n    return !(this._min > e || this._max < t);\n  }, hr.prototype.getMax = function () {\n    return this._max;\n  }, hr.prototype.toString = function () {\n    return Z.toLineString(new C(this._min, 0), new C(this._max, 0));\n  }, hr.prototype.interfaces_ = function () {\n    return [];\n  }, hr.prototype.getClass = function () {\n    return hr;\n  }, fr.NodeComparator.get = function () {\n    return gr;\n  }, Object.defineProperties(hr, fr);\n\n  var gr = function () {};\n\n  gr.prototype.compare = function (t, e) {\n    var n = t,\n        i = e,\n        r = (n._min + n._max) / 2,\n        o = (i._min + i._max) / 2;\n    return r < o ? -1 : r > o ? 1 : 0;\n  }, gr.prototype.interfaces_ = function () {\n    return [N];\n  }, gr.prototype.getClass = function () {\n    return gr;\n  };\n\n  var dr = function (t) {\n    function e() {\n      t.call(this), this._item = null;\n      var e = arguments[0],\n          n = arguments[1],\n          i = arguments[2];\n      this._min = e, this._max = n, this._item = i;\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.query = function (t, e, n) {\n      if (!this.intersects(t, e)) return null;\n      n.visitItem(this._item);\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e;\n  }(hr),\n      yr = function (t) {\n    function e() {\n      t.call(this), this._node1 = null, this._node2 = null;\n      var e = arguments[0],\n          n = arguments[1];\n      this._node1 = e, this._node2 = n, this.buildExtent(this._node1, this._node2);\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.buildExtent = function (t, e) {\n      this._min = Math.min(t._min, e._min), this._max = Math.max(t._max, e._max);\n    }, e.prototype.query = function (t, e, n) {\n      if (!this.intersects(t, e)) return null;\n      null !== this._node1 && this._node1.query(t, e, n), null !== this._node2 && this._node2.query(t, e, n);\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e;\n  }(hr),\n      _r = function () {\n    this._leaves = new Nt(), this._root = null, this._level = 0;\n  };\n\n  _r.prototype.buildTree = function () {\n    $e.sort(this._leaves, new hr.NodeComparator());\n\n    for (var t = this._leaves, e = null, n = new Nt();;) {\n      if (this.buildLevel(t, n), 1 === n.size()) return n.get(0);\n      e = t, t = n, n = e;\n    }\n  }, _r.prototype.insert = function (t, e, n) {\n    if (null !== this._root) throw new Error(\"Index cannot be added to once it has been queried\");\n\n    this._leaves.add(new dr(t, e, n));\n  }, _r.prototype.query = function (t, e, n) {\n    this.init(), this._root.query(t, e, n);\n  }, _r.prototype.buildRoot = function () {\n    if (null !== this._root) return null;\n    this._root = this.buildTree();\n  }, _r.prototype.printNode = function (t) {\n    Y.out.println(Z.toLineString(new C(t._min, this._level), new C(t._max, this._level)));\n  }, _r.prototype.init = function () {\n    if (null !== this._root) return null;\n    this.buildRoot();\n  }, _r.prototype.buildLevel = function (t, e) {\n    this._level++, e.clear();\n\n    for (var n = 0; n < t.size(); n += 2) {\n      var i = t.get(n);\n      if (null === (n + 1 < t.size() ? t.get(n) : null)) e.add(i);else {\n        var r = new yr(t.get(n), t.get(n + 1));\n        e.add(r);\n      }\n    }\n  }, _r.prototype.interfaces_ = function () {\n    return [];\n  }, _r.prototype.getClass = function () {\n    return _r;\n  };\n\n  var mr = function () {\n    this._items = new Nt();\n  };\n\n  mr.prototype.visitItem = function (t) {\n    this._items.add(t);\n  }, mr.prototype.getItems = function () {\n    return this._items;\n  }, mr.prototype.interfaces_ = function () {\n    return [Ke];\n  }, mr.prototype.getClass = function () {\n    return mr;\n  };\n\n  var vr = function () {\n    this._index = null;\n    var t = arguments[0];\n    if (!T(t, Zt)) throw new m(\"Argument must be Polygonal\");\n    this._index = new xr(t);\n  },\n      Ir = {\n    SegmentVisitor: {\n      configurable: !0\n    },\n    IntervalIndexedGeometry: {\n      configurable: !0\n    }\n  };\n\n  vr.prototype.locate = function (t) {\n    var e = new st(t),\n        n = new Er(e);\n    return this._index.query(t.y, t.y, n), e.getLocation();\n  }, vr.prototype.interfaces_ = function () {\n    return [Vn];\n  }, vr.prototype.getClass = function () {\n    return vr;\n  }, Ir.SegmentVisitor.get = function () {\n    return Er;\n  }, Ir.IntervalIndexedGeometry.get = function () {\n    return xr;\n  }, Object.defineProperties(vr, Ir);\n\n  var Er = function () {\n    this._counter = null;\n    var t = arguments[0];\n    this._counter = t;\n  };\n\n  Er.prototype.visitItem = function (t) {\n    var e = t;\n\n    this._counter.countSegment(e.getCoordinate(0), e.getCoordinate(1));\n  }, Er.prototype.interfaces_ = function () {\n    return [Ke];\n  }, Er.prototype.getClass = function () {\n    return Er;\n  };\n\n  var xr = function () {\n    this._index = new _r();\n    var t = arguments[0];\n    this.init(t);\n  };\n\n  xr.prototype.init = function (t) {\n    for (var e = Ci.getLines(t).iterator(); e.hasNext();) {\n      var n = e.next().getCoordinates();\n      this.addLine(n);\n    }\n  }, xr.prototype.addLine = function (t) {\n    for (var e = 1; e < t.length; e++) {\n      var n = new dn(t[e - 1], t[e]),\n          i = Math.min(n.p0.y, n.p1.y),\n          r = Math.max(n.p0.y, n.p1.y);\n\n      this._index.insert(i, r, n);\n    }\n  }, xr.prototype.query = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1],\n          n = new mr();\n      return this._index.query(t, e, n), n.getItems();\n    }\n\n    if (3 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1],\n          o = arguments[2];\n\n      this._index.query(i, r, o);\n    }\n  }, xr.prototype.interfaces_ = function () {\n    return [];\n  }, xr.prototype.getClass = function () {\n    return xr;\n  };\n\n  var Nr = function (t) {\n    function e() {\n      if (t.call(this), this._parentGeom = null, this._lineEdgeMap = new he(), this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = !0, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = !1, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new Si(), 2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1],\n            i = gt.OGC_SFS_BOUNDARY_RULE;\n        this._argIndex = e, this._parentGeom = n, this._boundaryNodeRule = i, null !== n && this.add(n);\n      } else if (3 === arguments.length) {\n        var r = arguments[0],\n            o = arguments[1],\n            s = arguments[2];\n        this._argIndex = r, this._parentGeom = o, this._boundaryNodeRule = s, null !== o && this.add(o);\n      }\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.insertBoundaryPoint = function (t, n) {\n      var i = this._nodes.addNode(n).getLabel(),\n          r = 1;\n\n      w.NONE;\n      i.getLocation(t, Se.ON) === w.BOUNDARY && r++;\n      var o = e.determineBoundary(this._boundaryNodeRule, r);\n      i.setLocation(t, o);\n    }, e.prototype.computeSelfNodes = function () {\n      if (2 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1];\n        return this.computeSelfNodes(t, e, !1);\n      }\n\n      if (3 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1],\n            r = arguments[2],\n            o = new cr(n, !0, !1);\n        o.setIsDoneIfProperInt(r);\n        var s = this.createEdgeSetIntersector(),\n            a = this._parentGeom instanceof ee || this._parentGeom instanceof $t || this._parentGeom instanceof ne,\n            u = i || !a;\n        return s.computeIntersections(this._edges, o, u), this.addSelfIntersectionNodes(this._argIndex), o;\n      }\n    }, e.prototype.computeSplitEdges = function (t) {\n      for (var e = this._edges.iterator(); e.hasNext();) {\n        e.next().eiList.addSplitEdges(t);\n      }\n    }, e.prototype.computeEdgeIntersections = function (t, e, n) {\n      var i = new cr(e, n, !0);\n      i.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes());\n      return this.createEdgeSetIntersector().computeIntersections(this._edges, t._edges, i), i;\n    }, e.prototype.getGeometry = function () {\n      return this._parentGeom;\n    }, e.prototype.getBoundaryNodeRule = function () {\n      return this._boundaryNodeRule;\n    }, e.prototype.hasTooFewPoints = function () {\n      return this._hasTooFewPoints;\n    }, e.prototype.addPoint = function () {\n      if (arguments[0] instanceof Qt) {\n        var t = arguments[0].getCoordinate();\n        this.insertPoint(this._argIndex, t, w.INTERIOR);\n      } else if (arguments[0] instanceof C) {\n        var e = arguments[0];\n        this.insertPoint(this._argIndex, e, w.INTERIOR);\n      }\n    }, e.prototype.addPolygon = function (t) {\n      this.addPolygonRing(t.getExteriorRing(), w.EXTERIOR, w.INTERIOR);\n\n      for (var e = 0; e < t.getNumInteriorRing(); e++) {\n        var n = t.getInteriorRingN(e);\n        this.addPolygonRing(n, w.INTERIOR, w.EXTERIOR);\n      }\n    }, e.prototype.addEdge = function (t) {\n      this.insertEdge(t);\n      var e = t.getCoordinates();\n      this.insertPoint(this._argIndex, e[0], w.BOUNDARY), this.insertPoint(this._argIndex, e[e.length - 1], w.BOUNDARY);\n    }, e.prototype.addLineString = function (t) {\n      var e = Lt.removeRepeatedPoints(t.getCoordinates());\n      if (e.length < 2) return this._hasTooFewPoints = !0, this._invalidPoint = e[0], null;\n      var n = new ni(e, new Pe(this._argIndex, w.INTERIOR));\n      this._lineEdgeMap.put(t, n), this.insertEdge(n), et.isTrue(e.length >= 2, \"found LineString with single point\"), this.insertBoundaryPoint(this._argIndex, e[0]), this.insertBoundaryPoint(this._argIndex, e[e.length - 1]);\n    }, e.prototype.getInvalidPoint = function () {\n      return this._invalidPoint;\n    }, e.prototype.getBoundaryPoints = function () {\n      for (var t = this.getBoundaryNodes(), e = new Array(t.size()).fill(null), n = 0, i = t.iterator(); i.hasNext();) {\n        var r = i.next();\n        e[n++] = r.getCoordinate().copy();\n      }\n\n      return e;\n    }, e.prototype.getBoundaryNodes = function () {\n      return null === this._boundaryNodes && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes;\n    }, e.prototype.addSelfIntersectionNode = function (t, e, n) {\n      if (this.isBoundaryNode(t, e)) return null;\n      n === w.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(t, e) : this.insertPoint(t, e, n);\n    }, e.prototype.addPolygonRing = function (t, e, n) {\n      if (t.isEmpty()) return null;\n      var i = Lt.removeRepeatedPoints(t.getCoordinates());\n      if (i.length < 4) return this._hasTooFewPoints = !0, this._invalidPoint = i[0], null;\n      var r = e,\n          o = n;\n      at.isCCW(i) && (r = n, o = e);\n      var s = new ni(i, new Pe(this._argIndex, w.BOUNDARY, r, o));\n      this._lineEdgeMap.put(t, s), this.insertEdge(s), this.insertPoint(this._argIndex, i[0], w.BOUNDARY);\n    }, e.prototype.insertPoint = function (t, e, n) {\n      var i = this._nodes.addNode(e),\n          r = i.getLabel();\n\n      null === r ? i._label = new Pe(t, n) : r.setLocation(t, n);\n    }, e.prototype.createEdgeSetIntersector = function () {\n      return new pr();\n    }, e.prototype.addSelfIntersectionNodes = function (t) {\n      for (var e = this._edges.iterator(); e.hasNext();) for (var n = e.next(), i = n.getLabel().getLocation(t), r = n.eiList.iterator(); r.hasNext();) {\n        var o = r.next();\n        this.addSelfIntersectionNode(t, o.coord, i);\n      }\n    }, e.prototype.add = function () {\n      if (1 !== arguments.length) return t.prototype.add.apply(this, arguments);\n      var e = arguments[0];\n      if (e.isEmpty()) return null;\n      if (e instanceof ne && (this._useBoundaryDeterminationRule = !1), e instanceof $t) this.addPolygon(e);else if (e instanceof Kt) this.addLineString(e);else if (e instanceof Qt) this.addPoint(e);else if (e instanceof te) this.addCollection(e);else if (e instanceof Xt) this.addCollection(e);else if (e instanceof ne) this.addCollection(e);else {\n        if (!(e instanceof zt)) throw new Error(e.getClass().getName());\n        this.addCollection(e);\n      }\n    }, e.prototype.addCollection = function (t) {\n      for (var e = 0; e < t.getNumGeometries(); e++) {\n        var n = t.getGeometryN(e);\n        this.add(n);\n      }\n    }, e.prototype.locate = function (t) {\n      return T(this._parentGeom, Zt) && this._parentGeom.getNumGeometries() > 50 ? (null === this._areaPtLocator && (this._areaPtLocator = new vr(this._parentGeom)), this._areaPtLocator.locate(t)) : this._ptLocator.locate(t, this._parentGeom);\n    }, e.prototype.findEdge = function () {\n      if (1 === arguments.length) {\n        var e = arguments[0];\n        return this._lineEdgeMap.get(e);\n      }\n\n      return t.prototype.findEdge.apply(this, arguments);\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e.determineBoundary = function (t, e) {\n      return t.isInBoundary(e) ? w.BOUNDARY : w.INTERIOR;\n    }, e;\n  }(Ye),\n      Cr = function () {\n    if (this._li = new rt(), this._resultPrecisionModel = null, this._arg = null, 1 === arguments.length) {\n      var t = arguments[0];\n      this.setComputationPrecision(t.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new Nr(0, t);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1],\n          i = gt.OGC_SFS_BOUNDARY_RULE;\n      e.getPrecisionModel().compareTo(n.getPrecisionModel()) >= 0 ? this.setComputationPrecision(e.getPrecisionModel()) : this.setComputationPrecision(n.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Nr(0, e, i), this._arg[1] = new Nr(1, n, i);\n    } else if (3 === arguments.length) {\n      var r = arguments[0],\n          o = arguments[1],\n          s = arguments[2];\n      r.getPrecisionModel().compareTo(o.getPrecisionModel()) >= 0 ? this.setComputationPrecision(r.getPrecisionModel()) : this.setComputationPrecision(o.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Nr(0, r, s), this._arg[1] = new Nr(1, o, s);\n    }\n  };\n\n  Cr.prototype.getArgGeometry = function (t) {\n    return this._arg[t].getGeometry();\n  }, Cr.prototype.setComputationPrecision = function (t) {\n    this._resultPrecisionModel = t, this._li.setPrecisionModel(this._resultPrecisionModel);\n  }, Cr.prototype.interfaces_ = function () {\n    return [];\n  }, Cr.prototype.getClass = function () {\n    return Cr;\n  };\n\n  var Sr = function () {};\n\n  Sr.prototype.interfaces_ = function () {\n    return [];\n  }, Sr.prototype.getClass = function () {\n    return Sr;\n  }, Sr.map = function () {\n    if (arguments[0] instanceof ct && T(arguments[1], Sr.MapOp)) {\n      for (var t = arguments[0], e = arguments[1], n = new Nt(), i = 0; i < t.getNumGeometries(); i++) {\n        var r = e.map(t.getGeometryN(i));\n        null !== r && n.add(r);\n      }\n\n      return t.getFactory().buildGeometry(n);\n    }\n\n    if (T(arguments[0], It) && T(arguments[1], Sr.MapOp)) {\n      for (var o = arguments[0], s = arguments[1], a = new Nt(), u = o.iterator(); u.hasNext();) {\n        var l = u.next(),\n            c = s.map(l);\n        null !== c && a.add(c);\n      }\n\n      return a;\n    }\n  }, Sr.MapOp = function () {};\n\n  var Lr = function (t) {\n    function e() {\n      var e = arguments[0],\n          n = arguments[1];\n      t.call(this, e, n), this._ptLocator = new Si(), this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new Hn(), this._resultPolyList = new Nt(), this._resultLineList = new Nt(), this._resultPointList = new Nt(), this._graph = new Ye(new kn()), this._geomFact = e.getFactory();\n    }\n\n    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.insertUniqueEdge = function (t) {\n      var e = this._edgeList.findEqualEdge(t);\n\n      if (null !== e) {\n        var n = e.getLabel(),\n            i = t.getLabel();\n        e.isPointwiseEqual(t) || (i = new Pe(t.getLabel())).flip();\n        var r = e.getDepth();\n        r.isNull() && r.add(n), r.add(i), n.merge(i);\n      } else this._edgeList.add(t);\n    }, e.prototype.getGraph = function () {\n      return this._graph;\n    }, e.prototype.cancelDuplicateResultEdges = function () {\n      for (var t = this._graph.getEdgeEnds().iterator(); t.hasNext();) {\n        var e = t.next(),\n            n = e.getSym();\n        e.isInResult() && n.isInResult() && (e.setInResult(!1), n.setInResult(!1));\n      }\n    }, e.prototype.isCoveredByLA = function (t) {\n      return !!this.isCovered(t, this._resultLineList) || !!this.isCovered(t, this._resultPolyList);\n    }, e.prototype.computeGeometry = function (t, n, i, r) {\n      var o = new Nt();\n      return o.addAll(t), o.addAll(n), o.addAll(i), o.isEmpty() ? e.createEmptyResult(r, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(o);\n    }, e.prototype.mergeSymLabels = function () {\n      for (var t = this._graph.getNodes().iterator(); t.hasNext();) {\n        t.next().getEdges().mergeSymLabels();\n      }\n    }, e.prototype.isCovered = function (t, e) {\n      for (var n = e.iterator(); n.hasNext();) {\n        var i = n.next();\n        if (this._ptLocator.locate(t, i) !== w.EXTERIOR) return !0;\n      }\n\n      return !1;\n    }, e.prototype.replaceCollapsedEdges = function () {\n      for (var t = new Nt(), e = this._edgeList.iterator(); e.hasNext();) {\n        var n = e.next();\n        n.isCollapsed() && (e.remove(), t.add(n.getCollapsedEdge()));\n      }\n\n      this._edgeList.addAll(t);\n    }, e.prototype.updateNodeLabelling = function () {\n      for (var t = this._graph.getNodes().iterator(); t.hasNext();) {\n        var e = t.next(),\n            n = e.getEdges().getLabel();\n        e.getLabel().merge(n);\n      }\n    }, e.prototype.getResultGeometry = function (t) {\n      return this.computeOverlay(t), this._resultGeom;\n    }, e.prototype.insertUniqueEdges = function (t) {\n      for (var e = t.iterator(); e.hasNext();) {\n        var n = e.next();\n        this.insertUniqueEdge(n);\n      }\n    }, e.prototype.computeOverlay = function (t) {\n      this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, !1), this._arg[1].computeSelfNodes(this._li, !1), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, !0);\n      var e = new Nt();\n      this._arg[0].computeSplitEdges(e), this._arg[1].computeSplitEdges(e), this.insertUniqueEdges(e), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Yi.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t), this.cancelDuplicateResultEdges();\n      var n = new ke(this._geomFact);\n      n.add(this._graph), this._resultPolyList = n.getPolygons();\n      var i = new ji(this, this._geomFact, this._ptLocator);\n      this._resultLineList = i.build(t);\n      var r = new Hi(this, this._geomFact, this._ptLocator);\n      this._resultPointList = r.build(t), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, t);\n    }, e.prototype.labelIncompleteNode = function (t, e) {\n      var n = this._ptLocator.locate(t.getCoordinate(), this._arg[e].getGeometry());\n\n      t.getLabel().setLocation(e, n);\n    }, e.prototype.copyPoints = function (t) {\n      for (var e = this._arg[t].getNodeIterator(); e.hasNext();) {\n        var n = e.next();\n\n        this._graph.addNode(n.getCoordinate()).setLabel(t, n.getLabel().getLocation(t));\n      }\n    }, e.prototype.findResultAreaEdges = function (t) {\n      for (var n = this._graph.getEdgeEnds().iterator(); n.hasNext();) {\n        var i = n.next(),\n            r = i.getLabel();\n        r.isArea() && !i.isInteriorAreaEdge() && e.isResultOfOp(r.getLocation(0, Se.RIGHT), r.getLocation(1, Se.RIGHT), t) && i.setInResult(!0);\n      }\n    }, e.prototype.computeLabelsFromDepths = function () {\n      for (var t = this._edgeList.iterator(); t.hasNext();) {\n        var e = t.next(),\n            n = e.getLabel(),\n            i = e.getDepth();\n\n        if (!i.isNull()) {\n          i.normalize();\n\n          for (var r = 0; r < 2; r++) n.isNull(r) || !n.isArea() || i.isNull(r) || (0 === i.getDelta(r) ? n.toLine(r) : (et.isTrue(!i.isNull(r, Se.LEFT), \"depth of LEFT side has not been initialized\"), n.setLocation(r, Se.LEFT, i.getLocation(r, Se.LEFT)), et.isTrue(!i.isNull(r, Se.RIGHT), \"depth of RIGHT side has not been initialized\"), n.setLocation(r, Se.RIGHT, i.getLocation(r, Se.RIGHT))));\n        }\n      }\n    }, e.prototype.computeLabelling = function () {\n      for (var t = this._graph.getNodes().iterator(); t.hasNext();) {\n        t.next().getEdges().computeLabelling(this._arg);\n      }\n\n      this.mergeSymLabels(), this.updateNodeLabelling();\n    }, e.prototype.labelIncompleteNodes = function () {\n      for (var t = this._graph.getNodes().iterator(); t.hasNext();) {\n        var e = t.next(),\n            n = e.getLabel();\n        e.isIsolated() && (n.isNull(0) ? this.labelIncompleteNode(e, 0) : this.labelIncompleteNode(e, 1)), e.getEdges().updateLabelling(n);\n      }\n    }, e.prototype.isCoveredByA = function (t) {\n      return !!this.isCovered(t, this._resultPolyList);\n    }, e.prototype.interfaces_ = function () {\n      return [];\n    }, e.prototype.getClass = function () {\n      return e;\n    }, e;\n  }(Cr);\n\n  Lr.overlayOp = function (t, e, n) {\n    return new Lr(t, e).getResultGeometry(n);\n  }, Lr.intersection = function (t, e) {\n    if (t.isEmpty() || e.isEmpty()) return Lr.createEmptyResult(Lr.INTERSECTION, t, e, t.getFactory());\n\n    if (t.isGeometryCollection()) {\n      var n = e;\n      return ki.map(t, {\n        interfaces_: function () {\n          return [Sr.MapOp];\n        },\n        map: function (t) {\n          return t.intersection(n);\n        }\n      });\n    }\n\n    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), or.overlayOp(t, e, Lr.INTERSECTION);\n  }, Lr.symDifference = function (t, e) {\n    if (t.isEmpty() || e.isEmpty()) {\n      if (t.isEmpty() && e.isEmpty()) return Lr.createEmptyResult(Lr.SYMDIFFERENCE, t, e, t.getFactory());\n      if (t.isEmpty()) return e.copy();\n      if (e.isEmpty()) return t.copy();\n    }\n\n    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), or.overlayOp(t, e, Lr.SYMDIFFERENCE);\n  }, Lr.resultDimension = function (t, e, n) {\n    var i = e.getDimension(),\n        r = n.getDimension(),\n        o = -1;\n\n    switch (t) {\n      case Lr.INTERSECTION:\n        o = Math.min(i, r);\n        break;\n\n      case Lr.UNION:\n        o = Math.max(i, r);\n        break;\n\n      case Lr.DIFFERENCE:\n        o = i;\n        break;\n\n      case Lr.SYMDIFFERENCE:\n        o = Math.max(i, r);\n    }\n\n    return o;\n  }, Lr.createEmptyResult = function (t, e, n, i) {\n    var r = null;\n\n    switch (Lr.resultDimension(t, e, n)) {\n      case -1:\n        r = i.createGeometryCollection(new Array(0).fill(null));\n        break;\n\n      case 0:\n        r = i.createPoint();\n        break;\n\n      case 1:\n        r = i.createLineString();\n        break;\n\n      case 2:\n        r = i.createPolygon();\n    }\n\n    return r;\n  }, Lr.difference = function (t, e) {\n    return t.isEmpty() ? Lr.createEmptyResult(Lr.DIFFERENCE, t, e, t.getFactory()) : e.isEmpty() ? t.copy() : (t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), or.overlayOp(t, e, Lr.DIFFERENCE));\n  }, Lr.isResultOfOp = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1],\n          n = t.getLocation(0),\n          i = t.getLocation(1);\n      return Lr.isResultOfOp(n, i, e);\n    }\n\n    if (3 === arguments.length) {\n      var r = arguments[0],\n          o = arguments[1],\n          s = arguments[2];\n\n      switch (r === w.BOUNDARY && (r = w.INTERIOR), o === w.BOUNDARY && (o = w.INTERIOR), s) {\n        case Lr.INTERSECTION:\n          return r === w.INTERIOR && o === w.INTERIOR;\n\n        case Lr.UNION:\n          return r === w.INTERIOR || o === w.INTERIOR;\n\n        case Lr.DIFFERENCE:\n          return r === w.INTERIOR && o !== w.INTERIOR;\n\n        case Lr.SYMDIFFERENCE:\n          return r === w.INTERIOR && o !== w.INTERIOR || r !== w.INTERIOR && o === w.INTERIOR;\n      }\n\n      return !1;\n    }\n  }, Lr.INTERSECTION = 1, Lr.UNION = 2, Lr.DIFFERENCE = 3, Lr.SYMDIFFERENCE = 4;\n\n  var br = function () {\n    this._g = null, this._boundaryDistanceTolerance = null, this._linework = null, this._ptLocator = new Si(), this._seg = new dn();\n    var t = arguments[0],\n        e = arguments[1];\n    this._g = t, this._boundaryDistanceTolerance = e, this._linework = this.extractLinework(t);\n  };\n\n  br.prototype.isWithinToleranceOfBoundary = function (t) {\n    for (var e = 0; e < this._linework.getNumGeometries(); e++) for (var n = this._linework.getGeometryN(e).getCoordinateSequence(), i = 0; i < n.size() - 1; i++) {\n      n.getCoordinate(i, this._seg.p0), n.getCoordinate(i + 1, this._seg.p1);\n      if (this._seg.distance(t) <= this._boundaryDistanceTolerance) return !0;\n    }\n\n    return !1;\n  }, br.prototype.getLocation = function (t) {\n    return this.isWithinToleranceOfBoundary(t) ? w.BOUNDARY : this._ptLocator.locate(t, this._g);\n  }, br.prototype.extractLinework = function (t) {\n    var e = new wr();\n    t.apply(e);\n\n    var n = e.getLinework(),\n        i = _e.toLineStringArray(n);\n\n    return t.getFactory().createMultiLineString(i);\n  }, br.prototype.interfaces_ = function () {\n    return [];\n  }, br.prototype.getClass = function () {\n    return br;\n  };\n\n  var wr = function () {\n    this._linework = null, this._linework = new Nt();\n  };\n\n  wr.prototype.getLinework = function () {\n    return this._linework;\n  }, wr.prototype.filter = function (t) {\n    if (t instanceof $t) {\n      var e = t;\n\n      this._linework.add(e.getExteriorRing());\n\n      for (var n = 0; n < e.getNumInteriorRing(); n++) this._linework.add(e.getInteriorRingN(n));\n    }\n  }, wr.prototype.interfaces_ = function () {\n    return [Vt];\n  }, wr.prototype.getClass = function () {\n    return wr;\n  };\n\n  var Or = function () {\n    this._g = null, this._doLeft = !0, this._doRight = !0;\n    var t = arguments[0];\n    this._g = t;\n  };\n\n  Or.prototype.extractPoints = function (t, e, n) {\n    for (var i = t.getCoordinates(), r = 0; r < i.length - 1; r++) this.computeOffsetPoints(i[r], i[r + 1], e, n);\n  }, Or.prototype.setSidesToGenerate = function (t, e) {\n    this._doLeft = t, this._doRight = e;\n  }, Or.prototype.getPoints = function (t) {\n    for (var e = new Nt(), n = Ci.getLines(this._g).iterator(); n.hasNext();) {\n      var i = n.next();\n      this.extractPoints(i, t, e);\n    }\n\n    return e;\n  }, Or.prototype.computeOffsetPoints = function (t, e, n, i) {\n    var r = e.x - t.x,\n        o = e.y - t.y,\n        s = Math.sqrt(r * r + o * o),\n        a = n * r / s,\n        u = n * o / s,\n        l = (e.x + t.x) / 2,\n        c = (e.y + t.y) / 2;\n\n    if (this._doLeft) {\n      var p = new C(l - u, c + a);\n      i.add(p);\n    }\n\n    if (this._doRight) {\n      var h = new C(l + u, c - a);\n      i.add(h);\n    }\n  }, Or.prototype.interfaces_ = function () {\n    return [];\n  }, Or.prototype.getClass = function () {\n    return Or;\n  };\n\n  var Tr = function t() {\n    this._geom = null, this._locFinder = null, this._location = new Array(3).fill(null), this._invalidLocation = null, this._boundaryDistanceTolerance = t.TOLERANCE, this._testCoords = new Nt();\n    var e = arguments[0],\n        n = arguments[1],\n        i = arguments[2];\n    this._boundaryDistanceTolerance = t.computeBoundaryDistanceTolerance(e, n), this._geom = [e, n, i], this._locFinder = [new br(this._geom[0], this._boundaryDistanceTolerance), new br(this._geom[1], this._boundaryDistanceTolerance), new br(this._geom[2], this._boundaryDistanceTolerance)];\n  },\n      Rr = {\n    TOLERANCE: {\n      configurable: !0\n    }\n  };\n\n  Tr.prototype.reportResult = function (t, e, n) {\n    Y.out.println(\"Overlay result invalid - A:\" + w.toLocationSymbol(e[0]) + \" B:\" + w.toLocationSymbol(e[1]) + \" expected:\" + (n ? \"i\" : \"e\") + \" actual:\" + w.toLocationSymbol(e[2]));\n  }, Tr.prototype.isValid = function (t) {\n    this.addTestPts(this._geom[0]), this.addTestPts(this._geom[1]);\n    var e = this.checkValid(t);\n    return e;\n  }, Tr.prototype.checkValid = function () {\n    if (1 === arguments.length) {\n      for (var t = arguments[0], e = 0; e < this._testCoords.size(); e++) {\n        var n = this._testCoords.get(e);\n\n        if (!this.checkValid(t, n)) return this._invalidLocation = n, !1;\n      }\n\n      return !0;\n    }\n\n    if (2 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1];\n      return this._location[0] = this._locFinder[0].getLocation(r), this._location[1] = this._locFinder[1].getLocation(r), this._location[2] = this._locFinder[2].getLocation(r), !!Tr.hasLocation(this._location, w.BOUNDARY) || this.isValidResult(i, this._location);\n    }\n  }, Tr.prototype.addTestPts = function (t) {\n    var e = new Or(t);\n\n    this._testCoords.addAll(e.getPoints(5 * this._boundaryDistanceTolerance));\n  }, Tr.prototype.isValidResult = function (t, e) {\n    var n = Lr.isResultOfOp(e[0], e[1], t),\n        i = !(n ^ e[2] === w.INTERIOR);\n    return i || this.reportResult(t, e, n), i;\n  }, Tr.prototype.getInvalidLocation = function () {\n    return this._invalidLocation;\n  }, Tr.prototype.interfaces_ = function () {\n    return [];\n  }, Tr.prototype.getClass = function () {\n    return Tr;\n  }, Tr.hasLocation = function (t, e) {\n    for (var n = 0; n < 3; n++) if (t[n] === e) return !0;\n\n    return !1;\n  }, Tr.computeBoundaryDistanceTolerance = function (t, e) {\n    return Math.min(Ji.computeSizeBasedSnapTolerance(t), Ji.computeSizeBasedSnapTolerance(e));\n  }, Tr.isValid = function (t, e, n, i) {\n    return new Tr(t, e, i).isValid(n);\n  }, Rr.TOLERANCE.get = function () {\n    return 1e-6;\n  }, Object.defineProperties(Tr, Rr);\n\n  var Pr = function t(e) {\n    this._geomFactory = null, this._skipEmpty = !1, this._inputGeoms = null, this._geomFactory = t.extractFactory(e), this._inputGeoms = e;\n  };\n\n  Pr.prototype.extractElements = function (t, e) {\n    if (null === t) return null;\n\n    for (var n = 0; n < t.getNumGeometries(); n++) {\n      var i = t.getGeometryN(n);\n      this._skipEmpty && i.isEmpty() || e.add(i);\n    }\n  }, Pr.prototype.combine = function () {\n    for (var t = new Nt(), e = this._inputGeoms.iterator(); e.hasNext();) {\n      var n = e.next();\n      this.extractElements(n, t);\n    }\n\n    return 0 === t.size() ? null !== this._geomFactory ? this._geomFactory.createGeometryCollection(null) : null : this._geomFactory.buildGeometry(t);\n  }, Pr.prototype.interfaces_ = function () {\n    return [];\n  }, Pr.prototype.getClass = function () {\n    return Pr;\n  }, Pr.combine = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return new Pr(t).combine();\n    }\n\n    if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      return new Pr(Pr.createList(e, n)).combine();\n    }\n\n    if (3 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1],\n          o = arguments[2];\n      return new Pr(Pr.createList(i, r, o)).combine();\n    }\n  }, Pr.extractFactory = function (t) {\n    return t.isEmpty() ? null : t.iterator().next().getFactory();\n  }, Pr.createList = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1],\n          n = new Nt();\n      return n.add(t), n.add(e), n;\n    }\n\n    if (3 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1],\n          o = arguments[2],\n          s = new Nt();\n      return s.add(i), s.add(r), s.add(o), s;\n    }\n  };\n\n  var Dr = function () {\n    this._inputPolys = null, this._geomFactory = null;\n    var t = arguments[0];\n    this._inputPolys = t, null === this._inputPolys && (this._inputPolys = new Nt());\n  },\n      Mr = {\n    STRTREE_NODE_CAPACITY: {\n      configurable: !0\n    }\n  };\n\n  Dr.prototype.reduceToGeometries = function (t) {\n    for (var e = new Nt(), n = t.iterator(); n.hasNext();) {\n      var i = n.next(),\n          r = null;\n      T(i, xt) ? r = this.unionTree(i) : i instanceof ct && (r = i), e.add(r);\n    }\n\n    return e;\n  }, Dr.prototype.extractByEnvelope = function (t, e, n) {\n    for (var i = new Nt(), r = 0; r < e.getNumGeometries(); r++) {\n      var o = e.getGeometryN(r);\n      o.getEnvelopeInternal().intersects(t) ? i.add(o) : n.add(o);\n    }\n\n    return this._geomFactory.buildGeometry(i);\n  }, Dr.prototype.unionOptimized = function (t, e) {\n    var n = t.getEnvelopeInternal(),\n        i = e.getEnvelopeInternal();\n\n    if (!n.intersects(i)) {\n      return Pr.combine(t, e);\n    }\n\n    if (t.getNumGeometries() <= 1 && e.getNumGeometries() <= 1) return this.unionActual(t, e);\n    var r = n.intersection(i);\n    return this.unionUsingEnvelopeIntersection(t, e, r);\n  }, Dr.prototype.union = function () {\n    if (null === this._inputPolys) throw new Error(\"union() method cannot be called twice\");\n    if (this._inputPolys.isEmpty()) return null;\n    this._geomFactory = this._inputPolys.iterator().next().getFactory();\n\n    for (var t = new sn(Dr.STRTREE_NODE_CAPACITY), e = this._inputPolys.iterator(); e.hasNext();) {\n      var n = e.next();\n      t.insert(n.getEnvelopeInternal(), n);\n    }\n\n    this._inputPolys = null;\n    var i = t.itemsTree();\n    return this.unionTree(i);\n  }, Dr.prototype.binaryUnion = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return this.binaryUnion(t, 0, t.size());\n    }\n\n    if (3 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1],\n          i = arguments[2];\n\n      if (i - n <= 1) {\n        var r = Dr.getGeometry(e, n);\n        return this.unionSafe(r, null);\n      }\n\n      if (i - n == 2) return this.unionSafe(Dr.getGeometry(e, n), Dr.getGeometry(e, n + 1));\n      var o = Math.trunc((i + n) / 2),\n          s = this.binaryUnion(e, n, o),\n          a = this.binaryUnion(e, o, i);\n      return this.unionSafe(s, a);\n    }\n  }, Dr.prototype.repeatedUnion = function (t) {\n    for (var e = null, n = t.iterator(); n.hasNext();) {\n      var i = n.next();\n      e = null === e ? i.copy() : e.union(i);\n    }\n\n    return e;\n  }, Dr.prototype.unionSafe = function (t, e) {\n    return null === t && null === e ? null : null === t ? e.copy() : null === e ? t.copy() : this.unionOptimized(t, e);\n  }, Dr.prototype.unionActual = function (t, e) {\n    return Dr.restrictToPolygons(t.union(e));\n  }, Dr.prototype.unionTree = function (t) {\n    var e = this.reduceToGeometries(t);\n    return this.binaryUnion(e);\n  }, Dr.prototype.unionUsingEnvelopeIntersection = function (t, e, n) {\n    var i = new Nt(),\n        r = this.extractByEnvelope(n, t, i),\n        o = this.extractByEnvelope(n, e, i),\n        s = this.unionActual(r, o);\n    i.add(s);\n    return Pr.combine(i);\n  }, Dr.prototype.bufferUnion = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return t.get(0).getFactory().buildGeometry(t).buffer(0);\n    }\n\n    if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      return e.getFactory().createGeometryCollection([e, n]).buffer(0);\n    }\n  }, Dr.prototype.interfaces_ = function () {\n    return [];\n  }, Dr.prototype.getClass = function () {\n    return Dr;\n  }, Dr.restrictToPolygons = function (t) {\n    if (T(t, Zt)) return t;\n    var e = Ni.getPolygons(t);\n    return 1 === e.size() ? e.get(0) : t.getFactory().createMultiPolygon(_e.toPolygonArray(e));\n  }, Dr.getGeometry = function (t, e) {\n    return e >= t.size() ? null : t.get(e);\n  }, Dr.union = function (t) {\n    return new Dr(t).union();\n  }, Mr.STRTREE_NODE_CAPACITY.get = function () {\n    return 4;\n  }, Object.defineProperties(Dr, Mr);\n\n  var Ar = function () {};\n\n  Ar.prototype.interfaces_ = function () {\n    return [];\n  }, Ar.prototype.getClass = function () {\n    return Ar;\n  }, Ar.union = function (t, e) {\n    if (t.isEmpty() || e.isEmpty()) {\n      if (t.isEmpty() && e.isEmpty()) return Lr.createEmptyResult(Lr.UNION, t, e, t.getFactory());\n      if (t.isEmpty()) return e.copy();\n      if (e.isEmpty()) return t.copy();\n    }\n\n    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), or.overlayOp(t, e, Lr.UNION);\n  }, t.GeoJSONReader = Ne, t.GeoJSONWriter = Ce, t.OverlayOp = Lr, t.UnionOp = Ar, t.BufferOp = di, Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n});","map":null,"metadata":{},"sourceType":"script"}