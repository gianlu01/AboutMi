{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ImmutableFeatureCollection = void 0;\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar ImmutableFeatureCollection =\n/*#__PURE__*/\nfunction () {\n  function ImmutableFeatureCollection(featureCollection) {\n    _classCallCheck(this, ImmutableFeatureCollection);\n\n    _defineProperty(this, \"featureCollection\", void 0);\n\n    this.featureCollection = featureCollection;\n  }\n\n  _createClass(ImmutableFeatureCollection, [{\n    key: \"getObject\",\n    value: function getObject() {\n      return this.featureCollection;\n    }\n    /**\n     * Replaces the position deeply nested withing the given feature's geometry.\n     * Works with Point, MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n     *\n     * @param featureIndex The index of the feature to update\n     * @param positionIndexes An array containing the indexes of the position to replace\n     * @param updatedPosition The updated position to place in the result (i.e. [lng, lat])\n     *\n     * @returns A new `ImmutableFeatureCollection` with the given position replaced. Does not modify this `ImmutableFeatureCollection`.\n     */\n\n  }, {\n    key: \"replacePosition\",\n    value: function replacePosition(featureIndex, positionIndexes, updatedPosition) {\n      var geometry = this.featureCollection.features[featureIndex].geometry;\n      var isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n\n      var updatedGeometry = _objectSpread({}, geometry, {\n        coordinates: immutablyReplacePosition(geometry.coordinates, positionIndexes, updatedPosition, isPolygonal)\n      });\n\n      return this.replaceGeometry(featureIndex, updatedGeometry);\n    }\n    /**\n     * Removes a position deeply nested in a GeoJSON geometry coordinates array.\n     * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n     *\n     * @param featureIndex The index of the feature to update\n     * @param positionIndexes An array containing the indexes of the postion to remove\n     *\n     * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n     */\n\n  }, {\n    key: \"removePosition\",\n    value: function removePosition(featureIndex, positionIndexes) {\n      var geometry = this.featureCollection.features[featureIndex].geometry;\n\n      if (geometry.type === 'Point') {\n        throw Error(\"Can't remove a position from a Point or there'd be nothing left\");\n      }\n\n      if (geometry.type === 'MultiPoint' && // only 1 point left\n      geometry.coordinates.length < 2) {\n        throw Error(\"Can't remove the last point of a MultiPoint or there'd be nothing left\");\n      }\n\n      if (geometry.type === 'LineString' && // only 2 positions\n      geometry.coordinates.length < 3) {\n        throw Error(\"Can't remove position. LineString must have at least two positions\");\n      }\n\n      if (geometry.type === 'Polygon' && // outer ring is a triangle\n      geometry.coordinates[0].length < 5 && // trying to remove from outer ring\n      positionIndexes[0] === 0) {\n        throw Error(\"Can't remove position. Polygon's outer ring must have at least four positions\");\n      }\n\n      if (geometry.type === 'MultiLineString' && // only 1 LineString left\n      geometry.coordinates.length === 1 && // only 2 positions\n      geometry.coordinates[0].length < 3) {\n        throw Error(\"Can't remove position. MultiLineString must have at least two positions\");\n      }\n\n      if (geometry.type === 'MultiPolygon' && // only 1 polygon left\n      geometry.coordinates.length === 1 && // outer ring is a triangle\n      geometry.coordinates[0][0].length < 5 && // trying to remove from first polygon\n      positionIndexes[0] === 0 && // trying to remove from outer ring\n      positionIndexes[1] === 0) {\n        throw Error(\"Can't remove position. MultiPolygon's outer ring must have at least four positions\");\n      }\n\n      var isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n\n      var updatedGeometry = _objectSpread({}, geometry, {\n        coordinates: immutablyRemovePosition(geometry.coordinates, positionIndexes, isPolygonal)\n      }); // Handle cases where incomplete geometries need pruned (e.g. holes that were triangles)\n\n\n      pruneGeometryIfNecessary(updatedGeometry);\n      return this.replaceGeometry(featureIndex, updatedGeometry);\n    }\n    /**\n     * Adds a position deeply nested in a GeoJSON geometry coordinates array.\n     * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n     *\n     * @param featureIndex The index of the feature to update\n     * @param positionIndexes An array containing the indexes of the position that will proceed the new position\n     * @param positionToAdd The new position to place in the result (i.e. [lng, lat])\n     *\n     * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n     */\n\n  }, {\n    key: \"addPosition\",\n    value: function addPosition(featureIndex, positionIndexes, positionToAdd) {\n      var geometry = this.featureCollection.features[featureIndex].geometry;\n\n      if (geometry.type === 'Point') {\n        throw new Error('Unable to add a position to a Point feature');\n      }\n\n      var isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n\n      var updatedGeometry = _objectSpread({}, geometry, {\n        coordinates: immutablyAddPosition(geometry.coordinates, positionIndexes, positionToAdd, isPolygonal)\n      });\n\n      return this.replaceGeometry(featureIndex, updatedGeometry);\n    }\n  }, {\n    key: \"replaceGeometry\",\n    value: function replaceGeometry(featureIndex, geometry) {\n      var updatedFeature = _objectSpread({}, this.featureCollection.features[featureIndex], {\n        geometry: geometry\n      });\n\n      var updatedFeatureCollection = _objectSpread({}, this.featureCollection, {\n        features: _toConsumableArray(this.featureCollection.features.slice(0, featureIndex)).concat([updatedFeature], _toConsumableArray(this.featureCollection.features.slice(featureIndex + 1)))\n      });\n\n      return new ImmutableFeatureCollection(updatedFeatureCollection);\n    }\n  }, {\n    key: \"addFeature\",\n    value: function addFeature(feature) {\n      return this.addFeatures([feature]);\n    }\n  }, {\n    key: \"addFeatures\",\n    value: function addFeatures(features) {\n      var updatedFeatureCollection = _objectSpread({}, this.featureCollection, {\n        features: _toConsumableArray(this.featureCollection.features).concat(_toConsumableArray(features))\n      });\n\n      return new ImmutableFeatureCollection(updatedFeatureCollection);\n    }\n  }, {\n    key: \"deleteFeature\",\n    value: function deleteFeature(featureIndex) {\n      return this.deleteFeatures([featureIndex]);\n    }\n  }, {\n    key: \"deleteFeatures\",\n    value: function deleteFeatures(featureIndexes) {\n      var features = _toConsumableArray(this.featureCollection.features);\n\n      featureIndexes.sort();\n\n      for (var i = featureIndexes.length - 1; i >= 0; i--) {\n        var featureIndex = featureIndexes[i];\n\n        if (featureIndex >= 0 && featureIndex < features.length) {\n          features.splice(featureIndex, 1);\n        }\n      }\n\n      var updatedFeatureCollection = _objectSpread({}, this.featureCollection, {\n        features: features\n      });\n\n      return new ImmutableFeatureCollection(updatedFeatureCollection);\n    }\n  }]);\n\n  return ImmutableFeatureCollection;\n}();\n\nexports.ImmutableFeatureCollection = ImmutableFeatureCollection;\n\nfunction getUpdatedPosition(updatedPosition, previousPosition) {\n  // This function checks if the updatedPosition is missing elevation\n  // and copies it from previousPosition\n  if (updatedPosition.length === 2 && previousPosition.length === 3) {\n    var elevation = previousPosition[2];\n    return [updatedPosition[0], updatedPosition[1], elevation];\n  }\n\n  return updatedPosition;\n}\n\nfunction immutablyReplacePosition(coordinates, positionIndexes, updatedPosition, isPolygonal) {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n\n  if (positionIndexes.length === 0) {\n    return getUpdatedPosition(updatedPosition, coordinates);\n  }\n\n  if (positionIndexes.length === 1) {\n    var updated = _toConsumableArray(coordinates.slice(0, positionIndexes[0])).concat([getUpdatedPosition(updatedPosition, coordinates[positionIndexes[0]])], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));\n\n    if (isPolygonal && (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, update it on both ends of the array\n      updated[0] = getUpdatedPosition(updatedPosition, coordinates[0]);\n      updated[coordinates.length - 1] = getUpdatedPosition(updatedPosition, coordinates[0]);\n    }\n\n    return updated;\n  } // recursively update inner array\n\n\n  return _toConsumableArray(coordinates.slice(0, positionIndexes[0])).concat([immutablyReplacePosition(coordinates[positionIndexes[0]], positionIndexes.slice(1, positionIndexes.length), updatedPosition, isPolygonal)], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));\n}\n\nfunction immutablyRemovePosition(coordinates, positionIndexes, isPolygonal) {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n\n  if (positionIndexes.length === 1) {\n    var updated = _toConsumableArray(coordinates.slice(0, positionIndexes[0])).concat(_toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));\n\n    if (isPolygonal && (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, if the first/last coordinate is to be removed, coordinates[1] will be the new first/last coordinate\n      if (positionIndexes[0] === 0) {\n        // change the last to be the same as the first\n        updated[updated.length - 1] = updated[0];\n      } else if (positionIndexes[0] === coordinates.length - 1) {\n        // change the first to be the same as the last\n        updated[0] = updated[updated.length - 1];\n      }\n    }\n\n    return updated;\n  } // recursively update inner array\n\n\n  return _toConsumableArray(coordinates.slice(0, positionIndexes[0])).concat([immutablyRemovePosition(coordinates[positionIndexes[0]], positionIndexes.slice(1, positionIndexes.length), isPolygonal)], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));\n}\n\nfunction immutablyAddPosition(coordinates, positionIndexes, positionToAdd, isPolygonal) {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n\n  if (positionIndexes.length === 1) {\n    var updated = _toConsumableArray(coordinates.slice(0, positionIndexes[0])).concat([positionToAdd], _toConsumableArray(coordinates.slice(positionIndexes[0])));\n\n    return updated;\n  } // recursively update inner array\n\n\n  return _toConsumableArray(coordinates.slice(0, positionIndexes[0])).concat([immutablyAddPosition(coordinates[positionIndexes[0]], positionIndexes.slice(1, positionIndexes.length), positionToAdd, isPolygonal)], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));\n}\n\nfunction pruneGeometryIfNecessary(geometry) {\n  switch (geometry.type) {\n    case 'Polygon':\n      prunePolygonIfNecessary(geometry);\n      break;\n\n    case 'MultiLineString':\n      pruneMultiLineStringIfNecessary(geometry);\n      break;\n\n    case 'MultiPolygon':\n      pruneMultiPolygonIfNecessary(geometry);\n      break;\n\n    default:\n      // Not downgradable\n      break;\n  }\n}\n\nfunction prunePolygonIfNecessary(geometry) {\n  var polygon = geometry.coordinates; // If any hole is no longer a polygon, remove the hole entirely\n\n  for (var holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n    if (removeHoleIfNecessary(polygon, holeIndex)) {\n      // It was removed, so keep the index the same\n      holeIndex--;\n    }\n  }\n}\n\nfunction pruneMultiLineStringIfNecessary(geometry) {\n  for (var lineStringIndex = 0; lineStringIndex < geometry.coordinates.length; lineStringIndex++) {\n    var lineString = geometry.coordinates[lineStringIndex];\n\n    if (lineString.length === 1) {\n      // Only a single position left on this LineString, so remove it (can't have Point in MultiLineString)\n      geometry.coordinates.splice(lineStringIndex, 1); // Keep the index the same\n\n      lineStringIndex--;\n    }\n  }\n}\n\nfunction pruneMultiPolygonIfNecessary(geometry) {\n  for (var polygonIndex = 0; polygonIndex < geometry.coordinates.length; polygonIndex++) {\n    var polygon = geometry.coordinates[polygonIndex];\n    var outerRing = polygon[0]; // If the outer ring is no longer a polygon, remove the whole polygon\n\n    if (outerRing.length <= 3) {\n      geometry.coordinates.splice(polygonIndex, 1); // It was removed, so keep the index the same\n\n      polygonIndex--;\n    }\n\n    for (var holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n      if (removeHoleIfNecessary(polygon, holeIndex)) {\n        // It was removed, so keep the index the same\n        holeIndex--;\n      }\n    }\n  }\n}\n\nfunction removeHoleIfNecessary(polygon, holeIndex) {\n  var hole = polygon[holeIndex];\n\n  if (hole.length <= 3) {\n    polygon.splice(holeIndex, 1);\n    return true;\n  }\n\n  return false;\n}","map":null,"metadata":{},"sourceType":"script"}