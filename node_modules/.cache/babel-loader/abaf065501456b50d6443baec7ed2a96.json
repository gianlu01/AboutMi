{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Draw90DegreePolygonMode = void 0;\n\nvar _destination = _interopRequireDefault(require(\"@turf/destination\"));\n\nvar _bearing = _interopRequireDefault(require(\"@turf/bearing\"));\n\nvar _lineIntersect = _interopRequireDefault(require(\"@turf/line-intersect\"));\n\nvar _distance = _interopRequireDefault(require(\"@turf/distance\"));\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _utils = require(\"../utils\");\n\nvar _geojsonEditMode = require(\"./geojson-edit-mode.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar Draw90DegreePolygonMode =\n/*#__PURE__*/\nfunction (_BaseGeoJsonEditMode) {\n  _inherits(Draw90DegreePolygonMode, _BaseGeoJsonEditMode);\n\n  function Draw90DegreePolygonMode() {\n    _classCallCheck(this, Draw90DegreePolygonMode);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Draw90DegreePolygonMode).apply(this, arguments));\n  }\n\n  _createClass(Draw90DegreePolygonMode, [{\n    key: \"getGuides\",\n    value: function getGuides(props) {\n      var guides = {\n        type: 'FeatureCollection',\n        features: []\n      };\n      var clickSequence = this.getClickSequence();\n\n      if (clickSequence.length === 0 || !props.lastPointerMoveEvent) {\n        return guides;\n      }\n\n      var mapCoords = props.lastPointerMoveEvent.mapCoords;\n      var p3;\n\n      if (clickSequence.length === 1) {\n        p3 = mapCoords;\n      } else {\n        var p1 = clickSequence[clickSequence.length - 2];\n        var p2 = clickSequence[clickSequence.length - 1];\n\n        var _generatePointsParall = (0, _utils.generatePointsParallelToLinePoints)(p1, p2, mapCoords);\n\n        var _generatePointsParall2 = _slicedToArray(_generatePointsParall, 1);\n\n        p3 = _generatePointsParall2[0];\n      }\n\n      var tentativeFeature;\n\n      if (clickSequence.length < 3) {\n        // Draw a LineString connecting all the clicked points with the hovered point\n        tentativeFeature = {\n          type: 'Feature',\n          properties: {\n            guideType: 'tentative'\n          },\n          geometry: {\n            type: 'LineString',\n            coordinates: _toConsumableArray(clickSequence).concat([p3])\n          }\n        };\n      } else {\n        // Draw a Polygon connecting all the clicked points with the hovered point\n        tentativeFeature = {\n          type: 'Feature',\n          properties: {\n            guideType: 'tentative'\n          },\n          geometry: {\n            type: 'Polygon',\n            coordinates: [_toConsumableArray(clickSequence).concat([p3, clickSequence[0]])]\n          }\n        };\n      }\n\n      guides.features.push(tentativeFeature);\n      guides.features = guides.features.concat((0, _utils.getEditHandlesForGeometry)(tentativeFeature.geometry, -1)); // Slice off the handles that are are next to the pointer\n\n      guides.features = guides.features.slice(0, -1);\n      return guides;\n    }\n  }, {\n    key: \"handlePointerMove\",\n    value: function handlePointerMove(_ref, props) {\n      var mapCoords = _ref.mapCoords;\n      props.onUpdateCursor('cell');\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(event, props) {\n      var picks = event.picks;\n      var tentativeFeature = this.getTentativeGuide(props);\n      this.addClickSequence(event);\n      var clickSequence = this.getClickSequence();\n\n      if (!tentativeFeature) {\n        // nothing else to do\n        return;\n      }\n\n      if (clickSequence.length === 3 && tentativeFeature.geometry.type === 'LineString') {\n        var lineString = tentativeFeature.geometry; // Tweak the clicked position to be the snapped 90 degree point along the polygon\n\n        clickSequence[clickSequence.length - 1] = lineString.coordinates[lineString.coordinates.length - 1];\n      } else if (clickSequence.length > 3 && tentativeFeature.geometry.type === 'Polygon') {\n        var polygon = tentativeFeature.geometry; // Tweak the clicked position to be the snapped 90 degree point along the polygon\n\n        clickSequence[clickSequence.length - 1] = polygon.coordinates[0][polygon.coordinates[0].length - 2];\n        var clickedEditHandle = (0, _utils.getPickedEditHandle)(picks);\n\n        if (clickedEditHandle && (clickedEditHandle.properties.positionIndexes[1] === 0 || clickedEditHandle.properties.positionIndexes[1] === polygon.coordinates[0].length - 3)) {\n          // They clicked the first or last point (or double-clicked), so complete the polygon\n          var polygonToAdd = {\n            type: 'Polygon',\n            coordinates: this.finalizedCoordinates(_toConsumableArray(polygon.coordinates[0]))\n          };\n          this.resetClickSequence();\n          var editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd, props);\n\n          if (editAction) {\n            props.onEdit(editAction);\n          }\n        }\n      } // Trigger pointer move right away in order for it to update edit handles (to support double-click)\n\n\n      var fakePointerMoveEvent = {\n        screenCoords: [-1, -1],\n        mapCoords: event.mapCoords,\n        picks: [],\n        pointerDownPicks: null,\n        pointerDownScreenCoords: null,\n        pointerDownMapCoords: null,\n        cancelPan: function cancelPan() {},\n        sourceEvent: null\n      };\n      this.handlePointerMove(fakePointerMoveEvent, props);\n    }\n  }, {\n    key: \"finalizedCoordinates\",\n    value: function finalizedCoordinates(coords) {\n      // Remove the hovered position\n      var coordinates = [_toConsumableArray(coords.slice(0, -2)).concat([coords[0]])];\n      var pt = this.getIntermediatePoint(_toConsumableArray(coords));\n\n      if (!pt) {\n        // if intermediate point with 90 degree not available\n        // try remove the last clicked point and get the intermediate point.\n        var tc = _toConsumableArray(coords);\n\n        tc.splice(-3, 1);\n        pt = this.getIntermediatePoint(_toConsumableArray(tc));\n\n        if (pt) {\n          coordinates = [_toConsumableArray(coords.slice(0, -3)).concat([pt, coords[0]])];\n        }\n      } else {\n        coordinates = [_toConsumableArray(coords.slice(0, -2)).concat([pt, coords[0]])];\n      }\n\n      return coordinates;\n    }\n  }, {\n    key: \"getIntermediatePoint\",\n    value: function getIntermediatePoint(coordinates) {\n      var pt;\n\n      if (coordinates.length > 4) {\n        var _ref2 = _toConsumableArray(coordinates),\n            p1 = _ref2[0],\n            p2 = _ref2[1];\n\n        var angle1 = (0, _bearing.default)(p1, p2);\n        var p3 = coordinates[coordinates.length - 3];\n        var p4 = coordinates[coordinates.length - 4];\n        var angle2 = (0, _bearing.default)(p3, p4);\n        var angles = {\n          first: [],\n          second: []\n        }; // calculate 3 right angle points for first and last points in lineString\n\n        [1, 2, 3].forEach(function (factor) {\n          var newAngle1 = angle1 + factor * 90; // convert angles to 0 to -180 for anti-clock and 0 to 180 for clock wise\n\n          angles.first.push(newAngle1 > 180 ? newAngle1 - 360 : newAngle1);\n          var newAngle2 = angle2 + factor * 90;\n          angles.second.push(newAngle2 > 180 ? newAngle2 - 360 : newAngle2);\n        });\n        var distance = (0, _distance.default)((0, _helpers.point)(p1), (0, _helpers.point)(p3)); // Draw imaginary right angle lines for both first and last points in lineString\n        // If there is intersection point for any 2 lines, will be the 90 degree point.\n\n        [0, 1, 2].forEach(function (indexFirst) {\n          var line1 = (0, _helpers.lineString)([p1, (0, _destination.default)(p1, distance, angles.first[indexFirst]).geometry.coordinates]);\n          [0, 1, 2].forEach(function (indexSecond) {\n            var line2 = (0, _helpers.lineString)([p3, (0, _destination.default)(p3, distance, angles.second[indexSecond]).geometry.coordinates]);\n            var fc = (0, _lineIntersect.default)(line1, line2);\n\n            if (fc && fc.features.length) {\n              // found the intersect point\n              pt = fc.features[0].geometry.coordinates;\n            }\n          });\n        });\n      }\n\n      return pt;\n    }\n  }]);\n\n  return Draw90DegreePolygonMode;\n}(_geojsonEditMode.BaseGeoJsonEditMode);\n\nexports.Draw90DegreePolygonMode = Draw90DegreePolygonMode;","map":null,"metadata":{},"sourceType":"script"}