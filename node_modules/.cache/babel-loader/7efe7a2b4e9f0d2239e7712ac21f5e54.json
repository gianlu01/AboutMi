{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getIntermediatePosition = getIntermediatePosition;\nexports.BaseGeoJsonEditMode = void 0;\n\nvar _union = _interopRequireDefault(require(\"@turf/union\"));\n\nvar _difference = _interopRequireDefault(require(\"@turf/difference\"));\n\nvar _intersect = _interopRequireDefault(require(\"@turf/intersect\"));\n\nvar _utils = require(\"../utils.js\");\n\nvar _editMode = require(\"./edit-mode.js\");\n\nvar _immutableFeatureCollection = require(\"./immutable-feature-collection.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar DEFAULT_GUIDES = {\n  type: 'FeatureCollection',\n  features: []\n};\nvar DEFAULT_TOOLTIPS = []; // Main interface for `EditMode`s that edit GeoJSON\n\nvar BaseGeoJsonEditMode =\n/*#__PURE__*/\nfunction () {\n  function BaseGeoJsonEditMode() {\n    _classCallCheck(this, BaseGeoJsonEditMode);\n\n    _defineProperty(this, \"_clickSequence\", []);\n  }\n\n  _createClass(BaseGeoJsonEditMode, [{\n    key: \"getGuides\",\n    value: function getGuides(props) {\n      return DEFAULT_GUIDES;\n    }\n  }, {\n    key: \"getTooltips\",\n    value: function getTooltips(props) {\n      return DEFAULT_TOOLTIPS;\n    }\n  }, {\n    key: \"getSelectedFeature\",\n    value: function getSelectedFeature(props) {\n      if (props.selectedIndexes.length === 1) {\n        return props.data.features[props.selectedIndexes[0]];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getSelectedGeometry\",\n    value: function getSelectedGeometry(props) {\n      var feature = this.getSelectedFeature(props);\n\n      if (feature) {\n        return feature.geometry;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getSelectedFeaturesAsFeatureCollection\",\n    value: function getSelectedFeaturesAsFeatureCollection(props) {\n      var features = props.data.features;\n      var selectedFeatures = props.selectedIndexes.map(function (selectedIndex) {\n        return features[selectedIndex];\n      });\n      return {\n        type: 'FeatureCollection',\n        features: selectedFeatures\n      };\n    }\n  }, {\n    key: \"getClickSequence\",\n    value: function getClickSequence() {\n      return this._clickSequence;\n    }\n  }, {\n    key: \"addClickSequence\",\n    value: function addClickSequence(_ref) {\n      var mapCoords = _ref.mapCoords;\n\n      this._clickSequence.push(mapCoords);\n    }\n  }, {\n    key: \"resetClickSequence\",\n    value: function resetClickSequence() {\n      this._clickSequence = [];\n    }\n  }, {\n    key: \"getTentativeGuide\",\n    value: function getTentativeGuide(props) {\n      var guides = this.getGuides(props); // $FlowFixMe\n\n      return guides.features.find(function (f) {\n        return f.properties && f.properties.guideType === 'tentative';\n      });\n    }\n  }, {\n    key: \"isSelectionPicked\",\n    value: function isSelectionPicked(picks, props) {\n      if (!picks.length) return false;\n      var pickedFeatures = (0, _utils.getNonGuidePicks)(picks).map(function (_ref2) {\n        var index = _ref2.index;\n        return index;\n      });\n      var pickedHandles = (0, _utils.getPickedEditHandles)(picks).map(function (_ref3) {\n        var properties = _ref3.properties;\n        return properties.featureIndex;\n      });\n      var pickedIndexes = new Set(_toConsumableArray(pickedFeatures).concat(_toConsumableArray(pickedHandles)));\n      return props.selectedIndexes.some(function (index) {\n        return pickedIndexes.has(index);\n      });\n    }\n  }, {\n    key: \"getAddFeatureAction\",\n    value: function getAddFeatureAction(geometry, features) {\n      // Unsure why flow can't deal with Geometry type, but there I fixed it\n      var geometryAsAny = geometry;\n      var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(features).addFeature({\n        type: 'Feature',\n        properties: {},\n        geometry: geometryAsAny\n      }).getObject();\n      return {\n        updatedData: updatedData,\n        editType: 'addFeature',\n        editContext: {\n          featureIndexes: [updatedData.features.length - 1]\n        }\n      };\n    }\n  }, {\n    key: \"getAddManyFeaturesAction\",\n    value: function getAddManyFeaturesAction(_ref4, features) {\n      var featuresToAdd = _ref4.features;\n      var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(features);\n      var initialIndex = updatedData.getObject().features.length;\n      var updatedIndexes = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = featuresToAdd[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var feature = _step.value;\n          var properties = feature.properties,\n              geometry = feature.geometry;\n          var geometryAsAny = geometry;\n          updatedData = updatedData.addFeature({\n            type: 'Feature',\n            properties: properties,\n            geometry: geometryAsAny\n          });\n          updatedIndexes.push(initialIndex + updatedIndexes.length);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return {\n        updatedData: updatedData.getObject(),\n        editType: 'addFeature',\n        editContext: {\n          featureIndexes: updatedIndexes\n        }\n      };\n    }\n  }, {\n    key: \"getAddFeatureOrBooleanPolygonAction\",\n    value: function getAddFeatureOrBooleanPolygonAction(geometry, props) {\n      var selectedFeature = this.getSelectedFeature(props);\n      var modeConfig = props.modeConfig;\n\n      if (modeConfig && modeConfig.booleanOperation) {\n        if (!selectedFeature || selectedFeature.geometry.type !== 'Polygon' && selectedFeature.geometry.type !== 'MultiPolygon') {\n          // eslint-disable-next-line no-console,no-undef\n          console.warn('booleanOperation only supported for single Polygon or MultiPolygon selection');\n          return null;\n        }\n\n        var feature = {\n          type: 'Feature',\n          geometry: geometry\n        };\n        var updatedGeometry;\n\n        if (modeConfig.booleanOperation === 'union') {\n          updatedGeometry = (0, _union.default)(selectedFeature, feature);\n        } else if (modeConfig.booleanOperation === 'difference') {\n          updatedGeometry = (0, _difference.default)(selectedFeature, feature);\n        } else if (modeConfig.booleanOperation === 'intersection') {\n          updatedGeometry = (0, _intersect.default)(selectedFeature, feature);\n        } else {\n          // eslint-disable-next-line no-console,no-undef\n          console.warn(\"Invalid booleanOperation \".concat(modeConfig.booleanOperation));\n          return null;\n        }\n\n        if (!updatedGeometry) {\n          // eslint-disable-next-line no-console,no-undef\n          console.warn('Canceling edit. Boolean operation erased entire polygon.');\n          return null;\n        }\n\n        var featureIndex = props.selectedIndexes[0];\n        var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replaceGeometry(featureIndex, updatedGeometry.geometry).getObject();\n        var editAction = {\n          updatedData: updatedData,\n          editType: 'unionGeometry',\n          editContext: {\n            featureIndexes: [featureIndex]\n          }\n        };\n        return editAction;\n      }\n\n      return this.getAddFeatureAction(geometry, props.data);\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(event, props) {}\n  }, {\n    key: \"handlePointerMove\",\n    value: function handlePointerMove(event, props) {}\n  }, {\n    key: \"handleStartDragging\",\n    value: function handleStartDragging(event, props) {}\n  }, {\n    key: \"handleStopDragging\",\n    value: function handleStopDragging(event, props) {}\n  }, {\n    key: \"handleDragging\",\n    value: function handleDragging(event, props) {}\n  }]);\n\n  return BaseGeoJsonEditMode;\n}();\n\nexports.BaseGeoJsonEditMode = BaseGeoJsonEditMode;\n\nfunction getIntermediatePosition(position1, position2) {\n  var intermediatePosition = [(position1[0] + position2[0]) / 2.0, (position1[1] + position2[1]) / 2.0];\n  return intermediatePosition;\n}","map":null,"metadata":{},"sourceType":"script"}