{"ast":null,"code":"var wgs84 = require('wgs84');\n\nmodule.exports.geometry = geometry;\nmodule.exports.ring = ringArea;\n\nfunction geometry(_) {\n  var area = 0,\n      i;\n\n  switch (_.type) {\n    case 'Polygon':\n      return polygonArea(_.coordinates);\n\n    case 'MultiPolygon':\n      for (i = 0; i < _.coordinates.length; i++) {\n        area += polygonArea(_.coordinates[i]);\n      }\n\n      return area;\n\n    case 'Point':\n    case 'MultiPoint':\n    case 'LineString':\n    case 'MultiLineString':\n      return 0;\n\n    case 'GeometryCollection':\n      for (i = 0; i < _.geometries.length; i++) {\n        area += geometry(_.geometries[i]);\n      }\n\n      return area;\n  }\n}\n\nfunction polygonArea(coords) {\n  var area = 0;\n\n  if (coords && coords.length > 0) {\n    area += Math.abs(ringArea(coords[0]));\n\n    for (var i = 1; i < coords.length; i++) {\n      area -= Math.abs(ringArea(coords[i]));\n    }\n  }\n\n  return area;\n}\n/**\n * Calculate the approximate area of the polygon were it projected onto\n *     the earth.  Note that this area will be positive if ring is oriented\n *     clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * Returns:\n * {float} The approximate signed geodesic area of the polygon in square\n *     meters.\n */\n\n\nfunction ringArea(coords) {\n  var p1,\n      p2,\n      p3,\n      lowerIndex,\n      middleIndex,\n      upperIndex,\n      i,\n      area = 0,\n      coordsLength = coords.length;\n\n  if (coordsLength > 2) {\n    for (i = 0; i < coordsLength; i++) {\n      if (i === coordsLength - 2) {\n        // i = N-2\n        lowerIndex = coordsLength - 2;\n        middleIndex = coordsLength - 1;\n        upperIndex = 0;\n      } else if (i === coordsLength - 1) {\n        // i = N-1\n        lowerIndex = coordsLength - 1;\n        middleIndex = 0;\n        upperIndex = 1;\n      } else {\n        // i = 0 to N-3\n        lowerIndex = i;\n        middleIndex = i + 1;\n        upperIndex = i + 2;\n      }\n\n      p1 = coords[lowerIndex];\n      p2 = coords[middleIndex];\n      p3 = coords[upperIndex];\n      area += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));\n    }\n\n    area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n  }\n\n  return area;\n}\n\nfunction rad(_) {\n  return _ * Math.PI / 180;\n}","map":{"version":3,"sources":["/home/gianluca/Documenti/Scuola/Informatica/Progetto/AboutMi/node_modules/@mapbox/geojson-area/index.js"],"names":["wgs84","require","module","exports","geometry","ring","ringArea","_","area","i","type","polygonArea","coordinates","length","geometries","coords","Math","abs","p1","p2","p3","lowerIndex","middleIndex","upperIndex","coordsLength","rad","sin","RADIUS","PI"],"mappings":"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","sourcesContent":["var wgs84 = require('wgs84');\n\nmodule.exports.geometry = geometry;\nmodule.exports.ring = ringArea;\n\nfunction geometry(_) {\n    var area = 0, i;\n    switch (_.type) {\n        case 'Polygon':\n            return polygonArea(_.coordinates);\n        case 'MultiPolygon':\n            for (i = 0; i < _.coordinates.length; i++) {\n                area += polygonArea(_.coordinates[i]);\n            }\n            return area;\n        case 'Point':\n        case 'MultiPoint':\n        case 'LineString':\n        case 'MultiLineString':\n            return 0;\n        case 'GeometryCollection':\n            for (i = 0; i < _.geometries.length; i++) {\n                area += geometry(_.geometries[i]);\n            }\n            return area;\n    }\n}\n\nfunction polygonArea(coords) {\n    var area = 0;\n    if (coords && coords.length > 0) {\n        area += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            area -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return area;\n}\n\n/**\n * Calculate the approximate area of the polygon were it projected onto\n *     the earth.  Note that this area will be positive if ring is oriented\n *     clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * Returns:\n * {float} The approximate signed geodesic area of the polygon in square\n *     meters.\n */\n\nfunction ringArea(coords) {\n    var p1, p2, p3, lowerIndex, middleIndex, upperIndex, i,\n    area = 0,\n    coordsLength = coords.length;\n\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {// i = N-2\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength -1;\n                upperIndex = 0;\n            } else if (i === coordsLength - 1) {// i = N-1\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            } else { // i = 0 to N-3\n                lowerIndex = i;\n                middleIndex = i+1;\n                upperIndex = i+2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            area += ( rad(p3[0]) - rad(p1[0]) ) * Math.sin( rad(p2[1]));\n        }\n\n        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n    }\n\n    return area;\n}\n\nfunction rad(_) {\n    return _ * Math.PI / 180;\n}"]},"metadata":{},"sourceType":"script"}