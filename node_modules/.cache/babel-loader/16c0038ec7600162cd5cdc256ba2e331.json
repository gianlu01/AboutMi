{"ast":null,"code":"/**\r\n * @module ol/geom/flat/geodesic\r\n */\nimport { squaredSegmentDistance, toRadians, toDegrees } from '../../math.js';\nimport { get as getProjection, getTransform } from '../../proj.js';\n/**\r\n * @param {function(number): import(\"../../coordinate.js\").Coordinate} interpolate Interpolate function.\r\n * @param {import(\"../../proj.js\").TransformFunction} transform Transform from longitude/latitude to\r\n *     projected coordinates.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @return {Array<number>} Flat coordinates.\r\n */\n\nfunction line(interpolate, transform, squaredTolerance) {\n  // FIXME reduce garbage generation\n  // FIXME optimize stack operations\n\n  /** @type {Array<number>} */\n  var flatCoordinates = [];\n  var geoA = interpolate(0);\n  var geoB = interpolate(1);\n  var a = transform(geoA);\n  var b = transform(geoB);\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n\n  var geoStack = [geoB, geoA];\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n\n  var stack = [b, a];\n  /** @type {Array<number>} */\n\n  var fractionStack = [1, 0];\n  /** @type {!Object<string, boolean>} */\n\n  var fractions = {};\n  var maxIterations = 1e5;\n  var geoM, m, fracA, fracB, fracM, key;\n\n  while (--maxIterations > 0 && fractionStack.length > 0) {\n    // Pop the a coordinate off the stack\n    fracA = fractionStack.pop();\n    geoA = geoStack.pop();\n    a = stack.pop(); // Add the a coordinate if it has not been added yet\n\n    key = fracA.toString();\n\n    if (!(key in fractions)) {\n      flatCoordinates.push(a[0], a[1]);\n      fractions[key] = true;\n    } // Pop the b coordinate off the stack\n\n\n    fracB = fractionStack.pop();\n    geoB = geoStack.pop();\n    b = stack.pop(); // Find the m point between the a and b coordinates\n\n    fracM = (fracA + fracB) / 2;\n    geoM = interpolate(fracM);\n    m = transform(geoM);\n\n    if (squaredSegmentDistance(m[0], m[1], a[0], a[1], b[0], b[1]) < squaredTolerance) {\n      // If the m point is sufficiently close to the straight line, then we\n      // discard it.  Just use the b coordinate and move on to the next line\n      // segment.\n      flatCoordinates.push(b[0], b[1]);\n      key = fracB.toString();\n      fractions[key] = true;\n    } else {\n      // Otherwise, we need to subdivide the current line segment.  Split it\n      // into two and push the two line segments onto the stack.\n      fractionStack.push(fracB, fracM, fracM, fracA);\n      stack.push(b, m, m, a);\n      geoStack.push(geoB, geoM, geoM, geoA);\n    }\n  }\n\n  return flatCoordinates;\n}\n/**\r\n * Generate a great-circle arcs between two lat/lon points.\r\n * @param {number} lon1 Longitude 1 in degrees.\r\n * @param {number} lat1 Latitude 1 in degrees.\r\n * @param {number} lon2 Longitude 2 in degrees.\r\n * @param {number} lat2 Latitude 2 in degrees.\r\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @return {Array<number>} Flat coordinates.\r\n */\n\n\nexport function greatCircleArc(lon1, lat1, lon2, lat2, projection, squaredTolerance) {\n  var geoProjection = getProjection('EPSG:4326');\n  var cosLat1 = Math.cos(toRadians(lat1));\n  var sinLat1 = Math.sin(toRadians(lat1));\n  var cosLat2 = Math.cos(toRadians(lat2));\n  var sinLat2 = Math.sin(toRadians(lat2));\n  var cosDeltaLon = Math.cos(toRadians(lon2 - lon1));\n  var sinDeltaLon = Math.sin(toRadians(lon2 - lon1));\n  var d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;\n  return line(\n  /**\r\n   * @param {number} frac Fraction.\r\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\r\n   */\n  function (frac) {\n    if (1 <= d) {\n      return [lon2, lat2];\n    }\n\n    var D = frac * Math.acos(d);\n    var cosD = Math.cos(D);\n    var sinD = Math.sin(D);\n    var y = sinDeltaLon * cosLat2;\n    var x = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon;\n    var theta = Math.atan2(y, x);\n    var lat = Math.asin(sinLat1 * cosD + cosLat1 * sinD * Math.cos(theta));\n    var lon = toRadians(lon1) + Math.atan2(Math.sin(theta) * sinD * cosLat1, cosD - sinLat1 * Math.sin(lat));\n    return [toDegrees(lon), toDegrees(lat)];\n  }, getTransform(geoProjection, projection), squaredTolerance);\n}\n/**\r\n * Generate a meridian (line at constant longitude).\r\n * @param {number} lon Longitude.\r\n * @param {number} lat1 Latitude 1.\r\n * @param {number} lat2 Latitude 2.\r\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @return {Array<number>} Flat coordinates.\r\n */\n\nexport function meridian(lon, lat1, lat2, projection, squaredTolerance) {\n  var epsg4326Projection = getProjection('EPSG:4326');\n  return line(\n  /**\r\n   * @param {number} frac Fraction.\r\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\r\n   */\n  function (frac) {\n    return [lon, lat1 + (lat2 - lat1) * frac];\n  }, getTransform(epsg4326Projection, projection), squaredTolerance);\n}\n/**\r\n * Generate a parallel (line at constant latitude).\r\n * @param {number} lat Latitude.\r\n * @param {number} lon1 Longitude 1.\r\n * @param {number} lon2 Longitude 2.\r\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @return {Array<number>} Flat coordinates.\r\n */\n\nexport function parallel(lat, lon1, lon2, projection, squaredTolerance) {\n  var epsg4326Projection = getProjection('EPSG:4326');\n  return line(\n  /**\r\n   * @param {number} frac Fraction.\r\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\r\n   */\n  function (frac) {\n    return [lon1 + (lon2 - lon1) * frac, lat];\n  }, getTransform(epsg4326Projection, projection), squaredTolerance);\n}","map":null,"metadata":{},"sourceType":"module"}