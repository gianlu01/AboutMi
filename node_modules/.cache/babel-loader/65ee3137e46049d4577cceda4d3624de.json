{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\michele\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\react-scripts\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\michele\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\react-scripts\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\michele\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\react-scripts\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\michele\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\react-scripts\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport KDBush from 'kdbush';\nvar defaultOptions = {\n  minZoom: 0,\n  // min zoom to generate clusters on\n  maxZoom: 16,\n  // max zoom level to cluster the points on\n  radius: 40,\n  // cluster radius in pixels\n  extent: 512,\n  // tile extent (radius is calculated relative to it)\n  nodeSize: 64,\n  // size of the KD-tree leaf node, affects performance\n  log: false,\n  // whether to log timing info\n  // whether to generate numeric ids for input features that don't have them\n  generateId: false,\n  // a reduce function for calculating custom cluster properties\n  reduce: null,\n  // (accumulated, props) => { accumulated.sum += props.sum; }\n  // properties to use for individual points when running the reducer\n  map: function map(props) {\n    return props;\n  } // props => ({sum: props.my_value})\n\n};\n\nvar Supercluster = /*#__PURE__*/function () {\n  function Supercluster(options) {\n    _classCallCheck(this, Supercluster);\n\n    this.options = extend(Object.create(defaultOptions), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n  }\n\n  _createClass(Supercluster, [{\n    key: \"load\",\n    value: function load(points) {\n      var _this$options = this.options,\n          log = _this$options.log,\n          minZoom = _this$options.minZoom,\n          maxZoom = _this$options.maxZoom,\n          nodeSize = _this$options.nodeSize;\n      if (log) console.time('total time');\n      var timerId = \"prepare \".concat(points.length, \" points\");\n      if (log) console.time(timerId);\n      this.points = points; // generate a cluster object for each point and index input points into a KD-tree\n\n      var clusters = [];\n\n      for (var i = 0; i < points.length; i++) {\n        if (!points[i].geometry) continue;\n        clusters.push(createPointCluster(points[i], i));\n      }\n\n      this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n      if (log) console.timeEnd(timerId); // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n      // results in a cluster hierarchy across zoom levels\n\n      for (var z = maxZoom; z >= minZoom; z--) {\n        var now = +Date.now(); // create a new set of clusters for the zoom and index them with a KD-tree\n\n        clusters = this._cluster(clusters, z);\n        this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n        if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n      }\n\n      if (log) console.timeEnd('total time');\n      return this;\n    }\n  }, {\n    key: \"getClusters\",\n    value: function getClusters(bbox, zoom) {\n      var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n      var minLat = Math.max(-90, Math.min(90, bbox[1]));\n      var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n      var maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n      if (bbox[2] - bbox[0] >= 360) {\n        minLng = -180;\n        maxLng = 180;\n      } else if (minLng > maxLng) {\n        var easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n        var westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n        return easternHem.concat(westernHem);\n      }\n\n      var tree = this.trees[this._limitZoom(zoom)];\n\n      var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n      var clusters = [];\n\n      var _iterator = _createForOfIteratorHelper(ids),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var id = _step.value;\n          var c = tree.points[id];\n          clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return clusters;\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(clusterId) {\n      var originId = this._getOriginId(clusterId);\n\n      var originZoom = this._getOriginZoom(clusterId);\n\n      var errorMsg = 'No cluster with the specified id.';\n      var index = this.trees[originZoom];\n      if (!index) throw new Error(errorMsg);\n      var origin = index.points[originId];\n      if (!origin) throw new Error(errorMsg);\n      var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n      var ids = index.within(origin.x, origin.y, r);\n      var children = [];\n\n      var _iterator2 = _createForOfIteratorHelper(ids),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var id = _step2.value;\n          var c = index.points[id];\n\n          if (c.parentId === clusterId) {\n            children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (children.length === 0) throw new Error(errorMsg);\n      return children;\n    }\n  }, {\n    key: \"getLeaves\",\n    value: function getLeaves(clusterId, limit, offset) {\n      limit = limit || 10;\n      offset = offset || 0;\n      var leaves = [];\n\n      this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n      return leaves;\n    }\n  }, {\n    key: \"getTile\",\n    value: function getTile(z, x, y) {\n      var tree = this.trees[this._limitZoom(z)];\n\n      var z2 = Math.pow(2, z);\n      var _this$options2 = this.options,\n          extent = _this$options2.extent,\n          radius = _this$options2.radius;\n      var p = radius / extent;\n      var top = (y - p) / z2;\n      var bottom = (y + 1 + p) / z2;\n      var tile = {\n        features: []\n      };\n\n      this._addTileFeatures(tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom), tree.points, x, y, z2, tile);\n\n      if (x === 0) {\n        this._addTileFeatures(tree.range(1 - p / z2, top, 1, bottom), tree.points, z2, y, z2, tile);\n      }\n\n      if (x === z2 - 1) {\n        this._addTileFeatures(tree.range(0, top, p / z2, bottom), tree.points, -1, y, z2, tile);\n      }\n\n      return tile.features.length ? tile : null;\n    }\n  }, {\n    key: \"getClusterExpansionZoom\",\n    value: function getClusterExpansionZoom(clusterId) {\n      var expansionZoom = this._getOriginZoom(clusterId) - 1;\n\n      while (expansionZoom <= this.options.maxZoom) {\n        var children = this.getChildren(clusterId);\n        expansionZoom++;\n        if (children.length !== 1) break;\n        clusterId = children[0].properties.cluster_id;\n      }\n\n      return expansionZoom;\n    }\n  }, {\n    key: \"_appendLeaves\",\n    value: function _appendLeaves(result, clusterId, limit, offset, skipped) {\n      var children = this.getChildren(clusterId);\n\n      var _iterator3 = _createForOfIteratorHelper(children),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var child = _step3.value;\n          var props = child.properties;\n\n          if (props && props.cluster) {\n            if (skipped + props.point_count <= offset) {\n              // skip the whole cluster\n              skipped += props.point_count;\n            } else {\n              // enter the cluster\n              skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped); // exit the cluster\n            }\n          } else if (skipped < offset) {\n            // skip a single point\n            skipped++;\n          } else {\n            // add a single point\n            result.push(child);\n          }\n\n          if (result.length === limit) break;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return skipped;\n    }\n  }, {\n    key: \"_addTileFeatures\",\n    value: function _addTileFeatures(ids, points, x, y, z2, tile) {\n      var _iterator4 = _createForOfIteratorHelper(ids),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var i = _step4.value;\n          var c = points[i];\n          var isCluster = c.numPoints;\n          var f = {\n            type: 1,\n            geometry: [[Math.round(this.options.extent * (c.x * z2 - x)), Math.round(this.options.extent * (c.y * z2 - y))]],\n            tags: isCluster ? getClusterProperties(c) : this.points[c.index].properties\n          }; // assign id\n\n          var id = void 0;\n\n          if (isCluster) {\n            id = c.id;\n          } else if (this.options.generateId) {\n            // optionally generate id\n            id = c.index;\n          } else if (this.points[c.index].id) {\n            // keep id if already assigned\n            id = this.points[c.index].id;\n          }\n\n          if (id !== undefined) f.id = id;\n          tile.features.push(f);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"_limitZoom\",\n    value: function _limitZoom(z) {\n      return Math.max(this.options.minZoom, Math.min(z, this.options.maxZoom + 1));\n    }\n  }, {\n    key: \"_cluster\",\n    value: function _cluster(points, zoom) {\n      var clusters = [];\n      var _this$options3 = this.options,\n          radius = _this$options3.radius,\n          extent = _this$options3.extent,\n          reduce = _this$options3.reduce;\n      var r = radius / (extent * Math.pow(2, zoom)); // loop through each point\n\n      for (var i = 0; i < points.length; i++) {\n        var p = points[i]; // if we've already visited the point at this zoom level, skip it\n\n        if (p.zoom <= zoom) continue;\n        p.zoom = zoom; // find all nearby points\n\n        var tree = this.trees[zoom + 1];\n        var neighborIds = tree.within(p.x, p.y, r);\n        var numPoints = p.numPoints || 1;\n        var wx = p.x * numPoints;\n        var wy = p.y * numPoints;\n        var clusterProperties = reduce && numPoints > 1 ? this._map(p, true) : null; // encode both zoom and point index on which the cluster originated -- offset by total length of features\n\n        var id = (i << 5) + (zoom + 1) + this.points.length;\n\n        var _iterator5 = _createForOfIteratorHelper(neighborIds),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var neighborId = _step5.value;\n            var b = tree.points[neighborId]; // filter out neighbors that are already processed\n\n            if (b.zoom <= zoom) continue;\n            b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n            var numPoints2 = b.numPoints || 1;\n            wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n\n            wy += b.y * numPoints2;\n            numPoints += numPoints2;\n            b.parentId = id;\n\n            if (reduce) {\n              if (!clusterProperties) clusterProperties = this._map(p, true);\n              reduce(clusterProperties, this._map(b));\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        if (numPoints === 1) {\n          clusters.push(p);\n        } else {\n          p.parentId = id;\n          clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n        }\n      }\n\n      return clusters;\n    } // get index of the point from which the cluster originated\n\n  }, {\n    key: \"_getOriginId\",\n    value: function _getOriginId(clusterId) {\n      return clusterId - this.points.length >> 5;\n    } // get zoom of the point from which the cluster originated\n\n  }, {\n    key: \"_getOriginZoom\",\n    value: function _getOriginZoom(clusterId) {\n      return (clusterId - this.points.length) % 32;\n    }\n  }, {\n    key: \"_map\",\n    value: function _map(point, clone) {\n      if (point.numPoints) {\n        return clone ? extend({}, point.properties) : point.properties;\n      }\n\n      var original = this.points[point.index].properties;\n      var result = this.options.map(original);\n      return clone && result === original ? extend({}, result) : result;\n    }\n  }]);\n\n  return Supercluster;\n}();\n\nexport { Supercluster as default };\n\nfunction createCluster(x, y, id, numPoints, properties) {\n  return {\n    x: x,\n    // weighted cluster center\n    y: y,\n    zoom: Infinity,\n    // the last zoom the cluster was processed at\n    id: id,\n    // encodes index of the first child of the cluster and its zoom level\n    parentId: -1,\n    // parent cluster id\n    numPoints: numPoints,\n    properties: properties\n  };\n}\n\nfunction createPointCluster(p, id) {\n  var _p$geometry$coordinat = _slicedToArray(p.geometry.coordinates, 2),\n      x = _p$geometry$coordinat[0],\n      y = _p$geometry$coordinat[1];\n\n  return {\n    x: lngX(x),\n    // projected point coordinates\n    y: latY(y),\n    zoom: Infinity,\n    // the last zoom the point was processed at\n    index: id,\n    // index of the source feature in the original input array,\n    parentId: -1 // parent cluster id\n\n  };\n}\n\nfunction getClusterJSON(cluster) {\n  return {\n    type: 'Feature',\n    id: cluster.id,\n    properties: getClusterProperties(cluster),\n    geometry: {\n      type: 'Point',\n      coordinates: [xLng(cluster.x), yLat(cluster.y)]\n    }\n  };\n}\n\nfunction getClusterProperties(cluster) {\n  var count = cluster.numPoints;\n  var abbrev = count >= 10000 ? \"\".concat(Math.round(count / 1000), \"k\") : count >= 1000 ? \"\".concat(Math.round(count / 100) / 10, \"k\") : count;\n  return extend(extend({}, cluster.properties), {\n    cluster: true,\n    cluster_id: cluster.id,\n    point_count: count,\n    point_count_abbreviated: abbrev\n  });\n} // longitude/latitude to spherical mercator in [0..1] range\n\n\nfunction lngX(lng) {\n  return lng / 360 + 0.5;\n}\n\nfunction latY(lat) {\n  var sin = Math.sin(lat * Math.PI / 180);\n  var y = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n  return y < 0 ? 0 : y > 1 ? 1 : y;\n} // spherical mercator to longitude/latitude\n\n\nfunction xLng(x) {\n  return (x - 0.5) * 360;\n}\n\nfunction yLat(y) {\n  var y2 = (180 - y * 360) * Math.PI / 180;\n  return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n  for (var id in src) {\n    dest[id] = src[id];\n  }\n\n  return dest;\n}\n\nfunction getX(p) {\n  return p.x;\n}\n\nfunction getY(p) {\n  return p.y;\n}","map":{"version":3,"sources":["C:/Users/michele/Desktop/IT/Code/react/aboutmi/node_modules/supercluster/index.js"],"names":["KDBush","defaultOptions","minZoom","maxZoom","radius","extent","nodeSize","log","generateId","reduce","map","props","Supercluster","options","extend","Object","create","trees","Array","points","console","time","timerId","length","clusters","i","geometry","push","createPointCluster","getX","getY","Float32Array","timeEnd","z","now","Date","_cluster","bbox","zoom","minLng","minLat","Math","max","min","maxLng","maxLat","easternHem","getClusters","westernHem","concat","tree","_limitZoom","ids","range","lngX","latY","id","c","numPoints","getClusterJSON","index","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","Error","origin","r","pow","within","x","y","children","parentId","limit","offset","leaves","_appendLeaves","z2","p","top","bottom","tile","features","_addTileFeatures","expansionZoom","getChildren","properties","cluster_id","result","skipped","child","cluster","point_count","isCluster","f","type","round","tags","getClusterProperties","undefined","neighborIds","wx","wy","clusterProperties","_map","neighborId","b","numPoints2","createCluster","point","clone","original","Infinity","coordinates","xLng","yLat","count","abbrev","point_count_abbreviated","lng","lat","sin","PI","y2","atan","exp","dest","src"],"mappings":"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","sourcesContent":["\r\nimport KDBush from 'kdbush';\r\n\r\nconst defaultOptions = {\r\n    minZoom: 0,   // min zoom to generate clusters on\r\n    maxZoom: 16,  // max zoom level to cluster the points on\r\n    radius: 40,   // cluster radius in pixels\r\n    extent: 512,  // tile extent (radius is calculated relative to it)\r\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\r\n    log: false,   // whether to log timing info\r\n\r\n    // whether to generate numeric ids for input features that don't have them\r\n    generateId: false,\r\n\r\n    // a reduce function for calculating custom cluster properties\r\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\r\n\r\n    // properties to use for individual points when running the reducer\r\n    map: props => props // props => ({sum: props.my_value})\r\n};\r\n\r\nexport default class Supercluster {\r\n    constructor(options) {\r\n        this.options = extend(Object.create(defaultOptions), options);\r\n        this.trees = new Array(this.options.maxZoom + 1);\r\n    }\r\n\r\n    load(points) {\r\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\r\n\r\n        if (log) console.time('total time');\r\n\r\n        const timerId = `prepare ${  points.length  } points`;\r\n        if (log) console.time(timerId);\r\n\r\n        this.points = points;\r\n\r\n        // generate a cluster object for each point and index input points into a KD-tree\r\n        let clusters = [];\r\n        for (let i = 0; i < points.length; i++) {\r\n            if (!points[i].geometry) continue;\r\n            clusters.push(createPointCluster(points[i], i));\r\n        }\r\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\r\n\r\n        if (log) console.timeEnd(timerId);\r\n\r\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\r\n        // results in a cluster hierarchy across zoom levels\r\n        for (let z = maxZoom; z >= minZoom; z--) {\r\n            const now = +Date.now();\r\n\r\n            // create a new set of clusters for the zoom and index them with a KD-tree\r\n            clusters = this._cluster(clusters, z);\r\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\r\n\r\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\r\n        }\r\n\r\n        if (log) console.timeEnd('total time');\r\n\r\n        return this;\r\n    }\r\n\r\n    getClusters(bbox, zoom) {\r\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\r\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\r\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\r\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\r\n\r\n        if (bbox[2] - bbox[0] >= 360) {\r\n            minLng = -180;\r\n            maxLng = 180;\r\n        } else if (minLng > maxLng) {\r\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\r\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\r\n            return easternHem.concat(westernHem);\r\n        }\r\n\r\n        const tree = this.trees[this._limitZoom(zoom)];\r\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\r\n        const clusters = [];\r\n        for (const id of ids) {\r\n            const c = tree.points[id];\r\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\r\n        }\r\n        return clusters;\r\n    }\r\n\r\n    getChildren(clusterId) {\r\n        const originId = this._getOriginId(clusterId);\r\n        const originZoom = this._getOriginZoom(clusterId);\r\n        const errorMsg = 'No cluster with the specified id.';\r\n\r\n        const index = this.trees[originZoom];\r\n        if (!index) throw new Error(errorMsg);\r\n\r\n        const origin = index.points[originId];\r\n        if (!origin) throw new Error(errorMsg);\r\n\r\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\r\n        const ids = index.within(origin.x, origin.y, r);\r\n        const children = [];\r\n        for (const id of ids) {\r\n            const c = index.points[id];\r\n            if (c.parentId === clusterId) {\r\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\r\n            }\r\n        }\r\n\r\n        if (children.length === 0) throw new Error(errorMsg);\r\n\r\n        return children;\r\n    }\r\n\r\n    getLeaves(clusterId, limit, offset) {\r\n        limit = limit || 10;\r\n        offset = offset || 0;\r\n\r\n        const leaves = [];\r\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\r\n\r\n        return leaves;\r\n    }\r\n\r\n    getTile(z, x, y) {\r\n        const tree = this.trees[this._limitZoom(z)];\r\n        const z2 = Math.pow(2, z);\r\n        const {extent, radius} = this.options;\r\n        const p = radius / extent;\r\n        const top = (y - p) / z2;\r\n        const bottom = (y + 1 + p) / z2;\r\n\r\n        const tile = {\r\n            features: []\r\n        };\r\n\r\n        this._addTileFeatures(\r\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\r\n            tree.points, x, y, z2, tile);\r\n\r\n        if (x === 0) {\r\n            this._addTileFeatures(\r\n                tree.range(1 - p / z2, top, 1, bottom),\r\n                tree.points, z2, y, z2, tile);\r\n        }\r\n        if (x === z2 - 1) {\r\n            this._addTileFeatures(\r\n                tree.range(0, top, p / z2, bottom),\r\n                tree.points, -1, y, z2, tile);\r\n        }\r\n\r\n        return tile.features.length ? tile : null;\r\n    }\r\n\r\n    getClusterExpansionZoom(clusterId) {\r\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\r\n        while (expansionZoom <= this.options.maxZoom) {\r\n            const children = this.getChildren(clusterId);\r\n            expansionZoom++;\r\n            if (children.length !== 1) break;\r\n            clusterId = children[0].properties.cluster_id;\r\n        }\r\n        return expansionZoom;\r\n    }\r\n\r\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\r\n        const children = this.getChildren(clusterId);\r\n\r\n        for (const child of children) {\r\n            const props = child.properties;\r\n\r\n            if (props && props.cluster) {\r\n                if (skipped + props.point_count <= offset) {\r\n                    // skip the whole cluster\r\n                    skipped += props.point_count;\r\n                } else {\r\n                    // enter the cluster\r\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\r\n                    // exit the cluster\r\n                }\r\n            } else if (skipped < offset) {\r\n                // skip a single point\r\n                skipped++;\r\n            } else {\r\n                // add a single point\r\n                result.push(child);\r\n            }\r\n            if (result.length === limit) break;\r\n        }\r\n\r\n        return skipped;\r\n    }\r\n\r\n    _addTileFeatures(ids, points, x, y, z2, tile) {\r\n        for (const i of ids) {\r\n            const c = points[i];\r\n            const isCluster = c.numPoints;\r\n            const f = {\r\n                type: 1,\r\n                geometry: [[\r\n                    Math.round(this.options.extent * (c.x * z2 - x)),\r\n                    Math.round(this.options.extent * (c.y * z2 - y))\r\n                ]],\r\n                tags: isCluster ? getClusterProperties(c) : this.points[c.index].properties\r\n            };\r\n\r\n            // assign id\r\n            let id;\r\n            if (isCluster) {\r\n                id = c.id;\r\n            } else if (this.options.generateId) {\r\n                // optionally generate id\r\n                id = c.index;\r\n            } else if (this.points[c.index].id) {\r\n                // keep id if already assigned\r\n                id = this.points[c.index].id;\r\n            }\r\n\r\n            if (id !== undefined) f.id = id;\r\n\r\n            tile.features.push(f);\r\n        }\r\n    }\r\n\r\n    _limitZoom(z) {\r\n        return Math.max(this.options.minZoom, Math.min(z, this.options.maxZoom + 1));\r\n    }\r\n\r\n    _cluster(points, zoom) {\r\n        const clusters = [];\r\n        const {radius, extent, reduce} = this.options;\r\n        const r = radius / (extent * Math.pow(2, zoom));\r\n\r\n        // loop through each point\r\n        for (let i = 0; i < points.length; i++) {\r\n            const p = points[i];\r\n            // if we've already visited the point at this zoom level, skip it\r\n            if (p.zoom <= zoom) continue;\r\n            p.zoom = zoom;\r\n\r\n            // find all nearby points\r\n            const tree = this.trees[zoom + 1];\r\n            const neighborIds = tree.within(p.x, p.y, r);\r\n\r\n            let numPoints = p.numPoints || 1;\r\n            let wx = p.x * numPoints;\r\n            let wy = p.y * numPoints;\r\n\r\n            let clusterProperties = reduce && numPoints > 1 ? this._map(p, true) : null;\r\n\r\n            // encode both zoom and point index on which the cluster originated -- offset by total length of features\r\n            const id = (i << 5) + (zoom + 1) + this.points.length;\r\n\r\n            for (const neighborId of neighborIds) {\r\n                const b = tree.points[neighborId];\r\n                // filter out neighbors that are already processed\r\n                if (b.zoom <= zoom) continue;\r\n                b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\r\n\r\n                const numPoints2 = b.numPoints || 1;\r\n                wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\r\n                wy += b.y * numPoints2;\r\n\r\n                numPoints += numPoints2;\r\n                b.parentId = id;\r\n\r\n                if (reduce) {\r\n                    if (!clusterProperties) clusterProperties = this._map(p, true);\r\n                    reduce(clusterProperties, this._map(b));\r\n                }\r\n            }\r\n\r\n            if (numPoints === 1) {\r\n                clusters.push(p);\r\n            } else {\r\n                p.parentId = id;\r\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\r\n            }\r\n        }\r\n\r\n        return clusters;\r\n    }\r\n\r\n    // get index of the point from which the cluster originated\r\n    _getOriginId(clusterId) {\r\n        return (clusterId - this.points.length) >> 5;\r\n    }\r\n\r\n    // get zoom of the point from which the cluster originated\r\n    _getOriginZoom(clusterId) {\r\n        return (clusterId - this.points.length) % 32;\r\n    }\r\n\r\n    _map(point, clone) {\r\n        if (point.numPoints) {\r\n            return clone ? extend({}, point.properties) : point.properties;\r\n        }\r\n        const original = this.points[point.index].properties;\r\n        const result = this.options.map(original);\r\n        return clone && result === original ? extend({}, result) : result;\r\n    }\r\n}\r\n\r\nfunction createCluster(x, y, id, numPoints, properties) {\r\n    return {\r\n        x, // weighted cluster center\r\n        y,\r\n        zoom: Infinity, // the last zoom the cluster was processed at\r\n        id, // encodes index of the first child of the cluster and its zoom level\r\n        parentId: -1, // parent cluster id\r\n        numPoints,\r\n        properties\r\n    };\r\n}\r\n\r\nfunction createPointCluster(p, id) {\r\n    const [x, y] = p.geometry.coordinates;\r\n    return {\r\n        x: lngX(x), // projected point coordinates\r\n        y: latY(y),\r\n        zoom: Infinity, // the last zoom the point was processed at\r\n        index: id, // index of the source feature in the original input array,\r\n        parentId: -1 // parent cluster id\r\n    };\r\n}\r\n\r\nfunction getClusterJSON(cluster) {\r\n    return {\r\n        type: 'Feature',\r\n        id: cluster.id,\r\n        properties: getClusterProperties(cluster),\r\n        geometry: {\r\n            type: 'Point',\r\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\r\n        }\r\n    };\r\n}\r\n\r\nfunction getClusterProperties(cluster) {\r\n    const count = cluster.numPoints;\r\n    const abbrev =\r\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\r\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\r\n    return extend(extend({}, cluster.properties), {\r\n        cluster: true,\r\n        cluster_id: cluster.id,\r\n        point_count: count,\r\n        point_count_abbreviated: abbrev\r\n    });\r\n}\r\n\r\n// longitude/latitude to spherical mercator in [0..1] range\r\nfunction lngX(lng) {\r\n    return lng / 360 + 0.5;\r\n}\r\nfunction latY(lat) {\r\n    const sin = Math.sin(lat * Math.PI / 180);\r\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\r\n    return y < 0 ? 0 : y > 1 ? 1 : y;\r\n}\r\n\r\n// spherical mercator to longitude/latitude\r\nfunction xLng(x) {\r\n    return (x - 0.5) * 360;\r\n}\r\nfunction yLat(y) {\r\n    const y2 = (180 - y * 360) * Math.PI / 180;\r\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\r\n}\r\n\r\nfunction extend(dest, src) {\r\n    for (const id in src) dest[id] = src[id];\r\n    return dest;\r\n}\r\n\r\nfunction getX(p) {\r\n    return p.x;\r\n}\r\nfunction getY(p) {\r\n    return p.y;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}