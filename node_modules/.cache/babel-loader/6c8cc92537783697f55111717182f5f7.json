{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toDeckColor = toDeckColor;\nexports.recursivelyTraverseNestedArrays = recursivelyTraverseNestedArrays;\nexports.generatePointsParallelToLinePoints = generatePointsParallelToLinePoints;\nexports.distance2d = distance2d;\nexports.mix = mix;\nexports.nearestPointOnProjectedLine = nearestPointOnProjectedLine;\nexports.getPickedEditHandle = getPickedEditHandle;\nexports.getNonGuidePicks = getNonGuidePicks;\nexports.getPickedExistingEditHandle = getPickedExistingEditHandle;\nexports.getPickedIntermediateEditHandle = getPickedIntermediateEditHandle;\nexports.getPickedEditHandles = getPickedEditHandles;\nexports.getEditHandlesForGeometry = getEditHandlesForGeometry;\n\nvar _destination = _interopRequireDefault(require(\"@turf/destination\"));\n\nvar _bearing = _interopRequireDefault(require(\"@turf/bearing\"));\n\nvar _pointToLineDistance = _interopRequireDefault(require(\"@turf/point-to-line-distance\"));\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _viewportMercatorProject = _interopRequireDefault(require(\"viewport-mercator-project\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction toDeckColor(color) {\n  var defaultColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [255, 0, 0, 255];\n\n  if (!Array.isArray(color)) {\n    return defaultColor;\n  }\n\n  return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];\n} //\n// a GeoJSON helper function that calls the provided function with\n// an argument that is the most deeply-nested array having elements\n// that are arrays of primitives as an argument, e.g.\n//\n// {\n//   \"type\": \"MultiPolygon\",\n//   \"coordinates\": [\n//       [\n//           [[30, 20], [45, 40], [10, 40], [30, 20]]\n//       ],\n//       [\n//           [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//       ]\n//   ]\n// }\n//\n// the function would be called on:\n//\n// [[30, 20], [45, 40], [10, 40], [30, 20]]\n//\n// and\n//\n// [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//\n\n\nfunction recursivelyTraverseNestedArrays(array, prefix, fn) {\n  if (!Array.isArray(array[0])) {\n    return true;\n  }\n\n  for (var i = 0; i < array.length; i++) {\n    if (recursivelyTraverseNestedArrays(array[i], _toConsumableArray(prefix).concat([i]), fn)) {\n      fn(array, prefix);\n      break;\n    }\n  }\n\n  return false;\n}\n\nfunction generatePointsParallelToLinePoints(p1, p2, mapCoords) {\n  var lineString = {\n    type: 'LineString',\n    coordinates: [p1, p2]\n  };\n  var pt = (0, _helpers.point)(mapCoords);\n  var ddistance = (0, _pointToLineDistance.default)(pt, lineString);\n  var lineBearing = (0, _bearing.default)(p1, p2); // Check if current point is to the left or right of line\n  // Line from A=(x1,y1) to B=(x2,y2) a point P=(x,y)\n  // then (x−x1)(y2−y1)−(y−y1)(x2−x1)\n\n  var isPointToLeftOfLine = (mapCoords[0] - p1[0]) * (p2[1] - p1[1]) - (mapCoords[1] - p1[1]) * (p2[0] - p1[0]); // Bearing to draw perpendicular to the line string\n\n  var orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270; // Get coordinates for the point p3 and p4 which are perpendicular to the lineString\n  // Add the distance as the current position moves away from the lineString\n\n  var p3 = (0, _destination.default)(p2, ddistance, orthogonalBearing);\n  var p4 = (0, _destination.default)(p1, ddistance, orthogonalBearing);\n  return [p3.geometry.coordinates, p4.geometry.coordinates];\n}\n\nfunction distance2d(x1, y1, x2, y2) {\n  var dx = x1 - x2;\n  var dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction mix(a, b, ratio) {\n  return b * ratio + a * (1 - ratio);\n}\n\nfunction nearestPointOnProjectedLine(line, inPoint, viewport) {\n  var wmViewport = new _viewportMercatorProject.default(viewport); // Project the line to viewport, then find the nearest point\n\n  var coordinates = line.geometry.coordinates;\n  var projectedCoords = coordinates.map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 3),\n        x = _ref2[0],\n        y = _ref2[1],\n        _ref2$ = _ref2[2],\n        z = _ref2$ === void 0 ? 0 : _ref2$;\n\n    return wmViewport.project([x, y, z]);\n  });\n\n  var _wmViewport$project = wmViewport.project(inPoint.geometry.coordinates),\n      _wmViewport$project2 = _slicedToArray(_wmViewport$project, 2),\n      x = _wmViewport$project2[0],\n      y = _wmViewport$project2[1]; // console.log('projectedCoords', JSON.stringify(projectedCoords));\n\n\n  var minDistance = Infinity;\n  var minPointInfo = {};\n  projectedCoords.forEach(function (_ref3, index) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        x2 = _ref4[0],\n        y2 = _ref4[1];\n\n    if (index === 0) {\n      return;\n    }\n\n    var _projectedCoords = _slicedToArray(projectedCoords[index - 1], 2),\n        x1 = _projectedCoords[0],\n        y1 = _projectedCoords[1]; // line from projectedCoords[index - 1] to projectedCoords[index]\n    // convert to Ax + By + C = 0\n\n\n    var A = y1 - y2;\n    var B = x2 - x1;\n    var C = x1 * y2 - x2 * y1; // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n\n    var div = A * A + B * B;\n    var distance = Math.abs(A * x + B * y + C) / Math.sqrt(div); // TODO: Check if inside bounds\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPointInfo = {\n        index: index,\n        x0: (B * (B * x - A * y) - A * C) / div,\n        y0: (A * (-B * x + A * y) - B * C) / div\n      };\n    }\n  });\n  var _minPointInfo = minPointInfo,\n      index = _minPointInfo.index,\n      x0 = _minPointInfo.x0,\n      y0 = _minPointInfo.y0;\n\n  var _projectedCoords2 = _slicedToArray(projectedCoords[index - 1], 3),\n      x1 = _projectedCoords2[0],\n      y1 = _projectedCoords2[1],\n      _projectedCoords2$ = _projectedCoords2[2],\n      z1 = _projectedCoords2$ === void 0 ? 0 : _projectedCoords2$;\n\n  var _projectedCoords$inde = _slicedToArray(projectedCoords[index], 3),\n      x2 = _projectedCoords$inde[0],\n      y2 = _projectedCoords$inde[1],\n      _projectedCoords$inde2 = _projectedCoords$inde[2],\n      z2 = _projectedCoords$inde2 === void 0 ? 0 : _projectedCoords$inde2; // calculate what ratio of the line we are on to find the proper z\n\n\n  var lineLength = distance2d(x1, y1, x2, y2);\n  var startToPointLength = distance2d(x1, y1, x0, y0);\n  var ratio = startToPointLength / lineLength;\n  var z0 = mix(z1, z2, ratio);\n  return {\n    type: 'Feature',\n    geometry: {\n      type: 'Point',\n      coordinates: wmViewport.unproject([x0, y0, z0])\n    },\n    properties: {\n      // TODO: calculate the distance in proper units\n      dist: minDistance,\n      index: index - 1\n    }\n  };\n}\n\nfunction getPickedEditHandle(picks) {\n  var handles = getPickedEditHandles(picks);\n  return handles.length ? handles[0] : null;\n}\n\nfunction getNonGuidePicks(picks) {\n  return picks && picks.filter(function (pick) {\n    return !pick.isGuide;\n  });\n}\n\nfunction getPickedExistingEditHandle(picks) {\n  var handles = getPickedEditHandles(picks);\n  return handles.find(function (_ref5) {\n    var properties = _ref5.properties;\n    return properties.featureIndex >= 0 && properties.editHandleType === 'existing';\n  });\n}\n\nfunction getPickedIntermediateEditHandle(picks) {\n  var handles = getPickedEditHandles(picks);\n  return handles.find(function (_ref6) {\n    var properties = _ref6.properties;\n    return properties.featureIndex >= 0 && properties.editHandleType === 'intermediate';\n  });\n}\n\nfunction getPickedEditHandles(picks) {\n  var handles = picks && picks.filter(function (pick) {\n    return pick.isGuide && pick.object.properties.guideType === 'editHandle';\n  }).map(function (pick) {\n    return pick.object;\n  }) || [];\n  return handles;\n}\n\nfunction getEditHandlesForGeometry(geometry, featureIndex) {\n  var editHandleType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'existing';\n  var handles = [];\n\n  switch (geometry.type) {\n    case 'Point':\n      // positions are not nested\n      handles = [{\n        type: 'Feature',\n        properties: {\n          guideType: 'editHandle',\n          editHandleType: editHandleType,\n          positionIndexes: [],\n          featureIndex: featureIndex\n        },\n        geometry: {\n          type: 'Point',\n          coordinates: geometry.coordinates\n        }\n      }];\n      break;\n\n    case 'MultiPoint':\n    case 'LineString':\n      // positions are nested 1 level\n      handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates, [], featureIndex, editHandleType));\n      break;\n\n    case 'Polygon':\n    case 'MultiLineString':\n      // positions are nested 2 levels\n      for (var a = 0; a < geometry.coordinates.length; a++) {\n        handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[a], [a], featureIndex, editHandleType));\n\n        if (geometry.type === 'Polygon') {\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n\n      break;\n\n    case 'MultiPolygon':\n      // positions are nested 3 levels\n      for (var _a = 0; _a < geometry.coordinates.length; _a++) {\n        for (var b = 0; b < geometry.coordinates[_a].length; b++) {\n          handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[_a][b], [_a, b], featureIndex, editHandleType)); // Don't repeat the first/last handle for Polygons\n\n          handles = handles.slice(0, -1);\n        }\n      }\n\n      break;\n\n    default:\n      throw Error(\"Unhandled geometry type: \".concat(geometry.type));\n  }\n\n  return handles;\n}\n\nfunction getEditHandlesForCoordinates(coordinates, positionIndexPrefix, featureIndex) {\n  var editHandleType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'existing';\n  var editHandles = [];\n\n  for (var i = 0; i < coordinates.length; i++) {\n    var position = coordinates[i];\n    editHandles.push({\n      type: 'Feature',\n      properties: {\n        guideType: 'editHandle',\n        positionIndexes: _toConsumableArray(positionIndexPrefix).concat([i]),\n        featureIndex: featureIndex,\n        editHandleType: editHandleType\n      },\n      geometry: {\n        type: 'Point',\n        coordinates: position\n      }\n    });\n  }\n\n  return editHandles;\n}","map":null,"metadata":{},"sourceType":"script"}