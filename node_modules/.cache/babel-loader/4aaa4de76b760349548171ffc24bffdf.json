{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // Taken from http://geomalgorithms.com/a02-_lines.html\n\nvar distance_1 = __importDefault(require(\"@turf/distance\"));\n\nvar helpers_1 = require(\"@turf/helpers\");\n\nvar invariant_1 = require(\"@turf/invariant\");\n\nvar meta_1 = require(\"@turf/meta\");\n\nvar rhumb_distance_1 = __importDefault(require(\"@turf/rhumb-distance\"));\n/**\n * Returns the minimum distance between a {@link Point} and a {@link LineString}, being the distance from a line the\n * minimum distance between the point and any segment of the `LineString`.\n *\n * @name pointToLineDistance\n * @param {Feature<Point>|Array<number>} pt Feature or Geometry\n * @param {Feature<LineString>} line GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] can be anything supported by turf/convertLength\n * (ex: degrees, radians, miles, or kilometers)\n * @param {string} [options.method=\"geodesic\"] wether to calculate the distance based on geodesic (spheroid) or\n * planar (flat) method. Valid options are 'geodesic' or 'planar'.\n * @returns {number} distance between point and line\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[1, 1],[-1, 1]]);\n *\n * var distance = turf.pointToLineDistance(pt, line, {units: 'miles'});\n * //=69.11854715938406\n */\n\n\nfunction pointToLineDistance(pt, line, options) {\n  if (options === void 0) {\n    options = {};\n  } // Optional parameters\n\n\n  if (!options.method) {\n    options.method = \"geodesic\";\n  }\n\n  if (!options.units) {\n    options.units = \"kilometers\";\n  } // validation\n\n\n  if (!pt) {\n    throw new Error(\"pt is required\");\n  }\n\n  if (Array.isArray(pt)) {\n    pt = helpers_1.point(pt);\n  } else if (pt.type === \"Point\") {\n    pt = helpers_1.feature(pt);\n  } else {\n    invariant_1.featureOf(pt, \"Point\", \"point\");\n  }\n\n  if (!line) {\n    throw new Error(\"line is required\");\n  }\n\n  if (Array.isArray(line)) {\n    line = helpers_1.lineString(line);\n  } else if (line.type === \"LineString\") {\n    line = helpers_1.feature(line);\n  } else {\n    invariant_1.featureOf(line, \"LineString\", \"line\");\n  }\n\n  var distance = Infinity;\n  var p = pt.geometry.coordinates;\n  meta_1.segmentEach(line, function (segment) {\n    var a = segment.geometry.coordinates[0];\n    var b = segment.geometry.coordinates[1];\n    var d = distanceToSegment(p, a, b, options);\n\n    if (d < distance) {\n      distance = d;\n    }\n  });\n  return helpers_1.convertLength(distance, \"degrees\", options.units);\n}\n/**\n * Returns the distance between a point P on a segment AB.\n *\n * @private\n * @param {Array<number>} p external point\n * @param {Array<number>} a first segment point\n * @param {Array<number>} b second segment point\n * @param {Object} [options={}] Optional parameters\n * @returns {number} distance\n */\n\n\nfunction distanceToSegment(p, a, b, options) {\n  var v = [b[0] - a[0], b[1] - a[1]];\n  var w = [p[0] - a[0], p[1] - a[1]];\n  var c1 = dot(w, v);\n\n  if (c1 <= 0) {\n    return calcDistance(p, a, {\n      method: options.method,\n      units: \"degrees\"\n    });\n  }\n\n  var c2 = dot(v, v);\n\n  if (c2 <= c1) {\n    return calcDistance(p, b, {\n      method: options.method,\n      units: \"degrees\"\n    });\n  }\n\n  var b2 = c1 / c2;\n  var Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];\n  return calcDistance(p, Pb, {\n    method: options.method,\n    units: \"degrees\"\n  });\n}\n\nfunction dot(u, v) {\n  return u[0] * v[0] + u[1] * v[1];\n}\n\nfunction calcDistance(a, b, options) {\n  return options.method === \"planar\" ? rhumb_distance_1.default(a, b, options) : distance_1.default(a, b, options);\n}\n\nexports.default = pointToLineDistance;","map":null,"metadata":{},"sourceType":"script"}