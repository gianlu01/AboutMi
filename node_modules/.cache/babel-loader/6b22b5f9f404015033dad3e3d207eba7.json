{"ast":null,"code":"/**\r\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\r\n *\r\n * @name feature\r\n * @param {Geometry} geometry input geometry\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\r\n * @param {string|number} [id] Identifier\r\n * @returns {Feature} a GeoJSON Feature\r\n * @example\r\n * var geometry = {\r\n *   \"type\": \"Point\",\r\n *   \"coordinates\": [110, 50]\r\n * };\r\n *\r\n * var feature = turf.feature(geometry);\r\n *\r\n * //=feature\r\n */\nfunction feature(geometry, properties, bbox, id) {\n  if (geometry === undefined) throw new Error('geometry is required');\n  if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n  if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n  if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n  var feat = {\n    type: 'Feature'\n  };\n  if (id) feat.id = id;\n  if (bbox) feat.bbox = bbox;\n  feat.properties = properties || {};\n  feat.geometry = geometry;\n  return feat;\n}\n/**\r\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\r\n * For GeometryCollection type use `helpers.geometryCollection`\r\n *\r\n * @name geometry\r\n * @param {string} type Geometry Type\r\n * @param {Array<number>} coordinates Coordinates\r\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\r\n * @returns {Geometry} a GeoJSON Geometry\r\n * @example\r\n * var type = 'Point';\r\n * var coordinates = [110, 50];\r\n *\r\n * var geometry = turf.geometry(type, coordinates);\r\n *\r\n * //=geometry\r\n */\n\n\nfunction geometry(type, coordinates, bbox) {\n  // Validation\n  if (!type) throw new Error('type is required');\n  if (!coordinates) throw new Error('coordinates is required');\n  if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n  if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n  var geom;\n\n  switch (type) {\n    case 'Point':\n      geom = point(coordinates).geometry;\n      break;\n\n    case 'LineString':\n      geom = lineString(coordinates).geometry;\n      break;\n\n    case 'Polygon':\n      geom = polygon(coordinates).geometry;\n      break;\n\n    case 'MultiPoint':\n      geom = multiPoint(coordinates).geometry;\n      break;\n\n    case 'MultiLineString':\n      geom = multiLineString(coordinates).geometry;\n      break;\n\n    case 'MultiPolygon':\n      geom = multiPolygon(coordinates).geometry;\n      break;\n\n    default:\n      throw new Error(type + ' is invalid');\n  }\n\n  if (bbox) geom.bbox = bbox;\n  return geom;\n}\n/**\r\n * Takes coordinates and properties (optional) and returns a new {@link Point} feature.\r\n *\r\n * @name point\r\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\r\n * @param {string|number} [id] Identifier\r\n * @returns {Feature<Point>} a Point feature\r\n * @example\r\n * var point = turf.point([-75.343, 39.984]);\r\n *\r\n * //=point\r\n */\n\n\nfunction point(coordinates, properties, bbox, id) {\n  if (!coordinates) throw new Error('No coordinates passed');\n  if (coordinates.length === undefined) throw new Error('Coordinates must be an array');\n  if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');\n  return feature({\n    type: 'Point',\n    coordinates: coordinates\n  }, properties, bbox, id);\n}\n/**\r\n * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.\r\n *\r\n * @name polygon\r\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\r\n * @param {string|number} [id] Identifier\r\n * @returns {Feature<Polygon>} a Polygon feature\r\n * @throws {Error} throw an error if a LinearRing of the polygon has too few positions\r\n * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.\r\n * @example\r\n * var polygon = turf.polygon([[\r\n *   [-2.275543, 53.464547],\r\n *   [-2.275543, 53.489271],\r\n *   [-2.215118, 53.489271],\r\n *   [-2.215118, 53.464547],\r\n *   [-2.275543, 53.464547]\r\n * ]], { name: 'poly1', population: 400});\r\n *\r\n * //=polygon\r\n */\n\n\nfunction polygon(coordinates, properties, bbox, id) {\n  if (!coordinates) throw new Error('No coordinates passed');\n\n  for (var i = 0; i < coordinates.length; i++) {\n    var ring = coordinates[i];\n\n    if (ring.length < 4) {\n      throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n    }\n\n    for (var j = 0; j < ring[ring.length - 1].length; j++) {\n      // Check if first point of Polygon contains two numbers\n      if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');\n\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error('First and last Position are not equivalent.');\n      }\n    }\n  }\n\n  return feature({\n    type: 'Polygon',\n    coordinates: coordinates\n  }, properties, bbox, id);\n}\n/**\r\n * Creates a {@link LineString} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name lineString\r\n * @param {Array<Array<number>>} coordinates an array of Positions\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\r\n * @param {string|number} [id] Identifier\r\n * @returns {Feature<LineString>} a LineString feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var linestring1 = turf.lineString([\r\n *   [-21.964416, 64.148203],\r\n *   [-21.956176, 64.141316],\r\n *   [-21.93901, 64.135924],\r\n *   [-21.927337, 64.136673]\r\n * ]);\r\n * var linestring2 = turf.lineString([\r\n *   [-21.929054, 64.127985],\r\n *   [-21.912918, 64.134726],\r\n *   [-21.916007, 64.141016],\r\n *   [-21.930084, 64.14446]\r\n * ], {name: 'line 1', distance: 145});\r\n *\r\n * //=linestring1\r\n *\r\n * //=linestring2\r\n */\n\n\nfunction lineString(coordinates, properties, bbox, id) {\n  if (!coordinates) throw new Error('No coordinates passed');\n  if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions'); // Check if first point of LineString contains two numbers\n\n  if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');\n  return feature({\n    type: 'LineString',\n    coordinates: coordinates\n  }, properties, bbox, id);\n}\n/**\r\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\r\n *\r\n * @name featureCollection\r\n * @param {Feature[]} features input features\r\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\r\n * @param {string|number} [id] Identifier\r\n * @returns {FeatureCollection} a FeatureCollection of input features\r\n * @example\r\n * var features = [\r\n *  turf.point([-75.343, 39.984], {name: 'Location A'}),\r\n *  turf.point([-75.833, 39.284], {name: 'Location B'}),\r\n *  turf.point([-75.534, 39.123], {name: 'Location C'})\r\n * ];\r\n *\r\n * var collection = turf.featureCollection(features);\r\n *\r\n * //=collection\r\n */\n\n\nfunction featureCollection(features, bbox, id) {\n  if (!features) throw new Error('No features passed');\n  if (!Array.isArray(features)) throw new Error('features must be an Array');\n  if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n  if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n  var fc = {\n    type: 'FeatureCollection'\n  };\n  if (id) fc.id = id;\n  if (bbox) fc.bbox = bbox;\n  fc.features = features;\n  return fc;\n}\n/**\r\n * Creates a {@link Feature<MultiLineString>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiLineString\r\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\r\n * @param {string|number} [id] Identifier\r\n * @returns {Feature<MultiLineString>} a MultiLineString feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\r\n *\r\n * //=multiLine\r\n */\n\n\nfunction multiLineString(coordinates, properties, bbox, id) {\n  if (!coordinates) throw new Error('No coordinates passed');\n  return feature({\n    type: 'MultiLineString',\n    coordinates: coordinates\n  }, properties, bbox, id);\n}\n/**\r\n * Creates a {@link Feature<MultiPoint>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiPoint\r\n * @param {Array<Array<number>>} coordinates an array of Positions\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\r\n * @param {string|number} [id] Identifier\r\n * @returns {Feature<MultiPoint>} a MultiPoint feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\r\n *\r\n * //=multiPt\r\n */\n\n\nfunction multiPoint(coordinates, properties, bbox, id) {\n  if (!coordinates) throw new Error('No coordinates passed');\n  return feature({\n    type: 'MultiPoint',\n    coordinates: coordinates\n  }, properties, bbox, id);\n}\n/**\r\n * Creates a {@link Feature<MultiPolygon>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiPolygon\r\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\r\n * @param {string|number} [id] Identifier\r\n * @returns {Feature<MultiPolygon>} a multipolygon feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\r\n *\r\n * //=multiPoly\r\n *\r\n */\n\n\nfunction multiPolygon(coordinates, properties, bbox, id) {\n  if (!coordinates) throw new Error('No coordinates passed');\n  return feature({\n    type: 'MultiPolygon',\n    coordinates: coordinates\n  }, properties, bbox, id);\n}\n/**\r\n * Creates a {@link Feature<GeometryCollection>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name geometryCollection\r\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\r\n * @param {string|number} [id] Identifier\r\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\r\n * @example\r\n * var pt = {\r\n *     \"type\": \"Point\",\r\n *       \"coordinates\": [100, 0]\r\n *     };\r\n * var line = {\r\n *     \"type\": \"LineString\",\r\n *     \"coordinates\": [ [101, 0], [102, 1] ]\r\n *   };\r\n * var collection = turf.geometryCollection([pt, line]);\r\n *\r\n * //=collection\r\n */\n\n\nfunction geometryCollection(geometries, properties, bbox, id) {\n  if (!geometries) throw new Error('geometries is required');\n  if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n  return feature({\n    type: 'GeometryCollection',\n    geometries: geometries\n  }, properties, bbox, id);\n} // https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth\n\n\nvar factors = {\n  miles: 3960,\n  nauticalmiles: 3441.145,\n  degrees: 57.2957795,\n  radians: 1,\n  inches: 250905600,\n  yards: 6969600,\n  meters: 6373000,\n  metres: 6373000,\n  centimeters: 6.373e+8,\n  centimetres: 6.373e+8,\n  kilometers: 6373,\n  kilometres: 6373,\n  feet: 20908792.65\n};\nvar areaFactors = {\n  kilometers: 0.000001,\n  kilometres: 0.000001,\n  meters: 1,\n  metres: 1,\n  centimetres: 10000,\n  millimeter: 1000000,\n  acres: 0.000247105,\n  miles: 3.86e-7,\n  yards: 1.195990046,\n  feet: 10.763910417,\n  inches: 1550.003100006\n};\n/**\r\n * Round number to precision\r\n *\r\n * @param {number} num Number\r\n * @param {number} [precision=0] Precision\r\n * @returns {number} rounded number\r\n * @example\r\n * turf.round(120.4321)\r\n * //=120\r\n *\r\n * turf.round(120.4321, 2)\r\n * //=120.43\r\n */\n\nfunction round(num, precision) {\n  if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n  if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n  var multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @name radiansToDistance\r\n * @param {number} radians in radians across the sphere\r\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\r\n * @returns {number} distance\r\n */\n\n\nfunction radiansToDistance(radians, units) {\n  if (radians === undefined || radians === null) throw new Error('radians is required');\n  var factor = factors[units || 'kilometers'];\n  if (!factor) throw new Error('units is invalid');\n  return radians * factor;\n}\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @name distanceToRadians\r\n * @param {number} distance in real units\r\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\r\n * @returns {number} radians\r\n */\n\n\nfunction distanceToRadians(distance, units) {\n  if (distance === undefined || distance === null) throw new Error('distance is required');\n  var factor = factors[units || 'kilometers'];\n  if (!factor) throw new Error('units is invalid');\n  return distance / factor;\n}\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\r\n *\r\n * @name distanceToDegrees\r\n * @param {number} distance in real units\r\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\r\n * @returns {number} degrees\r\n */\n\n\nfunction distanceToDegrees(distance, units) {\n  return radians2degrees(distanceToRadians(distance, units));\n}\n/**\r\n * Converts any bearing angle from the north line direction (positive clockwise)\r\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\r\n *\r\n * @name bearingToAngle\r\n * @param {number} bearing angle, between -180 and +180 degrees\r\n * @returns {number} angle between 0 and 360 degrees\r\n */\n\n\nfunction bearingToAngle(bearing) {\n  if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n  var angle = bearing % 360;\n  if (angle < 0) angle += 360;\n  return angle;\n}\n/**\r\n * Converts an angle in radians to degrees\r\n *\r\n * @name radians2degrees\r\n * @param {number} radians angle in radians\r\n * @returns {number} degrees between 0 and 360 degrees\r\n */\n\n\nfunction radians2degrees(radians) {\n  if (radians === null || radians === undefined) throw new Error('radians is required');\n  var degrees = radians % (2 * Math.PI);\n  return degrees * 180 / Math.PI;\n}\n/**\r\n * Converts an angle in degrees to radians\r\n *\r\n * @name degrees2radians\r\n * @param {number} degrees angle between 0 and 360 degrees\r\n * @returns {number} angle in radians\r\n */\n\n\nfunction degrees2radians(degrees) {\n  if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n  var radians = degrees % 360;\n  return radians * Math.PI / 180;\n}\n/**\r\n * Converts a distance to the requested unit.\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @param {number} distance to be converted\r\n * @param {string} originalUnit of the distance\r\n * @param {string} [finalUnit=kilometers] returned unit\r\n * @returns {number} the converted distance\r\n */\n\n\nfunction convertDistance(distance, originalUnit, finalUnit) {\n  if (distance === null || distance === undefined) throw new Error('distance is required');\n  if (!(distance >= 0)) throw new Error('distance must be a positive number');\n  var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');\n  return convertedDistance;\n}\n/**\r\n * Converts a area to the requested unit.\r\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch\r\n * @param {number} area to be converted\r\n * @param {string} [originalUnit=meters] of the distance\r\n * @param {string} [finalUnit=kilometers] returned unit\r\n * @returns {number} the converted distance\r\n */\n\n\nfunction convertArea(area, originalUnit, finalUnit) {\n  if (area === null || area === undefined) throw new Error('area is required');\n  if (!(area >= 0)) throw new Error('area must be a positive number');\n  var startFactor = areaFactors[originalUnit || 'meters'];\n  if (!startFactor) throw new Error('invalid original units');\n  var finalFactor = areaFactors[finalUnit || 'kilometers'];\n  if (!finalFactor) throw new Error('invalid final units');\n  return area / startFactor * finalFactor;\n}\n/**\r\n * isNumber\r\n *\r\n * @param {*} num Number to validate\r\n * @returns {boolean} true/false\r\n * @example\r\n * turf.isNumber(123)\r\n * //=true\r\n * turf.isNumber('foo')\r\n * //=false\r\n */\n\n\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\nmodule.exports = {\n  feature: feature,\n  geometry: geometry,\n  featureCollection: featureCollection,\n  geometryCollection: geometryCollection,\n  point: point,\n  multiPoint: multiPoint,\n  lineString: lineString,\n  multiLineString: multiLineString,\n  polygon: polygon,\n  multiPolygon: multiPolygon,\n  radiansToDistance: radiansToDistance,\n  distanceToRadians: distanceToRadians,\n  distanceToDegrees: distanceToDegrees,\n  radians2degrees: radians2degrees,\n  degrees2radians: degrees2radians,\n  bearingToAngle: bearingToAngle,\n  convertDistance: convertDistance,\n  convertArea: convertArea,\n  round: round,\n  isNumber: isNumber\n};","map":null,"metadata":{},"sourceType":"script"}