{"ast":null,"code":"/**\r\n * @module ol/structs/LRUCache\r\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { assert } from '../asserts.js';\nimport EventTarget from '../events/Target.js';\nimport EventType from '../events/EventType.js';\n/**\r\n * @typedef {Object} Entry\r\n * @property {string} key_\r\n * @property {Object} newer\r\n * @property {Object} older\r\n * @property {*} value_\r\n */\n\n/**\r\n * @classdesc\r\n * Implements a Least-Recently-Used cache where the keys do not conflict with\r\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\r\n * items from the cache is the responsibility of the user.\r\n *\r\n * @fires import(\"../events/Event.js\").default\r\n * @template T\r\n */\n\nvar LRUCache =\n/** @class */\nfunction (_super) {\n  __extends(LRUCache, _super);\n  /**\r\n   * @param {number=} opt_highWaterMark High water mark.\r\n   */\n\n\n  function LRUCache(opt_highWaterMark) {\n    var _this = _super.call(this) || this;\n    /**\r\n     * @type {number}\r\n     */\n\n\n    _this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n\n    _this.count_ = 0;\n    /**\r\n     * @private\r\n     * @type {!Object<string, Entry>}\r\n     */\n\n    _this.entries_ = {};\n    /**\r\n     * @private\r\n     * @type {?Entry}\r\n     */\n\n    _this.oldest_ = null;\n    /**\r\n     * @private\r\n     * @type {?Entry}\r\n     */\n\n    _this.newest_ = null;\n    return _this;\n  }\n  /**\r\n   * @return {boolean} Can expire cache.\r\n   */\n\n\n  LRUCache.prototype.canExpireCache = function () {\n    return this.getCount() > this.highWaterMark;\n  };\n  /**\r\n   * FIXME empty description for jsdoc\r\n   */\n\n\n  LRUCache.prototype.clear = function () {\n    this.count_ = 0;\n    this.entries_ = {};\n    this.oldest_ = null;\n    this.newest_ = null;\n    this.dispatchEvent(EventType.CLEAR);\n  };\n  /**\r\n   * @param {string} key Key.\r\n   * @return {boolean} Contains key.\r\n   */\n\n\n  LRUCache.prototype.containsKey = function (key) {\n    return this.entries_.hasOwnProperty(key);\n  };\n  /**\r\n   * @param {function(T, string, LRUCache<T>): ?} f The function\r\n   *     to call for every entry from the oldest to the newer. This function takes\r\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\r\n   *     The return value is ignored.\r\n   */\n\n\n  LRUCache.prototype.forEach = function (f) {\n    var entry = this.oldest_;\n\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  };\n  /**\r\n   * @param {string} key Key.\r\n   * @param {*=} opt_options Options (reserverd for subclasses).\r\n   * @return {T} Value.\r\n   */\n\n\n  LRUCache.prototype.get = function (key, opt_options) {\n    var entry = this.entries_[key];\n    assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n\n    if (entry === this.newest_) {\n      return entry.value_;\n    } else if (entry === this.oldest_) {\n      this.oldest_ =\n      /** @type {Entry} */\n      this.oldest_.newer;\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  };\n  /**\r\n   * Remove an entry from the cache.\r\n   * @param {string} key The entry key.\r\n   * @return {T} The removed entry.\r\n   */\n\n\n  LRUCache.prototype.remove = function (key) {\n    var entry = this.entries_[key];\n    assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n\n    if (entry === this.newest_) {\n      this.newest_ =\n      /** @type {Entry} */\n      entry.older;\n\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ =\n      /** @type {Entry} */\n      entry.newer;\n\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  };\n  /**\r\n   * @return {number} Count.\r\n   */\n\n\n  LRUCache.prototype.getCount = function () {\n    return this.count_;\n  };\n  /**\r\n   * @return {Array<string>} Keys.\r\n   */\n\n\n  LRUCache.prototype.getKeys = function () {\n    var keys = new Array(this.count_);\n    var i = 0;\n    var entry;\n\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n\n    return keys;\n  };\n  /**\r\n   * @return {Array<T>} Values.\r\n   */\n\n\n  LRUCache.prototype.getValues = function () {\n    var values = new Array(this.count_);\n    var i = 0;\n    var entry;\n\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n\n    return values;\n  };\n  /**\r\n   * @return {T} Last value.\r\n   */\n\n\n  LRUCache.prototype.peekLast = function () {\n    return this.oldest_.value_;\n  };\n  /**\r\n   * @return {string} Last key.\r\n   */\n\n\n  LRUCache.prototype.peekLastKey = function () {\n    return this.oldest_.key_;\n  };\n  /**\r\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\r\n   * @return {string} The newest key.\r\n   */\n\n\n  LRUCache.prototype.peekFirstKey = function () {\n    return this.newest_.key_;\n  };\n  /**\r\n   * @return {T} value Value.\r\n   */\n\n\n  LRUCache.prototype.pop = function () {\n    var entry = this.oldest_;\n    delete this.entries_[entry.key_];\n\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n\n    this.oldest_ =\n    /** @type {Entry} */\n    entry.newer;\n\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n\n    --this.count_;\n    return entry.value_;\n  };\n  /**\r\n   * @param {string} key Key.\r\n   * @param {T} value Value.\r\n   */\n\n\n  LRUCache.prototype.replace = function (key, value) {\n    this.get(key); // update `newest_`\n\n    this.entries_[key].value_ = value;\n  };\n  /**\r\n   * @param {string} key Key.\r\n   * @param {T} value Value.\r\n   */\n\n\n  LRUCache.prototype.set = function (key, value) {\n    assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already\n\n    var entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value\n    };\n\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  };\n  /**\r\n   * Set a maximum number of entries for the cache.\r\n   * @param {number} size Cache size.\r\n   * @api\r\n   */\n\n\n  LRUCache.prototype.setSize = function (size) {\n    this.highWaterMark = size;\n  };\n\n  return LRUCache;\n}(EventTarget);\n\nexport default LRUCache;","map":null,"metadata":{},"sourceType":"module"}