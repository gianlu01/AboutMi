{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\r\n * @module ol/layer/Graticule\r\n */\n\n\nimport VectorLayer from './Vector.js';\nimport { assign } from '../obj.js';\nimport { degreesToStringHDMS } from '../coordinate.js';\nimport Text from '../style/Text.js';\nimport Fill from '../style/Fill.js';\nimport Stroke from '../style/Stroke.js';\nimport LineString from '../geom/LineString.js';\nimport VectorSource from '../source/Vector.js';\nimport { equivalent as equivalentProjection, get as getProjection, getTransform, transformExtent } from '../proj.js';\nimport { getCenter, intersects, equals, getIntersection, isEmpty } from '../extent.js';\nimport { clamp } from '../math.js';\nimport Style from '../style/Style.js';\nimport Feature from '../Feature.js';\nimport { bbox } from '../loadingstrategy.js';\nimport { meridian, parallel } from '../geom/flat/geodesic.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport Point from '../geom/Point.js';\nimport Collection from '../Collection.js';\n/**\r\n * @type {Stroke}\r\n * @private\r\n * @const\r\n */\n\nvar DEFAULT_STROKE_STYLE = new Stroke({\n  color: 'rgba(0,0,0,0.2)'\n});\n/**\r\n * @type {Array<number>}\r\n * @private\r\n */\n\nvar INTERVALS = [90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001];\n/**\r\n * @typedef {Object} GraticuleLabelDataType\r\n * @property {Point} geom\r\n * @property {string} text\r\n */\n\n/**\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [maxLines=100] The maximum number of meridians and\r\n * parallels from the center of the map. The default value of 100 means that at\r\n * most 200 meridians and 200 parallels will be displayed. The default value is\r\n * appropriate for conformal projections like Spherical Mercator. If you\r\n * increase the value, more lines will be drawn and the drawing performance will\r\n * decrease.\r\n * @property {Stroke} [strokeStyle='rgba(0,0,0,0.2)'] The\r\n * stroke style to use for drawing the graticule. If not provided, a not fully\r\n * opaque black will be used.\r\n * @property {number} [targetSize=100] The target size of the graticule cells,\r\n * in pixels.\r\n * @property {boolean} [showLabels=false] Render a label with the respective\r\n * latitude/longitude for each graticule line.\r\n * @property {function(number):string} [lonLabelFormatter] Label formatter for\r\n * longitudes. This function is called with the longitude as argument, and\r\n * should return a formatted string representing the longitude. By default,\r\n * labels are formatted as degrees, minutes, seconds and hemisphere.\r\n * @property {function(number):string} [latLabelFormatter] Label formatter for\r\n * latitudes. This function is called with the latitude as argument, and\r\n * should return a formatted string representing the latitude. By default,\r\n * labels are formatted as degrees, minutes, seconds and hemisphere.\r\n * @property {number} [lonLabelPosition=0] Longitude label position in fractions\r\n * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the\r\n * top.\r\n * @property {number} [latLabelPosition=1] Latitude label position in fractions\r\n * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the\r\n * right.\r\n * @property {Text} [lonLabelStyle] Longitude label text\r\n * style. If not provided, the following style will be used:\r\n * ```js\r\n * new Text({\r\n *   font: '12px Calibri,sans-serif',\r\n *   textBaseline: 'bottom',\r\n *   fill: new Fill({\r\n *     color: 'rgba(0,0,0,1)'\r\n *   }),\r\n *   stroke: new Stroke({\r\n *     color: 'rgba(255,255,255,1)',\r\n *     width: 3\r\n *   })\r\n * });\r\n * ```\r\n * Note that the default's `textBaseline` configuration will not work well for\r\n * `lonLabelPosition` configurations that position labels close to the top of\r\n * the viewport.\r\n * @property {Text} [latLabelStyle] Latitude label text style.\r\n * If not provided, the following style will be used:\r\n * ```js\r\n * new Text({\r\n *   font: '12px Calibri,sans-serif',\r\n *   textAlign: 'end',\r\n *   fill: new Fill({\r\n *     color: 'rgba(0,0,0,1)'\r\n *   }),\r\n *   stroke: Stroke({\r\n *     color: 'rgba(255,255,255,1)',\r\n *     width: 3\r\n *   })\r\n * });\r\n * ```\r\n * Note that the default's `textAlign` configuration will not work well for\r\n * `latLabelPosition` configurations that position labels close to the left of\r\n * the viewport.\r\n * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001]]\r\n * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:\r\n * ```js\r\n * [30, 10]\r\n * ```\r\n * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.\r\n */\n\n/**\r\n * @classdesc\r\n * Layer that renders a grid for a coordinate system.\r\n *\r\n * @fires import(\"../render/Event.js\").RenderEvent\r\n * @api\r\n */\n\nvar Graticule =\n/** @class */\nfunction (_super) {\n  __extends(Graticule, _super);\n  /**\r\n   * @param {Options=} opt_options Options.\r\n   */\n\n\n  function Graticule(opt_options) {\n    var _this = this;\n\n    var options = opt_options ? opt_options : {};\n    var baseOptions = assign({\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n      renderBuffer: 0\n    }, options);\n    delete baseOptions.maxLines;\n    delete baseOptions.strokeStyle;\n    delete baseOptions.targetSize;\n    delete baseOptions.showLabels;\n    delete baseOptions.lonLabelFormatter;\n    delete baseOptions.latLabelFormatter;\n    delete baseOptions.lonLabelPosition;\n    delete baseOptions.latLabelPosition;\n    delete baseOptions.lonLabelStyle;\n    delete baseOptions.latLabelStyle;\n    delete baseOptions.intervals;\n    _this = _super.call(this, baseOptions) || this;\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     */\n\n    _this.projection_ = null;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    _this.maxLat_ = Infinity;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    _this.maxLon_ = Infinity;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    _this.minLat_ = -Infinity;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    _this.minLon_ = -Infinity;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    _this.maxLatP_ = Infinity;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    _this.maxLonP_ = Infinity;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    _this.minLatP_ = -Infinity;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    _this.minLonP_ = -Infinity;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    _this.targetSize_ = options.targetSize !== undefined ? options.targetSize : 100;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    _this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;\n    /**\r\n     * @type {Array<LineString>}\r\n     * @private\r\n     */\n\n    _this.meridians_ = [];\n    /**\r\n     * @type {Array<LineString>}\r\n     * @private\r\n     */\n\n    _this.parallels_ = [];\n    /**\r\n     * @type {Stroke}\r\n     * @private\r\n     */\n\n    _this.strokeStyle_ = options.strokeStyle !== undefined ? options.strokeStyle : DEFAULT_STROKE_STYLE;\n    /**\r\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\r\n     * @private\r\n     */\n\n    _this.fromLonLatTransform_ = undefined;\n    /**\r\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\r\n     * @private\r\n     */\n\n    _this.toLonLatTransform_ = undefined;\n    /**\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @private\r\n     */\n\n    _this.projectionCenterLonLat_ = null;\n    /**\r\n     * @type {Array<GraticuleLabelDataType>}\r\n     * @private\r\n     */\n\n    _this.meridiansLabels_ = null;\n    /**\r\n     * @type {Array<GraticuleLabelDataType>}\r\n     * @private\r\n     */\n\n    _this.parallelsLabels_ = null;\n\n    if (options.showLabels) {\n      /**\r\n       * @type {null|function(number):string}\r\n       * @private\r\n       */\n      _this.lonLabelFormatter_ = options.lonLabelFormatter == undefined ? degreesToStringHDMS.bind(_this, 'EW') : options.lonLabelFormatter;\n      /**\r\n       * @type {function(number):string}\r\n       * @private\r\n       */\n\n      _this.latLabelFormatter_ = options.latLabelFormatter == undefined ? degreesToStringHDMS.bind(_this, 'NS') : options.latLabelFormatter;\n      /**\r\n       * Longitude label position in fractions (0..1) of view extent. 0 means\r\n       * bottom, 1 means top.\r\n       * @type {number}\r\n       * @private\r\n       */\n\n      _this.lonLabelPosition_ = options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;\n      /**\r\n       * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1\r\n       * means right.\r\n       * @type {number}\r\n       * @private\r\n       */\n\n      _this.latLabelPosition_ = options.latLabelPosition == undefined ? 1 : options.latLabelPosition;\n      /**\r\n       * @type {Style}\r\n       * @private\r\n       */\n\n      _this.lonLabelStyleBase_ = new Style({\n        text: options.lonLabelStyle !== undefined ? options.lonLabelStyle.clone() : new Text({\n          font: '12px Calibri,sans-serif',\n          textBaseline: 'bottom',\n          fill: new Fill({\n            color: 'rgba(0,0,0,1)'\n          }),\n          stroke: new Stroke({\n            color: 'rgba(255,255,255,1)',\n            width: 3\n          })\n        })\n      });\n      /**\r\n       * @private\r\n       * @param {import(\"../Feature\").default} feature Feature\r\n       * @return {Style} style\r\n       */\n\n      _this.lonLabelStyle_ = function (feature) {\n        var label = feature.get('graticule_label');\n        this.lonLabelStyleBase_.getText().setText(label);\n        return this.lonLabelStyleBase_;\n      }.bind(_this);\n      /**\r\n       * @type {Style}\r\n       * @private\r\n       */\n\n\n      _this.latLabelStyleBase_ = new Style({\n        text: options.latLabelStyle !== undefined ? options.latLabelStyle.clone() : new Text({\n          font: '12px Calibri,sans-serif',\n          textAlign: 'right',\n          fill: new Fill({\n            color: 'rgba(0,0,0,1)'\n          }),\n          stroke: new Stroke({\n            color: 'rgba(255,255,255,1)',\n            width: 3\n          })\n        })\n      });\n      /**\r\n       * @private\r\n       * @param {import(\"../Feature\").default} feature Feature\r\n       * @return {Style} style\r\n       */\n\n      _this.latLabelStyle_ = function (feature) {\n        var label = feature.get('graticule_label');\n        this.latLabelStyleBase_.getText().setText(label);\n        return this.latLabelStyleBase_;\n      }.bind(_this);\n\n      _this.meridiansLabels_ = [];\n      _this.parallelsLabels_ = [];\n    }\n    /**\r\n     * @type {Array<number>}\r\n     * @private\r\n     */\n\n\n    _this.intervals_ = options.intervals !== undefined ? options.intervals : INTERVALS; // use a source with a custom loader for lines & text\n\n    _this.setSource(new VectorSource({\n      loader: _this.loaderFunction.bind(_this),\n      strategy: bbox,\n      features: new Collection(),\n      overlaps: false,\n      useSpatialIndex: false,\n      wrapX: options.wrapX\n    }));\n    /**\r\n     * feature pool to use when updating graticule\r\n     * @type {Array<Feature>}\r\n     * @private\r\n     */\n\n\n    _this.featurePool_ = [];\n    /**\r\n     * @type {Style}\r\n     * @private\r\n     */\n\n    _this.lineStyle_ = new Style({\n      stroke: _this.strokeStyle_\n    });\n    /**\r\n     * @type {?import(\"../extent.js\").Extent}\r\n     */\n\n    _this.renderedExtent_ = null;\n\n    _this.setRenderOrder(null);\n\n    _this.tmpExtent_ = null;\n    return _this;\n  }\n  /**\r\n   * Update geometries in the source based on current view\r\n   * @param {import(\"../extent\").Extent} extent Extent\r\n   * @param {number} resolution Resolution\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection\r\n   */\n\n\n  Graticule.prototype.loaderFunction = function (extent, resolution, projection) {\n    var source = this.getSource(); // only consider the intersection between our own extent & the requested one\n\n    var layerExtent = this.getExtent() || [-Infinity, -Infinity, Infinity, Infinity];\n    var renderExtent = getIntersection(layerExtent, extent, this.tmpExtent_); // we should not keep track of loaded extents\n\n    setTimeout(function () {\n      source.removeLoadedExtent(extent);\n    }, 0);\n\n    if (this.renderedExtent_ && equals(this.renderedExtent_, renderExtent)) {\n      return;\n    }\n\n    this.renderedExtent_ = renderExtent; // bail out if nothing to render\n\n    if (isEmpty(renderExtent)) {\n      return;\n    } // update projection info\n\n\n    var center = getCenter(renderExtent);\n    var squaredTolerance = resolution * resolution / 4;\n    var updateProjectionInfo = !this.projection_ || !equivalentProjection(this.projection_, projection);\n\n    if (updateProjectionInfo) {\n      this.updateProjectionInfo_(projection);\n    }\n\n    this.createGraticule_(renderExtent, center, resolution, squaredTolerance); // first make sure we have enough features in the pool\n\n    var featureCount = this.meridians_.length + this.parallels_.length;\n\n    if (this.meridiansLabels_) {\n      featureCount += this.meridiansLabels_.length;\n    }\n\n    if (this.parallelsLabels_) {\n      featureCount += this.parallelsLabels_.length;\n    }\n\n    var feature;\n\n    while (featureCount > this.featurePool_.length) {\n      feature = new Feature();\n      this.featurePool_.push(feature);\n    }\n\n    var featuresColl = source.getFeaturesCollection();\n    featuresColl.clear();\n    var poolIndex = 0; // add features for the lines & labels\n\n    var i, l;\n\n    for (i = 0, l = this.meridians_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.meridians_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n\n    for (i = 0, l = this.parallels_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.parallels_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n\n    var labelData;\n\n    if (this.meridiansLabels_) {\n      for (i = 0, l = this.meridiansLabels_.length; i < l; ++i) {\n        labelData = this.meridiansLabels_[i];\n        feature = this.featurePool_[poolIndex++];\n        feature.setGeometry(labelData.geom);\n        feature.setStyle(this.lonLabelStyle_);\n        feature.set('graticule_label', labelData.text);\n        featuresColl.push(feature);\n      }\n    }\n\n    if (this.parallelsLabels_) {\n      for (i = 0, l = this.parallelsLabels_.length; i < l; ++i) {\n        labelData = this.parallelsLabels_[i];\n        feature = this.featurePool_[poolIndex++];\n        feature.setGeometry(labelData.geom);\n        feature.setStyle(this.latLabelStyle_);\n        feature.set('graticule_label', labelData.text);\n        featuresColl.push(feature);\n      }\n    }\n  };\n  /**\r\n   * @param {number} lon Longitude.\r\n   * @param {number} minLat Minimal latitude.\r\n   * @param {number} maxLat Maximal latitude.\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} index Index.\r\n   * @return {number} Index.\r\n   * @private\r\n   */\n\n\n  Graticule.prototype.addMeridian_ = function (lon, minLat, maxLat, squaredTolerance, extent, index) {\n    var lineString = this.getMeridian_(lon, minLat, maxLat, squaredTolerance, index);\n\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.meridiansLabels_) {\n        var textPoint = this.getMeridianPoint_(lineString, extent, index);\n        this.meridiansLabels_[index] = {\n          geom: textPoint,\n          text: this.lonLabelFormatter_(lon)\n        };\n      }\n\n      this.meridians_[index++] = lineString;\n    }\n\n    return index;\n  };\n  /**\r\n   * @param {number} lat Latitude.\r\n   * @param {number} minLon Minimal longitude.\r\n   * @param {number} maxLon Maximal longitude.\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} index Index.\r\n   * @return {number} Index.\r\n   * @private\r\n   */\n\n\n  Graticule.prototype.addParallel_ = function (lat, minLon, maxLon, squaredTolerance, extent, index) {\n    var lineString = this.getParallel_(lat, minLon, maxLon, squaredTolerance, index);\n\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.parallelsLabels_) {\n        var textPoint = this.getParallelPoint_(lineString, extent, index);\n        this.parallelsLabels_[index] = {\n          geom: textPoint,\n          text: this.latLabelFormatter_(lat)\n        };\n      }\n\n      this.parallels_[index++] = lineString;\n    }\n\n    return index;\n  };\n  /**\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @private\r\n   */\n\n\n  Graticule.prototype.createGraticule_ = function (extent, center, resolution, squaredTolerance) {\n    var interval = this.getInterval_(resolution);\n\n    if (interval == -1) {\n      this.meridians_.length = 0;\n      this.parallels_.length = 0;\n\n      if (this.meridiansLabels_) {\n        this.meridiansLabels_.length = 0;\n      }\n\n      if (this.parallelsLabels_) {\n        this.parallelsLabels_.length = 0;\n      }\n\n      return;\n    }\n\n    var centerLonLat = this.toLonLatTransform_(center);\n    var centerLon = centerLonLat[0];\n    var centerLat = centerLonLat[1];\n    var maxLines = this.maxLines_;\n    var cnt, idx, lat, lon;\n    var validExtent = [Math.max(extent[0], this.minLonP_), Math.max(extent[1], this.minLatP_), Math.min(extent[2], this.maxLonP_), Math.min(extent[3], this.maxLatP_)];\n    validExtent = transformExtent(validExtent, this.projection_, 'EPSG:4326');\n    var maxLat = validExtent[3];\n    var maxLon = validExtent[2];\n    var minLat = validExtent[1];\n    var minLon = validExtent[0]; // Create meridians\n\n    centerLon = Math.floor(centerLon / interval) * interval;\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n    idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);\n    cnt = 0;\n\n    while (lon != this.minLon_ && cnt++ < maxLines) {\n      lon = Math.max(lon - interval, this.minLon_);\n      idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n    }\n\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n    cnt = 0;\n\n    while (lon != this.maxLon_ && cnt++ < maxLines) {\n      lon = Math.min(lon + interval, this.maxLon_);\n      idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n    }\n\n    this.meridians_.length = idx;\n\n    if (this.meridiansLabels_) {\n      this.meridiansLabels_.length = idx;\n    } // Create parallels\n\n\n    centerLat = Math.floor(centerLat / interval) * interval;\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n    idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);\n    cnt = 0;\n\n    while (lat != this.minLat_ && cnt++ < maxLines) {\n      lat = Math.max(lat - interval, this.minLat_);\n      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n    }\n\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n    cnt = 0;\n\n    while (lat != this.maxLat_ && cnt++ < maxLines) {\n      lat = Math.min(lat + interval, this.maxLat_);\n      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n    }\n\n    this.parallels_.length = idx;\n\n    if (this.parallelsLabels_) {\n      this.parallelsLabels_.length = idx;\n    }\n  };\n  /**\r\n   * @param {number} resolution Resolution.\r\n   * @return {number} The interval in degrees.\r\n   * @private\r\n   */\n\n\n  Graticule.prototype.getInterval_ = function (resolution) {\n    var centerLon = this.projectionCenterLonLat_[0];\n    var centerLat = this.projectionCenterLonLat_[1];\n    var interval = -1;\n    var target = Math.pow(this.targetSize_ * resolution, 2);\n    /** @type {Array<number>} **/\n\n    var p1 = [];\n    /** @type {Array<number>} **/\n\n    var p2 = [];\n\n    for (var i = 0, ii = this.intervals_.length; i < ii; ++i) {\n      var delta = this.intervals_[i] / 2;\n      p1[0] = centerLon - delta;\n      p1[1] = centerLat - delta;\n      p2[0] = centerLon + delta;\n      p2[1] = centerLat + delta;\n      this.fromLonLatTransform_(p1, p1);\n      this.fromLonLatTransform_(p2, p2);\n      var dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);\n\n      if (dist <= target) {\n        break;\n      }\n\n      interval = this.intervals_[i];\n    }\n\n    return interval;\n  };\n  /**\r\n   * @param {number} lon Longitude.\r\n   * @param {number} minLat Minimal latitude.\r\n   * @param {number} maxLat Maximal latitude.\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {LineString} The meridian line string.\r\n   * @param {number} index Index.\r\n   * @private\r\n   */\n\n\n  Graticule.prototype.getMeridian_ = function (lon, minLat, maxLat, squaredTolerance, index) {\n    var flatCoordinates = meridian(lon, minLat, maxLat, this.projection_, squaredTolerance);\n    var lineString = this.meridians_[index];\n\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, GeometryLayout.XY);\n      this.meridians_[index] = lineString;\n    } else {\n      lineString.setFlatCoordinates(GeometryLayout.XY, flatCoordinates);\n      lineString.changed();\n    }\n\n    return lineString;\n  };\n  /**\r\n   * @param {LineString} lineString Meridian\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} index Index.\r\n   * @return {Point} Meridian point.\r\n   * @private\r\n   */\n\n\n  Graticule.prototype.getMeridianPoint_ = function (lineString, extent, index) {\n    var flatCoordinates = lineString.getFlatCoordinates();\n    var clampedBottom = Math.max(extent[1], flatCoordinates[1]);\n    var clampedTop = Math.min(extent[3], flatCoordinates[flatCoordinates.length - 1]);\n    var lat = clamp(extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_, clampedBottom, clampedTop);\n    var coordinate = [flatCoordinates[0], lat];\n    var point;\n\n    if (index in this.meridiansLabels_) {\n      point = this.meridiansLabels_[index].geom;\n      point.setCoordinates(coordinate);\n    } else {\n      point = new Point(coordinate);\n    }\n\n    return point;\n  };\n  /**\r\n   * Get the list of meridians.  Meridians are lines of equal longitude.\r\n   * @return {Array<LineString>} The meridians.\r\n   * @api\r\n   */\n\n\n  Graticule.prototype.getMeridians = function () {\n    return this.meridians_;\n  };\n  /**\r\n   * @param {number} lat Latitude.\r\n   * @param {number} minLon Minimal longitude.\r\n   * @param {number} maxLon Maximal longitude.\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {LineString} The parallel line string.\r\n   * @param {number} index Index.\r\n   * @private\r\n   */\n\n\n  Graticule.prototype.getParallel_ = function (lat, minLon, maxLon, squaredTolerance, index) {\n    var flatCoordinates = parallel(lat, minLon, maxLon, this.projection_, squaredTolerance);\n    var lineString = this.parallels_[index];\n\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, GeometryLayout.XY);\n    } else {\n      lineString.setFlatCoordinates(GeometryLayout.XY, flatCoordinates);\n      lineString.changed();\n    }\n\n    return lineString;\n  };\n  /**\r\n   * @param {LineString} lineString Parallels.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} index Index.\r\n   * @return {Point} Parallel point.\r\n   * @private\r\n   */\n\n\n  Graticule.prototype.getParallelPoint_ = function (lineString, extent, index) {\n    var flatCoordinates = lineString.getFlatCoordinates();\n    var clampedLeft = Math.max(extent[0], flatCoordinates[0]);\n    var clampedRight = Math.min(extent[2], flatCoordinates[flatCoordinates.length - 2]);\n    var lon = clamp(extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_, clampedLeft, clampedRight);\n    var coordinate = [lon, flatCoordinates[1]];\n    var point;\n\n    if (index in this.parallelsLabels_) {\n      point = this.parallelsLabels_[index].geom;\n      point.setCoordinates(coordinate);\n    } else {\n      point = new Point(coordinate);\n    }\n\n    return point;\n  };\n  /**\r\n   * Get the list of parallels.  Parallels are lines of equal latitude.\r\n   * @return {Array<LineString>} The parallels.\r\n   * @api\r\n   */\n\n\n  Graticule.prototype.getParallels = function () {\n    return this.parallels_;\n  };\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @private\r\n   */\n\n\n  Graticule.prototype.updateProjectionInfo_ = function (projection) {\n    var epsg4326Projection = getProjection('EPSG:4326');\n    var worldExtent = projection.getWorldExtent();\n    var worldExtentP = transformExtent(worldExtent, epsg4326Projection, projection);\n    this.maxLat_ = worldExtent[3];\n    this.maxLon_ = worldExtent[2];\n    this.minLat_ = worldExtent[1];\n    this.minLon_ = worldExtent[0];\n    this.maxLatP_ = worldExtentP[3];\n    this.maxLonP_ = worldExtentP[2];\n    this.minLatP_ = worldExtentP[1];\n    this.minLonP_ = worldExtentP[0];\n    this.fromLonLatTransform_ = getTransform(epsg4326Projection, projection);\n    this.toLonLatTransform_ = getTransform(projection, epsg4326Projection);\n    this.projectionCenterLonLat_ = this.toLonLatTransform_(getCenter(projection.getExtent()));\n    this.projection_ = projection;\n  };\n\n  return Graticule;\n}(VectorLayer);\n\nexport default Graticule;","map":null,"metadata":{},"sourceType":"module"}