{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bearing_1 = require(\"@turf/bearing\");\n\nvar distance_1 = require(\"@turf/distance\");\n\nvar destination_1 = require(\"@turf/destination\");\n\nvar line_intersect_1 = require(\"@turf/line-intersect\");\n\nvar meta_1 = require(\"@turf/meta\");\n\nvar helpers_1 = require(\"@turf/helpers\");\n\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name nearestPointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\n\n\nfunction nearestPointOnLine(lines, pt, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var closestPt = helpers_1.point([Infinity, Infinity], {\n    dist: Infinity\n  });\n  var length = 0.0;\n  meta_1.flattenEach(lines, function (line) {\n    var coords = invariant_1.getCoords(line);\n\n    for (var i = 0; i < coords.length - 1; i++) {\n      //start\n      var start = helpers_1.point(coords[i]);\n      start.properties.dist = distance_1.default(pt, start, options); //stop\n\n      var stop_1 = helpers_1.point(coords[i + 1]);\n      stop_1.properties.dist = distance_1.default(pt, stop_1, options); // sectionLength\n\n      var sectionLength = distance_1.default(start, stop_1, options); //perpendicular\n\n      var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);\n      var direction = bearing_1.default(start, stop_1);\n      var perpendicularPt1 = destination_1.default(pt, heightDistance, direction + 90, options);\n      var perpendicularPt2 = destination_1.default(pt, heightDistance, direction - 90, options);\n      var intersect = line_intersect_1.default(helpers_1.lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), helpers_1.lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));\n      var intersectPt = null;\n\n      if (intersect.features.length > 0) {\n        intersectPt = intersect.features[0];\n        intersectPt.properties.dist = distance_1.default(pt, intersectPt, options);\n        intersectPt.properties.location = length + distance_1.default(start, intersectPt, options);\n      }\n\n      if (start.properties.dist < closestPt.properties.dist) {\n        closestPt = start;\n        closestPt.properties.index = i;\n        closestPt.properties.location = length;\n      }\n\n      if (stop_1.properties.dist < closestPt.properties.dist) {\n        closestPt = stop_1;\n        closestPt.properties.index = i + 1;\n        closestPt.properties.location = length + sectionLength;\n      }\n\n      if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n        closestPt = intersectPt;\n        closestPt.properties.index = i;\n      } // update length\n\n\n      length += sectionLength;\n    }\n  });\n  return closestPt;\n}\n\nexports.default = nearestPointOnLine;","map":null,"metadata":{},"sourceType":"script"}