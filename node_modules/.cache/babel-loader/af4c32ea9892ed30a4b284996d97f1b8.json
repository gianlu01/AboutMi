{"ast":null,"code":"var createVertex = require('./create_vertex');\n\nvar createMidpoint = require('./create_midpoint');\n\nvar Constants = require('../constants');\n\nfunction createSupplementaryPoints(geojson) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var basePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var _geojson$geometry = geojson.geometry,\n      type = _geojson$geometry.type,\n      coordinates = _geojson$geometry.coordinates;\n  var featureId = geojson.properties && geojson.properties.id;\n  var supplementaryPoints = [];\n\n  if (type === Constants.geojsonTypes.POINT) {\n    // For points, just create a vertex\n    supplementaryPoints.push(createVertex(featureId, coordinates, basePath, isSelectedPath(basePath)));\n  } else if (type === Constants.geojsonTypes.POLYGON) {\n    // Cycle through a Polygon's rings and\n    // process each line\n    coordinates.forEach(function (line, lineIndex) {\n      processLine(line, basePath !== null ? \"\".concat(basePath, \".\").concat(lineIndex) : String(lineIndex));\n    });\n  } else if (type === Constants.geojsonTypes.LINE_STRING) {\n    processLine(coordinates, basePath);\n  } else if (type.indexOf(Constants.geojsonTypes.MULTI_PREFIX) === 0) {\n    processMultiGeometry();\n  }\n\n  function processLine(line, lineBasePath) {\n    var firstPointString = '';\n    var lastVertex = null;\n    line.forEach(function (point, pointIndex) {\n      var pointPath = lineBasePath !== undefined && lineBasePath !== null ? \"\".concat(lineBasePath, \".\").concat(pointIndex) : String(pointIndex);\n      var vertex = createVertex(featureId, point, pointPath, isSelectedPath(pointPath)); // If we're creating midpoints, check if there was a\n      // vertex before this one. If so, add a midpoint\n      // between that vertex and this one.\n\n      if (options.midpoints && lastVertex) {\n        var midpoint = createMidpoint(featureId, lastVertex, vertex, options.map);\n\n        if (midpoint) {\n          supplementaryPoints.push(midpoint);\n        }\n      }\n\n      lastVertex = vertex; // A Polygon line's last point is the same as the first point. If we're on the last\n      // point, we want to draw a midpoint before it but not another vertex on it\n      // (since we already a vertex there, from the first point).\n\n      var stringifiedPoint = JSON.stringify(point);\n\n      if (firstPointString !== stringifiedPoint) {\n        supplementaryPoints.push(vertex);\n      }\n\n      if (pointIndex === 0) {\n        firstPointString = stringifiedPoint;\n      }\n    });\n  }\n\n  function isSelectedPath(path) {\n    if (!options.selectedPaths) return false;\n    return options.selectedPaths.indexOf(path) !== -1;\n  } // Split a multi-geometry into constituent\n  // geometries, and accumulate the supplementary points\n  // for each of those constituents\n\n\n  function processMultiGeometry() {\n    var subType = type.replace(Constants.geojsonTypes.MULTI_PREFIX, '');\n    coordinates.forEach(function (subCoordinates, index) {\n      var subFeature = {\n        type: Constants.geojsonTypes.FEATURE,\n        properties: geojson.properties,\n        geometry: {\n          type: subType,\n          coordinates: subCoordinates\n        }\n      };\n      supplementaryPoints = supplementaryPoints.concat(createSupplementaryPoints(subFeature, options, index));\n    });\n  }\n\n  return supplementaryPoints;\n}\n\nmodule.exports = createSupplementaryPoints;","map":{"version":3,"sources":["C:/Users/michele/Desktop/IT/Code/react/aboutmi/node_modules/@mapbox/mapbox-gl-draw/src/lib/create_supplementary_points.js"],"names":["createVertex","require","createMidpoint","Constants","createSupplementaryPoints","geojson","options","basePath","geometry","type","coordinates","featureId","properties","id","supplementaryPoints","geojsonTypes","POINT","push","isSelectedPath","POLYGON","forEach","line","lineIndex","processLine","String","LINE_STRING","indexOf","MULTI_PREFIX","processMultiGeometry","lineBasePath","firstPointString","lastVertex","point","pointIndex","pointPath","undefined","vertex","midpoints","midpoint","map","stringifiedPoint","JSON","stringify","path","selectedPaths","subType","replace","subCoordinates","index","subFeature","FEATURE","concat","module","exports"],"mappings":"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","sourcesContent":["const createVertex = require('./create_vertex');\r\nconst createMidpoint = require('./create_midpoint');\r\nconst Constants = require('../constants');\r\n\r\nfunction createSupplementaryPoints(geojson, options = {}, basePath = null) {\r\n  const { type, coordinates } = geojson.geometry;\r\n  const featureId = geojson.properties && geojson.properties.id;\r\n\r\n  let supplementaryPoints = [];\r\n\r\n  if (type === Constants.geojsonTypes.POINT) {\r\n    // For points, just create a vertex\r\n    supplementaryPoints.push(createVertex(featureId, coordinates, basePath, isSelectedPath(basePath)));\r\n  } else if (type === Constants.geojsonTypes.POLYGON) {\r\n    // Cycle through a Polygon's rings and\r\n    // process each line\r\n    coordinates.forEach((line, lineIndex) => {\r\n      processLine(line, (basePath !== null) ? `${basePath}.${lineIndex}` : String(lineIndex));\r\n    });\r\n  } else if (type === Constants.geojsonTypes.LINE_STRING) {\r\n    processLine(coordinates, basePath);\r\n  } else if (type.indexOf(Constants.geojsonTypes.MULTI_PREFIX) === 0) {\r\n    processMultiGeometry();\r\n  }\r\n\r\n  function processLine(line, lineBasePath) {\r\n    let firstPointString = '';\r\n    let lastVertex = null;\r\n    line.forEach((point, pointIndex) => {\r\n      const pointPath = (lineBasePath !== undefined && lineBasePath !== null) ? `${lineBasePath}.${pointIndex}` : String(pointIndex);\r\n      const vertex = createVertex(featureId, point, pointPath, isSelectedPath(pointPath));\r\n\r\n      // If we're creating midpoints, check if there was a\r\n      // vertex before this one. If so, add a midpoint\r\n      // between that vertex and this one.\r\n      if (options.midpoints && lastVertex) {\r\n        const midpoint = createMidpoint(featureId, lastVertex, vertex, options.map);\r\n        if (midpoint) {\r\n          supplementaryPoints.push(midpoint);\r\n        }\r\n      }\r\n      lastVertex = vertex;\r\n\r\n      // A Polygon line's last point is the same as the first point. If we're on the last\r\n      // point, we want to draw a midpoint before it but not another vertex on it\r\n      // (since we already a vertex there, from the first point).\r\n      const stringifiedPoint = JSON.stringify(point);\r\n      if (firstPointString !== stringifiedPoint) {\r\n        supplementaryPoints.push(vertex);\r\n      }\r\n      if (pointIndex === 0) {\r\n        firstPointString = stringifiedPoint;\r\n      }\r\n    });\r\n  }\r\n\r\n  function isSelectedPath(path) {\r\n    if (!options.selectedPaths) return false;\r\n    return options.selectedPaths.indexOf(path) !== -1;\r\n  }\r\n\r\n  // Split a multi-geometry into constituent\r\n  // geometries, and accumulate the supplementary points\r\n  // for each of those constituents\r\n  function processMultiGeometry() {\r\n    const subType = type.replace(Constants.geojsonTypes.MULTI_PREFIX, '');\r\n    coordinates.forEach((subCoordinates, index) => {\r\n      const subFeature = {\r\n        type: Constants.geojsonTypes.FEATURE,\r\n        properties: geojson.properties,\r\n        geometry: {\r\n          type: subType,\r\n          coordinates: subCoordinates\r\n        }\r\n      };\r\n      supplementaryPoints = supplementaryPoints.concat(createSupplementaryPoints(subFeature, options, index));\r\n    });\r\n  }\r\n\r\n  return supplementaryPoints;\r\n}\r\n\r\nmodule.exports = createSupplementaryPoints;\r\n"]},"metadata":{},"sourceType":"script"}