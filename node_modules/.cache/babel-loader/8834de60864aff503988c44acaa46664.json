{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isNumeric = isNumeric;\nexports.parseEventElement = parseEventElement;\nexports.getScreenCoords = getScreenCoords;\nexports.findClosestPointOnLineSegment = findClosestPointOnLineSegment;\nexports.getFeatureCoordinates = getFeatureCoordinates;\nexports.updateRectanglePosition = updateRectanglePosition;\n\nvar _constants = require(\"../constants\");\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction isNumeric(val) {\n  return !Array.isArray(val) && !isNaN(parseFloat(val)) && isFinite(val);\n}\n\nfunction parseEventElement(evt) {\n  var elem = evt.target;\n\n  if (!elem || !elem.dataset || !elem.dataset.type) {\n    return null;\n  }\n\n  var type = elem.dataset.type;\n  var featureIndex = elem.dataset.featureIndex;\n  var index = elem.dataset.index;\n  return {\n    object: {\n      type: type,\n      index: isNumeric(index) ? Number(index) : undefined,\n      featureIndex: isNumeric(featureIndex) ? Number(featureIndex) : undefined\n    },\n    index: index\n  };\n}\n\nfunction getScreenCoords(evt) {\n  var _evt$offsetCenter = evt.offsetCenter,\n      x = _evt$offsetCenter.x,\n      y = _evt$offsetCenter.y;\n  return [Number(x), Number(y)];\n}\n\nfunction findClosestPointOnLineSegment(p1, p2, p) {\n  // line\n  var k = (p2[1] - p1[1]) / (p2[0] - p1[0]);\n  var b = p1[1] - k * p1[0]; // vertical line\n\n  if (!isFinite(k)) {\n    var q = [p1[0], p[1]];\n    return inBounds(p1, p2, q) ? q : null;\n  } // p is on line [p1, p2]\n\n\n  if (p[0] * k + b - p[1] === 0) {\n    return inBounds(p1, p2, p) ? p : null;\n  }\n\n  var qx = (k * p[1] + p[0] - k * b) / (k * k + 1);\n  var qy = k * qx + b;\n  return inBounds(p1, p2, [qx, qy]) ? [qx, qy] : null;\n}\n\nfunction getFeatureCoordinates(feature) {\n  var coordinates = feature && feature.geometry && feature.geometry.coordinates;\n\n  if (!coordinates) {\n    return null;\n  }\n\n  var isPolygonal = feature.geometry.type === _constants.GEOJSON_TYPE.POLYGON;\n  return isPolygonal ? coordinates[0] : coordinates;\n}\n\nfunction updateRectanglePosition(feature, editHandleIndex, mapCoords) {\n  var coordinates = getFeatureCoordinates(feature);\n\n  if (!coordinates) {\n    return null;\n  }\n\n  var points = coordinates.slice(0, 4);\n  points[editHandleIndex % 4] = mapCoords;\n  /*\n  *   p0.x, p0.y (p0) ------ p2.x, p0.y (p1)\n  *       |                      |\n  *       |                      |\n  *   p0.x, p2.y (p3) ----- p2.x, p2.y (p2)\n  */\n\n  var p0 = points[(editHandleIndex + 2) % 4];\n  var p2 = points[editHandleIndex % 4];\n  points[(editHandleIndex + 1) % 4] = [p2[0], p0[1]];\n  points[(editHandleIndex + 3) % 4] = [p0[0], p2[1]];\n  return feature.geometry.type === _constants.GEOJSON_TYPE.POLYGON ? [_toConsumableArray(points).concat([points[0]])] : points;\n}\n\nfunction inBounds(p1, p2, p) {\n  var bounds = [Math.min(p1[0], p2[0]), Math.max(p1[0], p2[0]), Math.min(p1[1], p2[1]), Math.max(p1[1], p2[1])];\n  return p[0] >= bounds[0] && p[0] <= bounds[1] && p[1] >= bounds[2] && p[1] <= bounds[3];\n}","map":null,"metadata":{},"sourceType":"script"}