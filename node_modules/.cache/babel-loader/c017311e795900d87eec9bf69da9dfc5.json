{"ast":null,"code":"import center from '@turf/center';\nimport turfBbox from '@turf/bbox';\nimport { BufferOp, GeoJSONReader, GeoJSONWriter } from 'turf-jsts';\nimport { toMercator, toWgs84 } from '@turf/projection';\nimport { featureEach, geomEach } from '@turf/meta';\nimport { geoTransverseMercator } from 'd3-geo';\nimport { earthRadius, feature, featureCollection, lengthToRadians, radiansToLength } from '@turf/helpers';\n/**\n * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.\n *\n * When using a negative radius, the resulting geometry may be invalid if\n * it's too small compared to the radius magnitude. If the input is a\n * FeatureCollection, only valid members will be returned in the output\n * FeatureCollection - i.e., the output collection may have fewer members than\n * the input, or even be empty.\n *\n * @name buffer\n * @param {FeatureCollection|Geometry|Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer (negative values are allowed)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] any of the options supported by turf units\n * @param {number} [options.steps=64] number of steps\n * @returns {FeatureCollection|Feature<Polygon|MultiPolygon>|undefined} buffered features\n * @example\n * var point = turf.point([-90.548630, 14.616599]);\n * var buffered = turf.buffer(point, 500, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [point, buffered]\n */\n\nfunction buffer(geojson, radius, options) {\n  // Optional params\n  options = options || {};\n  var units = options.units;\n  var steps = options.steps || 64; // validation\n\n  if (!geojson) throw new Error('geojson is required');\n  if (typeof options !== 'object') throw new Error('options must be an object');\n  if (typeof steps !== 'number') throw new Error('steps must be an number'); // Allow negative buffers (\"erosion\") or zero-sized buffers (\"repair geometry\")\n\n  if (radius === undefined) throw new Error('radius is required');\n  if (steps <= 0) throw new Error('steps must be greater than 0'); // default params\n\n  steps = steps || 64;\n  units = units || 'kilometers';\n  var results = [];\n\n  switch (geojson.type) {\n    case 'GeometryCollection':\n      geomEach(geojson, function (geometry) {\n        var buffered = bufferFeature(geometry, radius, units, steps);\n        if (buffered) results.push(buffered);\n      });\n      return featureCollection(results);\n\n    case 'FeatureCollection':\n      featureEach(geojson, function (feature$$1) {\n        var multiBuffered = bufferFeature(feature$$1, radius, units, steps);\n\n        if (multiBuffered) {\n          featureEach(multiBuffered, function (buffered) {\n            if (buffered) results.push(buffered);\n          });\n        }\n      });\n      return featureCollection(results);\n  }\n\n  return bufferFeature(geojson, radius, units, steps);\n}\n/**\n * Buffer single Feature/Geometry\n *\n * @private\n * @param {Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer\n * @param {string} [units='kilometers'] any of the options supported by turf units\n * @param {number} [steps=64] number of steps\n * @returns {Feature<Polygon|MultiPolygon>} buffered feature\n */\n\n\nfunction bufferFeature(geojson, radius, units, steps) {\n  var properties = geojson.properties || {};\n  var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson; // Geometry Types faster than jsts\n\n  if (geometry.type === 'GeometryCollection') {\n    var results = [];\n    geomEach(geojson, function (geometry) {\n      var buffered = bufferFeature(geometry, radius, units, steps);\n      if (buffered) results.push(buffered);\n    });\n    return featureCollection(results);\n  } // Project GeoJSON to Transverse Mercator projection (convert to Meters)\n\n\n  var projected;\n  var bbox = turfBbox(geojson);\n  var needsTransverseMercator = bbox[1] > 50 && bbox[3] > 50;\n\n  if (needsTransverseMercator) {\n    projected = {\n      type: geometry.type,\n      coordinates: projectCoords(geometry.coordinates, defineProjection(geometry))\n    };\n  } else {\n    projected = toMercator(geometry);\n  } // JSTS buffer operation\n\n\n  var reader = new GeoJSONReader();\n  var geom = reader.read(projected);\n  var distance = radiansToLength(lengthToRadians(radius, units), 'meters');\n  var buffered = BufferOp.bufferOp(geom, distance);\n  var writer = new GeoJSONWriter();\n  buffered = writer.write(buffered); // Detect if empty geometries\n\n  if (coordsIsNaN(buffered.coordinates)) return undefined; // Unproject coordinates (convert to Degrees)\n\n  var result;\n\n  if (needsTransverseMercator) {\n    result = {\n      type: buffered.type,\n      coordinates: unprojectCoords(buffered.coordinates, defineProjection(geometry))\n    };\n  } else {\n    result = toWgs84(buffered);\n  }\n\n  return result.geometry ? result : feature(result, properties);\n}\n/**\n * Coordinates isNaN\n *\n * @private\n * @param {Array<any>} coords GeoJSON Coordinates\n * @returns {boolean} if NaN exists\n */\n\n\nfunction coordsIsNaN(coords) {\n  if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);\n  return isNaN(coords[0]);\n}\n/**\n * Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} projected coordinates\n */\n\n\nfunction projectCoords(coords, proj) {\n  if (typeof coords[0] !== 'object') return proj(coords);\n  return coords.map(function (coord) {\n    return projectCoords(coord, proj);\n  });\n}\n/**\n * Un-Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to un-project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} un-projected coordinates\n */\n\n\nfunction unprojectCoords(coords, proj) {\n  if (typeof coords[0] !== 'object') return proj.invert(coords);\n  return coords.map(function (coord) {\n    return unprojectCoords(coord, proj);\n  });\n}\n/**\n * Define Transverse Mercator projection\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Base projection on center of GeoJSON\n * @returns {GeoProjection} D3 Geo Transverse Mercator Projection\n */\n\n\nfunction defineProjection(geojson) {\n  var coords = center(geojson).geometry.coordinates.reverse();\n  var rotate = coords.map(function (coord) {\n    return -coord;\n  });\n  return geoTransverseMercator().center(coords).rotate(rotate).scale(earthRadius);\n}\n\nexport default buffer;","map":null,"metadata":{},"sourceType":"module"}