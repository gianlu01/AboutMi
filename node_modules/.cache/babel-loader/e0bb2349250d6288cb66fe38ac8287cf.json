{"ast":null,"code":"const isEqual = require('lodash.isequal');\n\nconst normalize = require('@mapbox/geojson-normalize');\n\nconst hat = require('hat');\n\nconst featuresAt = require('./lib/features_at');\n\nconst stringSetsAreEqual = require('./lib/string_sets_are_equal');\n\nconst geojsonhint = require('@mapbox/geojsonhint');\n\nconst Constants = require('./constants');\n\nconst StringSet = require('./lib/string_set');\n\nconst featureTypes = {\n  Polygon: require('./feature_types/polygon'),\n  LineString: require('./feature_types/line_string'),\n  Point: require('./feature_types/point'),\n  MultiPolygon: require('./feature_types/multi_feature'),\n  MultiLineString: require('./feature_types/multi_feature'),\n  MultiPoint: require('./feature_types/multi_feature')\n};\n\nmodule.exports = function (ctx, api) {\n  api.modes = Constants.modes;\n\n  api.getFeatureIdsAt = function (point) {\n    const features = featuresAt.click({\n      point\n    }, null, ctx);\n    return features.map(feature => feature.properties.id);\n  };\n\n  api.getSelectedIds = function () {\n    return ctx.store.getSelectedIds();\n  };\n\n  api.getSelected = function () {\n    return {\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: ctx.store.getSelectedIds().map(id => ctx.store.get(id)).map(feature => feature.toGeoJSON())\n    };\n  };\n\n  api.getSelectedPoints = function () {\n    return {\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: ctx.store.getSelectedCoordinates().map(coordinate => {\n        return {\n          type: Constants.geojsonTypes.FEATURE,\n          properties: {},\n          geometry: {\n            type: Constants.geojsonTypes.POINT,\n            coordinates: coordinate.coordinates\n          }\n        };\n      })\n    };\n  };\n\n  api.set = function (featureCollection) {\n    if (featureCollection.type === undefined || featureCollection.type !== Constants.geojsonTypes.FEATURE_COLLECTION || !Array.isArray(featureCollection.features)) {\n      throw new Error('Invalid FeatureCollection');\n    }\n\n    const renderBatch = ctx.store.createRenderBatch();\n    let toDelete = ctx.store.getAllIds().slice();\n    const newIds = api.add(featureCollection);\n    const newIdsLookup = new StringSet(newIds);\n    toDelete = toDelete.filter(id => !newIdsLookup.has(id));\n\n    if (toDelete.length) {\n      api.delete(toDelete);\n    }\n\n    renderBatch();\n    return newIds;\n  };\n\n  api.add = function (geojson) {\n    const errors = geojsonhint.hint(geojson, {\n      precisionWarning: false\n    }).filter(e => e.level !== 'message');\n\n    if (errors.length) {\n      throw new Error(errors[0].message);\n    }\n\n    const featureCollection = JSON.parse(JSON.stringify(normalize(geojson)));\n    const ids = featureCollection.features.map(feature => {\n      feature.id = feature.id || hat();\n\n      if (feature.geometry === null) {\n        throw new Error('Invalid geometry: null');\n      }\n\n      if (ctx.store.get(feature.id) === undefined || ctx.store.get(feature.id).type !== feature.geometry.type) {\n        // If the feature has not yet been created ...\n        const Model = featureTypes[feature.geometry.type];\n\n        if (Model === undefined) {\n          throw new Error(\"Invalid geometry type: \".concat(feature.geometry.type, \".\"));\n        }\n\n        const internalFeature = new Model(ctx, feature);\n        ctx.store.add(internalFeature);\n      } else {\n        // If a feature of that id has already been created, and we are swapping it out ...\n        const internalFeature = ctx.store.get(feature.id);\n        internalFeature.properties = feature.properties;\n\n        if (!isEqual(internalFeature.getCoordinates(), feature.geometry.coordinates)) {\n          internalFeature.incomingCoords(feature.geometry.coordinates);\n        }\n      }\n\n      return feature.id;\n    });\n    ctx.store.render();\n    return ids;\n  };\n\n  api.get = function (id) {\n    const feature = ctx.store.get(id);\n\n    if (feature) {\n      return feature.toGeoJSON();\n    }\n  };\n\n  api.getAll = function () {\n    return {\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: ctx.store.getAll().map(feature => feature.toGeoJSON())\n    };\n  };\n\n  api.delete = function (featureIds) {\n    ctx.store.delete(featureIds, {\n      silent: true\n    }); // If we were in direct select mode and our selected feature no longer exists\n    // (because it was deleted), we need to get out of that mode.\n\n    if (api.getMode() === Constants.modes.DIRECT_SELECT && !ctx.store.getSelectedIds().length) {\n      ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, undefined, {\n        silent: true\n      });\n    } else {\n      ctx.store.render();\n    }\n\n    return api;\n  };\n\n  api.deleteAll = function () {\n    ctx.store.delete(ctx.store.getAllIds(), {\n      silent: true\n    }); // If we were in direct select mode, now our selected feature no longer exists,\n    // so escape that mode.\n\n    if (api.getMode() === Constants.modes.DIRECT_SELECT) {\n      ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, undefined, {\n        silent: true\n      });\n    } else {\n      ctx.store.render();\n    }\n\n    return api;\n  };\n\n  api.changeMode = function (mode, modeOptions = {}) {\n    // Avoid changing modes just to re-select what's already selected\n    if (mode === Constants.modes.SIMPLE_SELECT && api.getMode() === Constants.modes.SIMPLE_SELECT) {\n      if (stringSetsAreEqual(modeOptions.featureIds || [], ctx.store.getSelectedIds())) return api; // And if we are changing the selection within simple_select mode, just change the selection,\n      // instead of stopping and re-starting the mode\n\n      ctx.store.setSelected(modeOptions.featureIds, {\n        silent: true\n      });\n      ctx.store.render();\n      return api;\n    }\n\n    if (mode === Constants.modes.DIRECT_SELECT && api.getMode() === Constants.modes.DIRECT_SELECT && modeOptions.featureId === ctx.store.getSelectedIds()[0]) {\n      return api;\n    }\n\n    ctx.events.changeMode(mode, modeOptions, {\n      silent: true\n    });\n    return api;\n  };\n\n  api.getMode = function () {\n    return ctx.events.getMode();\n  };\n\n  api.trash = function () {\n    ctx.events.trash({\n      silent: true\n    });\n    return api;\n  };\n\n  api.combineFeatures = function () {\n    ctx.events.combineFeatures({\n      silent: true\n    });\n    return api;\n  };\n\n  api.uncombineFeatures = function () {\n    ctx.events.uncombineFeatures({\n      silent: true\n    });\n    return api;\n  };\n\n  api.setFeatureProperty = function (featureId, property, value) {\n    ctx.store.setFeatureProperty(featureId, property, value);\n    return api;\n  };\n\n  return api;\n};","map":null,"metadata":{},"sourceType":"script"}