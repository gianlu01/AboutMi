{"ast":null,"code":"var Constants = require('./constants');\n\nmodule.exports = function render() {\n  var store = this;\n  var mapExists = store.ctx.map && store.ctx.map.getSource(Constants.sources.HOT) !== undefined;\n  if (!mapExists) return cleanup();\n  var mode = store.ctx.events.currentModeName();\n  store.ctx.ui.queueMapClasses({\n    mode: mode\n  });\n  var newHotIds = [];\n  var newColdIds = [];\n\n  if (store.isDirty) {\n    newColdIds = store.getAllIds();\n  } else {\n    newHotIds = store.getChangedIds().filter(function (id) {\n      return store.get(id) !== undefined;\n    });\n    newColdIds = store.sources.hot.filter(function (geojson) {\n      return geojson.properties.id && newHotIds.indexOf(geojson.properties.id) === -1 && store.get(geojson.properties.id) !== undefined;\n    }).map(function (geojson) {\n      return geojson.properties.id;\n    });\n  }\n\n  store.sources.hot = [];\n  var lastColdCount = store.sources.cold.length;\n  store.sources.cold = store.isDirty ? [] : store.sources.cold.filter(function (geojson) {\n    var id = geojson.properties.id || geojson.properties.parent;\n    return newHotIds.indexOf(id) === -1;\n  });\n  var coldChanged = lastColdCount !== store.sources.cold.length || newColdIds.length > 0;\n  newHotIds.forEach(function (id) {\n    return renderFeature(id, 'hot');\n  });\n  newColdIds.forEach(function (id) {\n    return renderFeature(id, 'cold');\n  });\n\n  function renderFeature(id, source) {\n    var feature = store.get(id);\n    var featureInternal = feature.internal(mode);\n    store.ctx.events.currentModeRender(featureInternal, function (geojson) {\n      store.sources[source].push(geojson);\n    });\n  }\n\n  if (coldChanged) {\n    store.ctx.map.getSource(Constants.sources.COLD).setData({\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: store.sources.cold\n    });\n  }\n\n  store.ctx.map.getSource(Constants.sources.HOT).setData({\n    type: Constants.geojsonTypes.FEATURE_COLLECTION,\n    features: store.sources.hot\n  });\n\n  if (store._emitSelectionChange) {\n    store.ctx.map.fire(Constants.events.SELECTION_CHANGE, {\n      features: store.getSelected().map(function (feature) {\n        return feature.toGeoJSON();\n      }),\n      points: store.getSelectedCoordinates().map(function (coordinate) {\n        return {\n          type: Constants.geojsonTypes.FEATURE,\n          properties: {},\n          geometry: {\n            type: Constants.geojsonTypes.POINT,\n            coordinates: coordinate.coordinates\n          }\n        };\n      })\n    });\n    store._emitSelectionChange = false;\n  }\n\n  if (store._deletedFeaturesToEmit.length) {\n    var geojsonToEmit = store._deletedFeaturesToEmit.map(function (feature) {\n      return feature.toGeoJSON();\n    });\n\n    store._deletedFeaturesToEmit = [];\n    store.ctx.map.fire(Constants.events.DELETE, {\n      features: geojsonToEmit\n    });\n  }\n\n  cleanup();\n  store.ctx.map.fire(Constants.events.RENDER, {});\n\n  function cleanup() {\n    store.isDirty = false;\n    store.clearChangedIds();\n  }\n};","map":{"version":3,"sources":["C:/Users/michele/Desktop/IT/Code/react/aboutmi/node_modules/@mapbox/mapbox-gl-draw/src/render.js"],"names":["Constants","require","module","exports","render","store","mapExists","ctx","map","getSource","sources","HOT","undefined","cleanup","mode","events","currentModeName","ui","queueMapClasses","newHotIds","newColdIds","isDirty","getAllIds","getChangedIds","filter","id","get","hot","geojson","properties","indexOf","lastColdCount","cold","length","parent","coldChanged","forEach","renderFeature","source","feature","featureInternal","internal","currentModeRender","push","COLD","setData","type","geojsonTypes","FEATURE_COLLECTION","features","_emitSelectionChange","fire","SELECTION_CHANGE","getSelected","toGeoJSON","points","getSelectedCoordinates","coordinate","FEATURE","geometry","POINT","coordinates","_deletedFeaturesToEmit","geojsonToEmit","DELETE","RENDER","clearChangedIds"],"mappings":"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","sourcesContent":["const Constants = require('./constants');\r\n\r\nmodule.exports = function render() {\r\n  const store = this;\r\n  const mapExists = store.ctx.map && store.ctx.map.getSource(Constants.sources.HOT) !== undefined;\r\n  if (!mapExists) return cleanup();\r\n\r\n  const mode = store.ctx.events.currentModeName();\r\n\r\n  store.ctx.ui.queueMapClasses({ mode });\r\n\r\n  let newHotIds = [];\r\n  let newColdIds = [];\r\n\r\n  if (store.isDirty) {\r\n    newColdIds = store.getAllIds();\r\n  } else {\r\n    newHotIds = store.getChangedIds().filter(id => store.get(id) !== undefined);\r\n    newColdIds = store.sources.hot.filter((geojson) => {\r\n      return geojson.properties.id && newHotIds.indexOf(geojson.properties.id) === -1 && store.get(geojson.properties.id) !== undefined;\r\n    }).map(geojson => geojson.properties.id);\r\n  }\r\n\r\n  store.sources.hot = [];\r\n  const lastColdCount = store.sources.cold.length;\r\n  store.sources.cold = store.isDirty ? [] : store.sources.cold.filter((geojson) => {\r\n    const id = geojson.properties.id || geojson.properties.parent;\r\n    return newHotIds.indexOf(id) === -1;\r\n  });\r\n\r\n  const coldChanged = lastColdCount !== store.sources.cold.length || newColdIds.length > 0;\r\n  newHotIds.forEach(id => renderFeature(id, 'hot'));\r\n  newColdIds.forEach(id => renderFeature(id, 'cold'));\r\n\r\n  function renderFeature(id, source) {\r\n    const feature = store.get(id);\r\n    const featureInternal = feature.internal(mode);\r\n    store.ctx.events.currentModeRender(featureInternal, (geojson) => {\r\n      store.sources[source].push(geojson);\r\n    });\r\n  }\r\n\r\n  if (coldChanged) {\r\n    store.ctx.map.getSource(Constants.sources.COLD).setData({\r\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\r\n      features: store.sources.cold\r\n    });\r\n  }\r\n\r\n  store.ctx.map.getSource(Constants.sources.HOT).setData({\r\n    type: Constants.geojsonTypes.FEATURE_COLLECTION,\r\n    features: store.sources.hot\r\n  });\r\n\r\n  if (store._emitSelectionChange) {\r\n    store.ctx.map.fire(Constants.events.SELECTION_CHANGE, {\r\n      features: store.getSelected().map(feature => feature.toGeoJSON()),\r\n      points: store.getSelectedCoordinates().map(coordinate => {\r\n        return {\r\n          type: Constants.geojsonTypes.FEATURE,\r\n          properties: {},\r\n          geometry: {\r\n            type: Constants.geojsonTypes.POINT,\r\n            coordinates: coordinate.coordinates\r\n          }\r\n        };\r\n      })\r\n    });\r\n    store._emitSelectionChange = false;\r\n  }\r\n\r\n  if (store._deletedFeaturesToEmit.length) {\r\n    const geojsonToEmit = store._deletedFeaturesToEmit.map(feature => feature.toGeoJSON());\r\n\r\n    store._deletedFeaturesToEmit = [];\r\n\r\n    store.ctx.map.fire(Constants.events.DELETE, {\r\n      features: geojsonToEmit\r\n    });\r\n  }\r\n\r\n  cleanup();\r\n  store.ctx.map.fire(Constants.events.RENDER, {});\r\n\r\n  function cleanup() {\r\n    store.isDirty = false;\r\n    store.clearChangedIds();\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}