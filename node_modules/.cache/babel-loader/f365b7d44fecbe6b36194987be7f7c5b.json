{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\r\n * @module ol/geom/SimpleGeometry\r\n */\n\n\nimport { abstract } from '../util.js';\nimport { createOrUpdateFromFlatCoordinates, getCenter } from '../extent.js';\nimport Geometry from './Geometry.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport { rotate, scale, translate, transform2D } from './flat/transform.js';\n/**\r\n * @classdesc\r\n * Abstract base class; only used for creating subclasses; do not instantiate\r\n * in apps, as cannot be rendered.\r\n *\r\n * @abstract\r\n * @api\r\n */\n\nvar SimpleGeometry =\n/** @class */\nfunction (_super) {\n  __extends(SimpleGeometry, _super);\n\n  function SimpleGeometry() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * @protected\r\n     * @type {GeometryLayout}\r\n     */\n\n\n    _this.layout = GeometryLayout.XY;\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\n\n    _this.stride = 2;\n    /**\r\n     * @protected\r\n     * @type {Array<number>}\r\n     */\n\n    _this.flatCoordinates = null;\n    return _this;\n  }\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  SimpleGeometry.prototype.computeExtent = function (extent) {\n    return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n  };\n  /**\r\n   * @abstract\r\n   * @return {Array<*>} Coordinates.\r\n   */\n\n\n  SimpleGeometry.prototype.getCoordinates = function () {\n    return abstract();\n  };\n  /**\r\n   * Return the first coordinate of the geometry.\r\n   * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\r\n   * @api\r\n   */\n\n\n  SimpleGeometry.prototype.getFirstCoordinate = function () {\n    return this.flatCoordinates.slice(0, this.stride);\n  };\n  /**\r\n   * @return {Array<number>} Flat coordinates.\r\n   */\n\n\n  SimpleGeometry.prototype.getFlatCoordinates = function () {\n    return this.flatCoordinates;\n  };\n  /**\r\n   * Return the last coordinate of the geometry.\r\n   * @return {import(\"../coordinate.js\").Coordinate} Last point.\r\n   * @api\r\n   */\n\n\n  SimpleGeometry.prototype.getLastCoordinate = function () {\n    return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);\n  };\n  /**\r\n   * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.\r\n   * @return {GeometryLayout} Layout.\r\n   * @api\r\n   */\n\n\n  SimpleGeometry.prototype.getLayout = function () {\n    return this.layout;\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  SimpleGeometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    } // If squaredTolerance is negative or if we know that simplification will not\n    // have any effect then just return this.\n\n\n    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {\n      return this;\n    }\n\n    var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);\n    var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n\n    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n      return simplifiedGeometry;\n    } else {\n      // Simplification did not actually remove any coordinates.  We now know\n      // that any calls to getSimplifiedGeometry with a squaredTolerance less\n      // than or equal to the current squaredTolerance will also not have any\n      // effect.  This allows us to short circuit simplification (saving CPU\n      // cycles) and prevents the cache of simplified geometries from filling\n      // up with useless identical copies of this geometry (saving memory).\n      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n      return this;\n    }\n  };\n  /**\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {SimpleGeometry} Simplified geometry.\r\n   * @protected\r\n   */\n\n\n  SimpleGeometry.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n    return this;\n  };\n  /**\r\n   * @return {number} Stride.\r\n   */\n\n\n  SimpleGeometry.prototype.getStride = function () {\n    return this.stride;\n  };\n  /**\r\n   * @param {GeometryLayout} layout Layout.\r\n   * @param {Array<number>} flatCoordinates Flat coordinates.\r\n   */\n\n\n  SimpleGeometry.prototype.setFlatCoordinates = function (layout, flatCoordinates) {\n    this.stride = getStrideForLayout(layout);\n    this.layout = layout;\n    this.flatCoordinates = flatCoordinates;\n  };\n  /**\r\n   * @abstract\r\n   * @param {!Array<*>} coordinates Coordinates.\r\n   * @param {GeometryLayout=} opt_layout Layout.\r\n   */\n\n\n  SimpleGeometry.prototype.setCoordinates = function (coordinates, opt_layout) {\n    abstract();\n  };\n  /**\r\n   * @param {GeometryLayout|undefined} layout Layout.\r\n   * @param {Array<*>} coordinates Coordinates.\r\n   * @param {number} nesting Nesting.\r\n   * @protected\r\n   */\n\n\n  SimpleGeometry.prototype.setLayout = function (layout, coordinates, nesting) {\n    /** @type {number} */\n    var stride;\n\n    if (layout) {\n      stride = getStrideForLayout(layout);\n    } else {\n      for (var i = 0; i < nesting; ++i) {\n        if (coordinates.length === 0) {\n          this.layout = GeometryLayout.XY;\n          this.stride = 2;\n          return;\n        } else {\n          coordinates =\n          /** @type {Array} */\n          coordinates[0];\n        }\n      }\n\n      stride = coordinates.length;\n      layout = getLayoutForStride(stride);\n    }\n\n    this.layout = layout;\n    this.stride = stride;\n  };\n  /**\r\n   * Apply a transform function to the coordinates of the geometry.\r\n   * The geometry is modified in place.\r\n   * If you do not want the geometry modified in place, first `clone()` it and\r\n   * then use this function on the clone.\r\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\r\n   * Called with a flat array of geometry coordinates.\r\n   * @api\r\n   */\n\n\n  SimpleGeometry.prototype.applyTransform = function (transformFn) {\n    if (this.flatCoordinates) {\n      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n      this.changed();\n    }\n  };\n  /**\r\n   * Rotate the geometry around a given coordinate. This modifies the geometry\r\n   * coordinates in place.\r\n   * @param {number} angle Rotation angle in radians.\r\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\r\n   * @api\r\n   */\n\n\n  SimpleGeometry.prototype.rotate = function (angle, anchor) {\n    var flatCoordinates = this.getFlatCoordinates();\n\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);\n      this.changed();\n    }\n  };\n  /**\r\n   * Scale the geometry (with an optional origin).  This modifies the geometry\r\n   * coordinates in place.\r\n    * @param {number} sx The scaling factor in the x-direction.\r\n   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to\r\n   *     sx).\r\n   * @param {import(\"../coordinate.js\").Coordinate=} opt_anchor The scale origin (defaults to the center\r\n   *     of the geometry extent).\r\n   * @api\r\n   */\n\n\n  SimpleGeometry.prototype.scale = function (sx, opt_sy, opt_anchor) {\n    var sy = opt_sy;\n\n    if (sy === undefined) {\n      sy = sx;\n    }\n\n    var anchor = opt_anchor;\n\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n\n    var flatCoordinates = this.getFlatCoordinates();\n\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);\n      this.changed();\n    }\n  };\n  /**\r\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\r\n   * instead you want a new geometry, first `clone()` this geometry.\r\n   * @param {number} deltaX Delta X.\r\n   * @param {number} deltaY Delta Y.\r\n   * @api\r\n   */\n\n\n  SimpleGeometry.prototype.translate = function (deltaX, deltaY) {\n    var flatCoordinates = this.getFlatCoordinates();\n\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);\n      this.changed();\n    }\n  };\n\n  return SimpleGeometry;\n}(Geometry);\n/**\r\n * @param {number} stride Stride.\r\n * @return {GeometryLayout} layout Layout.\r\n */\n\n\nfunction getLayoutForStride(stride) {\n  var layout;\n\n  if (stride == 2) {\n    layout = GeometryLayout.XY;\n  } else if (stride == 3) {\n    layout = GeometryLayout.XYZ;\n  } else if (stride == 4) {\n    layout = GeometryLayout.XYZM;\n  }\n\n  return (\n    /** @type {GeometryLayout} */\n    layout\n  );\n}\n/**\r\n * @param {GeometryLayout} layout Layout.\r\n * @return {number} Stride.\r\n */\n\n\nexport function getStrideForLayout(layout) {\n  var stride;\n\n  if (layout == GeometryLayout.XY) {\n    stride = 2;\n  } else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {\n    stride = 3;\n  } else if (layout == GeometryLayout.XYZM) {\n    stride = 4;\n  }\n\n  return (\n    /** @type {number} */\n    stride\n  );\n}\n/**\r\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\r\n * @param {import(\"../transform.js\").Transform} transform Transform.\r\n * @param {Array<number>=} opt_dest Destination.\r\n * @return {Array<number>} Transformed flat coordinates.\r\n */\n\nexport function transformGeom2D(simpleGeometry, transform, opt_dest) {\n  var flatCoordinates = simpleGeometry.getFlatCoordinates();\n\n  if (!flatCoordinates) {\n    return null;\n  } else {\n    var stride = simpleGeometry.getStride();\n    return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);\n  }\n}\nexport default SimpleGeometry;","map":null,"metadata":{},"sourceType":"module"}