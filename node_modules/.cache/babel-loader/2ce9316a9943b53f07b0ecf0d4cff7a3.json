{"ast":null,"code":"var sortFeatures = require('./sort_features');\n\nvar mapEventToBoundingBox = require('./map_event_to_bounding_box');\n\nvar Constants = require('../constants');\n\nvar StringSet = require('./string_set');\n\nvar META_TYPES = [Constants.meta.FEATURE, Constants.meta.MIDPOINT, Constants.meta.VERTEX]; // Requires either event or bbox\n\nmodule.exports = {\n  click: featuresAtClick,\n  touch: featuresAtTouch\n};\n\nfunction featuresAtClick(event, bbox, ctx) {\n  return featuresAt(event, bbox, ctx, ctx.options.clickBuffer);\n}\n\nfunction featuresAtTouch(event, bbox, ctx) {\n  return featuresAt(event, bbox, ctx, ctx.options.touchBuffer);\n}\n\nfunction featuresAt(event, bbox, ctx, buffer) {\n  if (ctx.map === null) return [];\n  var box = event ? mapEventToBoundingBox(event, buffer) : bbox;\n  var queryParams = {};\n  if (ctx.options.styles) queryParams.layers = ctx.options.styles.map(function (s) {\n    return s.id;\n  });\n  var features = ctx.map.queryRenderedFeatures(box, queryParams).filter(function (feature) {\n    return META_TYPES.indexOf(feature.properties.meta) !== -1;\n  });\n  var featureIds = new StringSet();\n  var uniqueFeatures = [];\n  features.forEach(function (feature) {\n    var featureId = feature.properties.id;\n    if (featureIds.has(featureId)) return;\n    featureIds.add(featureId);\n    uniqueFeatures.push(feature);\n  });\n  return sortFeatures(uniqueFeatures);\n}","map":{"version":3,"sources":["C:/Users/michele/Desktop/IT/Code/react/aboutmi/node_modules/@mapbox/mapbox-gl-draw/src/lib/features_at.js"],"names":["sortFeatures","require","mapEventToBoundingBox","Constants","StringSet","META_TYPES","meta","FEATURE","MIDPOINT","VERTEX","module","exports","click","featuresAtClick","touch","featuresAtTouch","event","bbox","ctx","featuresAt","options","clickBuffer","touchBuffer","buffer","map","box","queryParams","styles","layers","s","id","features","queryRenderedFeatures","filter","feature","indexOf","properties","featureIds","uniqueFeatures","forEach","featureId","has","add","push"],"mappings":"AAAA,IAAMA,YAAY,GAAGC,OAAO,CAAC,iBAAD,CAA5B;;AACA,IAAMC,qBAAqB,GAAGD,OAAO,CAAC,6BAAD,CAArC;;AACA,IAAME,SAAS,GAAGF,OAAO,CAAC,cAAD,CAAzB;;AACA,IAAMG,SAAS,GAAGH,OAAO,CAAC,cAAD,CAAzB;;AAEA,IAAMI,UAAU,GAAG,CACjBF,SAAS,CAACG,IAAV,CAAeC,OADE,EAEjBJ,SAAS,CAACG,IAAV,CAAeE,QAFE,EAGjBL,SAAS,CAACG,IAAV,CAAeG,MAHE,CAAnB,C,CAMA;;AACAC,MAAM,CAACC,OAAP,GAAiB;AACfC,EAAAA,KAAK,EAAEC,eADQ;AAEfC,EAAAA,KAAK,EAAEC;AAFQ,CAAjB;;AAKA,SAASF,eAAT,CAAyBG,KAAzB,EAAgCC,IAAhC,EAAsCC,GAAtC,EAA2C;AACzC,SAAOC,UAAU,CAACH,KAAD,EAAQC,IAAR,EAAcC,GAAd,EAAmBA,GAAG,CAACE,OAAJ,CAAYC,WAA/B,CAAjB;AACD;;AAED,SAASN,eAAT,CAAyBC,KAAzB,EAAgCC,IAAhC,EAAsCC,GAAtC,EAA2C;AACzC,SAAOC,UAAU,CAACH,KAAD,EAAQC,IAAR,EAAcC,GAAd,EAAmBA,GAAG,CAACE,OAAJ,CAAYE,WAA/B,CAAjB;AACD;;AAED,SAASH,UAAT,CAAoBH,KAApB,EAA2BC,IAA3B,EAAiCC,GAAjC,EAAsCK,MAAtC,EAA8C;AAC5C,MAAIL,GAAG,CAACM,GAAJ,KAAY,IAAhB,EAAsB,OAAO,EAAP;AAEtB,MAAMC,GAAG,GAAIT,KAAD,GAAUd,qBAAqB,CAACc,KAAD,EAAQO,MAAR,CAA/B,GAAiDN,IAA7D;AAEA,MAAMS,WAAW,GAAG,EAApB;AACA,MAAIR,GAAG,CAACE,OAAJ,CAAYO,MAAhB,EAAwBD,WAAW,CAACE,MAAZ,GAAqBV,GAAG,CAACE,OAAJ,CAAYO,MAAZ,CAAmBH,GAAnB,CAAuB,UAAAK,CAAC;AAAA,WAAIA,CAAC,CAACC,EAAN;AAAA,GAAxB,CAArB;AAExB,MAAMC,QAAQ,GAAGb,GAAG,CAACM,GAAJ,CAAQQ,qBAAR,CAA8BP,GAA9B,EAAmCC,WAAnC,EACdO,MADc,CACP,UAACC,OAAD,EAAa;AACnB,WAAO7B,UAAU,CAAC8B,OAAX,CAAmBD,OAAO,CAACE,UAAR,CAAmB9B,IAAtC,MAAgD,CAAC,CAAxD;AACD,GAHc,CAAjB;AAKA,MAAM+B,UAAU,GAAG,IAAIjC,SAAJ,EAAnB;AACA,MAAMkC,cAAc,GAAG,EAAvB;AACAP,EAAAA,QAAQ,CAACQ,OAAT,CAAiB,UAACL,OAAD,EAAa;AAC5B,QAAMM,SAAS,GAAGN,OAAO,CAACE,UAAR,CAAmBN,EAArC;AACA,QAAIO,UAAU,CAACI,GAAX,CAAeD,SAAf,CAAJ,EAA+B;AAC/BH,IAAAA,UAAU,CAACK,GAAX,CAAeF,SAAf;AACAF,IAAAA,cAAc,CAACK,IAAf,CAAoBT,OAApB;AACD,GALD;AAOA,SAAOlC,YAAY,CAACsC,cAAD,CAAnB;AACD","sourcesContent":["const sortFeatures = require('./sort_features');\r\nconst mapEventToBoundingBox = require('./map_event_to_bounding_box');\r\nconst Constants = require('../constants');\r\nconst StringSet = require('./string_set');\r\n\r\nconst META_TYPES = [\r\n  Constants.meta.FEATURE,\r\n  Constants.meta.MIDPOINT,\r\n  Constants.meta.VERTEX\r\n];\r\n\r\n// Requires either event or bbox\r\nmodule.exports = {\r\n  click: featuresAtClick,\r\n  touch: featuresAtTouch\r\n};\r\n\r\nfunction featuresAtClick(event, bbox, ctx) {\r\n  return featuresAt(event, bbox, ctx, ctx.options.clickBuffer);\r\n}\r\n\r\nfunction featuresAtTouch(event, bbox, ctx) {\r\n  return featuresAt(event, bbox, ctx, ctx.options.touchBuffer);\r\n}\r\n\r\nfunction featuresAt(event, bbox, ctx, buffer) {\r\n  if (ctx.map === null) return [];\r\n\r\n  const box = (event) ? mapEventToBoundingBox(event, buffer) : bbox;\r\n\r\n  const queryParams = {};\r\n  if (ctx.options.styles) queryParams.layers = ctx.options.styles.map(s => s.id);\r\n\r\n  const features = ctx.map.queryRenderedFeatures(box, queryParams)\r\n    .filter((feature) => {\r\n      return META_TYPES.indexOf(feature.properties.meta) !== -1;\r\n    });\r\n\r\n  const featureIds = new StringSet();\r\n  const uniqueFeatures = [];\r\n  features.forEach((feature) => {\r\n    const featureId = feature.properties.id;\r\n    if (featureIds.has(featureId)) return;\r\n    featureIds.add(featureId);\r\n    uniqueFeatures.push(feature);\r\n  });\r\n\r\n  return sortFeatures(uniqueFeatures);\r\n}\r\n"]},"metadata":{},"sourceType":"script"}