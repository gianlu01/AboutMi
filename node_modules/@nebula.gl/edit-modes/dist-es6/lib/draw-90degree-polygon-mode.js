"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Draw90DegreePolygonMode = void 0;

var _destination = _interopRequireDefault(require("@turf/destination"));

var _bearing = _interopRequireDefault(require("@turf/bearing"));

var _lineIntersect = _interopRequireDefault(require("@turf/line-intersect"));

var _distance = _interopRequireDefault(require("@turf/distance"));

var _helpers = require("@turf/helpers");

var _utils = require("../utils");

var _geojsonEditMode = require("./geojson-edit-mode.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Draw90DegreePolygonMode =
/*#__PURE__*/
function (_BaseGeoJsonEditMode) {
  _inherits(Draw90DegreePolygonMode, _BaseGeoJsonEditMode);

  function Draw90DegreePolygonMode() {
    _classCallCheck(this, Draw90DegreePolygonMode);

    return _possibleConstructorReturn(this, _getPrototypeOf(Draw90DegreePolygonMode).apply(this, arguments));
  }

  _createClass(Draw90DegreePolygonMode, [{
    key: "getGuides",
    value: function getGuides(props) {
      var guides = {
        type: 'FeatureCollection',
        features: []
      };
      var clickSequence = this.getClickSequence();

      if (clickSequence.length === 0 || !props.lastPointerMoveEvent) {
        return guides;
      }

      var mapCoords = props.lastPointerMoveEvent.mapCoords;
      var p3;

      if (clickSequence.length === 1) {
        p3 = mapCoords;
      } else {
        var p1 = clickSequence[clickSequence.length - 2];
        var p2 = clickSequence[clickSequence.length - 1];

        var _generatePointsParall = (0, _utils.generatePointsParallelToLinePoints)(p1, p2, mapCoords);

        var _generatePointsParall2 = _slicedToArray(_generatePointsParall, 1);

        p3 = _generatePointsParall2[0];
      }

      var tentativeFeature;

      if (clickSequence.length < 3) {
        // Draw a LineString connecting all the clicked points with the hovered point
        tentativeFeature = {
          type: 'Feature',
          properties: {
            guideType: 'tentative'
          },
          geometry: {
            type: 'LineString',
            coordinates: _toConsumableArray(clickSequence).concat([p3])
          }
        };
      } else {
        // Draw a Polygon connecting all the clicked points with the hovered point
        tentativeFeature = {
          type: 'Feature',
          properties: {
            guideType: 'tentative'
          },
          geometry: {
            type: 'Polygon',
            coordinates: [_toConsumableArray(clickSequence).concat([p3, clickSequence[0]])]
          }
        };
      }

      guides.features.push(tentativeFeature);
      guides.features = guides.features.concat((0, _utils.getEditHandlesForGeometry)(tentativeFeature.geometry, -1)); // Slice off the handles that are are next to the pointer

      guides.features = guides.features.slice(0, -1);
      return guides;
    }
  }, {
    key: "handlePointerMove",
    value: function handlePointerMove(_ref, props) {
      var mapCoords = _ref.mapCoords;
      props.onUpdateCursor('cell');
    }
  }, {
    key: "handleClick",
    value: function handleClick(event, props) {
      var picks = event.picks;
      var tentativeFeature = this.getTentativeGuide(props);
      this.addClickSequence(event);
      var clickSequence = this.getClickSequence();

      if (!tentativeFeature) {
        // nothing else to do
        return;
      }

      if (clickSequence.length === 3 && tentativeFeature.geometry.type === 'LineString') {
        var lineString = tentativeFeature.geometry; // Tweak the clicked position to be the snapped 90 degree point along the polygon

        clickSequence[clickSequence.length - 1] = lineString.coordinates[lineString.coordinates.length - 1];
      } else if (clickSequence.length > 3 && tentativeFeature.geometry.type === 'Polygon') {
        var polygon = tentativeFeature.geometry; // Tweak the clicked position to be the snapped 90 degree point along the polygon

        clickSequence[clickSequence.length - 1] = polygon.coordinates[0][polygon.coordinates[0].length - 2];
        var clickedEditHandle = (0, _utils.getPickedEditHandle)(picks);

        if (clickedEditHandle && (clickedEditHandle.properties.positionIndexes[1] === 0 || clickedEditHandle.properties.positionIndexes[1] === polygon.coordinates[0].length - 3)) {
          // They clicked the first or last point (or double-clicked), so complete the polygon
          var polygonToAdd = {
            type: 'Polygon',
            coordinates: this.finalizedCoordinates(_toConsumableArray(polygon.coordinates[0]))
          };
          this.resetClickSequence();
          var editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd, props);

          if (editAction) {
            props.onEdit(editAction);
          }
        }
      } // Trigger pointer move right away in order for it to update edit handles (to support double-click)


      var fakePointerMoveEvent = {
        screenCoords: [-1, -1],
        mapCoords: event.mapCoords,
        picks: [],
        pointerDownPicks: null,
        pointerDownScreenCoords: null,
        pointerDownMapCoords: null,
        cancelPan: function cancelPan() {},
        sourceEvent: null
      };
      this.handlePointerMove(fakePointerMoveEvent, props);
    }
  }, {
    key: "finalizedCoordinates",
    value: function finalizedCoordinates(coords) {
      // Remove the hovered position
      var coordinates = [_toConsumableArray(coords.slice(0, -2)).concat([coords[0]])];
      var pt = this.getIntermediatePoint(_toConsumableArray(coords));

      if (!pt) {
        // if intermediate point with 90 degree not available
        // try remove the last clicked point and get the intermediate point.
        var tc = _toConsumableArray(coords);

        tc.splice(-3, 1);
        pt = this.getIntermediatePoint(_toConsumableArray(tc));

        if (pt) {
          coordinates = [_toConsumableArray(coords.slice(0, -3)).concat([pt, coords[0]])];
        }
      } else {
        coordinates = [_toConsumableArray(coords.slice(0, -2)).concat([pt, coords[0]])];
      }

      return coordinates;
    }
  }, {
    key: "getIntermediatePoint",
    value: function getIntermediatePoint(coordinates) {
      var pt;

      if (coordinates.length > 4) {
        var _ref2 = _toConsumableArray(coordinates),
            p1 = _ref2[0],
            p2 = _ref2[1];

        var angle1 = (0, _bearing.default)(p1, p2);
        var p3 = coordinates[coordinates.length - 3];
        var p4 = coordinates[coordinates.length - 4];
        var angle2 = (0, _bearing.default)(p3, p4);
        var angles = {
          first: [],
          second: []
        }; // calculate 3 right angle points for first and last points in lineString

        [1, 2, 3].forEach(function (factor) {
          var newAngle1 = angle1 + factor * 90; // convert angles to 0 to -180 for anti-clock and 0 to 180 for clock wise

          angles.first.push(newAngle1 > 180 ? newAngle1 - 360 : newAngle1);
          var newAngle2 = angle2 + factor * 90;
          angles.second.push(newAngle2 > 180 ? newAngle2 - 360 : newAngle2);
        });
        var distance = (0, _distance.default)((0, _helpers.point)(p1), (0, _helpers.point)(p3)); // Draw imaginary right angle lines for both first and last points in lineString
        // If there is intersection point for any 2 lines, will be the 90 degree point.

        [0, 1, 2].forEach(function (indexFirst) {
          var line1 = (0, _helpers.lineString)([p1, (0, _destination.default)(p1, distance, angles.first[indexFirst]).geometry.coordinates]);
          [0, 1, 2].forEach(function (indexSecond) {
            var line2 = (0, _helpers.lineString)([p3, (0, _destination.default)(p3, distance, angles.second[indexSecond]).geometry.coordinates]);
            var fc = (0, _lineIntersect.default)(line1, line2);

            if (fc && fc.features.length) {
              // found the intersect point
              pt = fc.features[0].geometry.coordinates;
            }
          });
        });
      }

      return pt;
    }
  }]);

  return Draw90DegreePolygonMode;
}(_geojsonEditMode.BaseGeoJsonEditMode);

exports.Draw90DegreePolygonMode = Draw90DegreePolygonMode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZHJhdy05MGRlZ3JlZS1wb2x5Z29uLW1vZGUuanMiXSwibmFtZXMiOlsiRHJhdzkwRGVncmVlUG9seWdvbk1vZGUiLCJwcm9wcyIsImd1aWRlcyIsInR5cGUiLCJmZWF0dXJlcyIsImNsaWNrU2VxdWVuY2UiLCJnZXRDbGlja1NlcXVlbmNlIiwibGVuZ3RoIiwibGFzdFBvaW50ZXJNb3ZlRXZlbnQiLCJtYXBDb29yZHMiLCJwMyIsInAxIiwicDIiLCJ0ZW50YXRpdmVGZWF0dXJlIiwicHJvcGVydGllcyIsImd1aWRlVHlwZSIsImdlb21ldHJ5IiwiY29vcmRpbmF0ZXMiLCJwdXNoIiwiY29uY2F0Iiwic2xpY2UiLCJvblVwZGF0ZUN1cnNvciIsImV2ZW50IiwicGlja3MiLCJnZXRUZW50YXRpdmVHdWlkZSIsImFkZENsaWNrU2VxdWVuY2UiLCJsaW5lU3RyaW5nIiwicG9seWdvbiIsImNsaWNrZWRFZGl0SGFuZGxlIiwicG9zaXRpb25JbmRleGVzIiwicG9seWdvblRvQWRkIiwiZmluYWxpemVkQ29vcmRpbmF0ZXMiLCJyZXNldENsaWNrU2VxdWVuY2UiLCJlZGl0QWN0aW9uIiwiZ2V0QWRkRmVhdHVyZU9yQm9vbGVhblBvbHlnb25BY3Rpb24iLCJvbkVkaXQiLCJmYWtlUG9pbnRlck1vdmVFdmVudCIsInNjcmVlbkNvb3JkcyIsInBvaW50ZXJEb3duUGlja3MiLCJwb2ludGVyRG93blNjcmVlbkNvb3JkcyIsInBvaW50ZXJEb3duTWFwQ29vcmRzIiwiY2FuY2VsUGFuIiwic291cmNlRXZlbnQiLCJoYW5kbGVQb2ludGVyTW92ZSIsImNvb3JkcyIsInB0IiwiZ2V0SW50ZXJtZWRpYXRlUG9pbnQiLCJ0YyIsInNwbGljZSIsImFuZ2xlMSIsInA0IiwiYW5nbGUyIiwiYW5nbGVzIiwiZmlyc3QiLCJzZWNvbmQiLCJmb3JFYWNoIiwiZmFjdG9yIiwibmV3QW5nbGUxIiwibmV3QW5nbGUyIiwiZGlzdGFuY2UiLCJpbmRleEZpcnN0Iiwi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QUE2REMsV0FGbEMsQ0FBZixDQUFkO0FBSUEsV0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVXNDLE9BQVYsQ0FBa0IsVUFBQU8sV0FBVyxFQUFJO0FBQy9CLGdCQUFNQyxLQUFLLEdBQUcseUJBQWUsQ0FDM0JyRCxFQUQyQixFQUUzQiwwQkFBWUEsRUFBWixFQUFnQmlELFFBQWhCLEVBQTBCUCxNQUFNLENBQUNFLE1BQVAsQ0FBY1EsV0FBZCxDQUExQixFQUFzRDlDLFFBQXRELENBQStEQyxXQUZwQyxDQUFmLENBQWQ7QUFJQSxnQkFBTStDLEVBQUUsR0FBRyw0QkFBY0gsS0FBZCxFQUFxQkUsS0FBckIsQ0FBWDs7QUFDQSxnQkFBSUMsRUFBRSxJQUFJQSxFQUFFLENBQUM1RCxRQUFILENBQVlHLE1BQXRCLEVBQThCO0FBQzVCO0FBQ0FzQyxjQUFBQSxFQUFFLEdBQUdtQixFQUFFLENBQUM1RCxRQUFILENBQVksQ0FBWixFQUFlWSxRQUFmLENBQXdCQyxXQUE3QjtBQUNEO0FBQ0YsV0FWRDtBQVdELFNBaEJEO0FBaUJEOztBQUNELGFBQU80QixFQUFQO0FBQ0Q7Ozs7RUEzTDBDb0Isb0MiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQgZGVzdGluYXRpb24gZnJvbSAnQHR1cmYvZGVzdGluYXRpb24nO1xuaW1wb3J0IGJlYXJpbmcgZnJvbSAnQHR1cmYvYmVhcmluZyc7XG5pbXBvcnQgbGluZUludGVyc2VjdCBmcm9tICdAdHVyZi9saW5lLWludGVyc2VjdCc7XG5pbXBvcnQgdHVyZkRpc3RhbmNlIGZyb20gJ0B0dXJmL2Rpc3RhbmNlJztcbmltcG9ydCB7IHBvaW50LCBsaW5lU3RyaW5nIGFzIHR1cmZMaW5lU3RyaW5nIH0gZnJvbSAnQHR1cmYvaGVscGVycyc7XG5pbXBvcnQge1xuICBnZW5lcmF0ZVBvaW50c1BhcmFsbGVsVG9MaW5lUG9pbnRzLFxuICBnZXRQaWNrZWRFZGl0SGFuZGxlLFxuICBnZXRFZGl0SGFuZGxlc0Zvckdlb21ldHJ5XG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgQ2xpY2tFdmVudCwgUG9pbnRlck1vdmVFdmVudCwgTW9kZVByb3BzLCBHdWlkZUZlYXR1cmVDb2xsZWN0aW9uIH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHR5cGUgeyBQb2x5Z29uLCBMaW5lU3RyaW5nLCBQb3NpdGlvbiwgRmVhdHVyZUNvbGxlY3Rpb24gfSBmcm9tICcuLi9nZW9qc29uLXR5cGVzLmpzJztcbmltcG9ydCB7IEJhc2VHZW9Kc29uRWRpdE1vZGUgfSBmcm9tICcuL2dlb2pzb24tZWRpdC1tb2RlLmpzJztcblxuZXhwb3J0IGNsYXNzIERyYXc5MERlZ3JlZVBvbHlnb25Nb2RlIGV4dGVuZHMgQmFzZUdlb0pzb25FZGl0TW9kZSB7XG4gIGdldEd1aWRlcyhwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPik6IEd1aWRlRmVhdHVyZUNvbGxlY3Rpb24ge1xuICAgIGNvbnN0IGd1aWRlczogR3VpZGVGZWF0dXJlQ29sbGVjdGlvbiA9IHtcbiAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICBmZWF0dXJlczogW11cbiAgICB9O1xuXG4gICAgY29uc3QgY2xpY2tTZXF1ZW5jZSA9IHRoaXMuZ2V0Q2xpY2tTZXF1ZW5jZSgpO1xuXG4gICAgaWYgKGNsaWNrU2VxdWVuY2UubGVuZ3RoID09PSAwIHx8ICFwcm9wcy5sYXN0UG9pbnRlck1vdmVFdmVudCkge1xuICAgICAgcmV0dXJuIGd1aWRlcztcbiAgICB9XG4gICAgY29uc3QgeyBtYXBDb29yZHMgfSA9IHByb3BzLmxhc3RQb2ludGVyTW92ZUV2ZW50O1xuXG4gICAgbGV0IHAzO1xuICAgIGlmIChjbGlja1NlcXVlbmNlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcDMgPSBtYXBDb29yZHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHAxID0gY2xpY2tTZXF1ZW5jZVtjbGlja1NlcXVlbmNlLmxlbmd0aCAtIDJdO1xuICAgICAgY29uc3QgcDIgPSBjbGlja1NlcXVlbmNlW2NsaWNrU2VxdWVuY2UubGVuZ3RoIC0gMV07XG4gICAgICBbcDNdID0gZ2VuZXJhdGVQb2ludHNQYXJhbGxlbFRvTGluZVBvaW50cyhwMSwgcDIsIG1hcENvb3Jkcyk7XG4gICAgfVxuXG4gICAgbGV0IHRlbnRhdGl2ZUZlYXR1cmU7XG5cbiAgICBpZiAoY2xpY2tTZXF1ZW5jZS5sZW5ndGggPCAzKSB7XG4gICAgICAvLyBEcmF3IGEgTGluZVN0cmluZyBjb25uZWN0aW5nIGFsbCB0aGUgY2xpY2tlZCBwb2ludHMgd2l0aCB0aGUgaG92ZXJlZCBwb2ludFxuICAgICAgdGVudGF0aXZlRmVhdHVyZSA9IHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgZ3VpZGVUeXBlOiAndGVudGF0aXZlJ1xuICAgICAgICB9LFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAgICAgICAgICBjb29yZGluYXRlczogWy4uLmNsaWNrU2VxdWVuY2UsIHAzXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEcmF3IGEgUG9seWdvbiBjb25uZWN0aW5nIGFsbCB0aGUgY2xpY2tlZCBwb2ludHMgd2l0aCB0aGUgaG92ZXJlZCBwb2ludFxuICAgICAgdGVudGF0aXZlRmVhdHVyZSA9IHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgZ3VpZGVUeXBlOiAndGVudGF0aXZlJ1xuICAgICAgICB9LFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgIHR5cGU6ICdQb2x5Z29uJyxcbiAgICAgICAgICBjb29yZGluYXRlczogW1suLi5jbGlja1NlcXVlbmNlLCBwMywgY2xpY2tTZXF1ZW5jZVswXV1dXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZ3VpZGVzLmZlYXR1cmVzLnB1c2godGVudGF0aXZlRmVhdHVyZSk7XG5cbiAgICBndWlkZXMuZmVhdHVyZXMgPSBndWlkZXMuZmVhdHVyZXMuY29uY2F0KFxuICAgICAgZ2V0RWRpdEhhbmRsZXNGb3JHZW9tZXRyeSh0ZW50YXRpdmVGZWF0dXJlLmdlb21ldHJ5LCAtMSlcbiAgICApO1xuXG4gICAgLy8gU2xpY2Ugb2ZmIHRoZSBoYW5kbGVzIHRoYXQgYXJlIGFyZSBuZXh0IHRvIHRoZSBwb2ludGVyXG4gICAgZ3VpZGVzLmZlYXR1cmVzID0gZ3VpZGVzLmZlYXR1cmVzLnNsaWNlKDAsIC0xKTtcblxuICAgIHJldHVybiBndWlkZXM7XG4gIH1cblxuICBoYW5kbGVQb2ludGVyTW92ZSh7IG1hcENvb3JkcyB9OiBQb2ludGVyTW92ZUV2ZW50LCBwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPikge1xuICAgIHByb3BzLm9uVXBkYXRlQ3Vyc29yKCdjZWxsJyk7XG4gIH1cblxuICBoYW5kbGVDbGljayhldmVudDogQ2xpY2tFdmVudCwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pIHtcbiAgICBjb25zdCB7IHBpY2tzIH0gPSBldmVudDtcbiAgICBjb25zdCB0ZW50YXRpdmVGZWF0dXJlID0gdGhpcy5nZXRUZW50YXRpdmVHdWlkZShwcm9wcyk7XG4gICAgdGhpcy5hZGRDbGlja1NlcXVlbmNlKGV2ZW50KTtcbiAgICBjb25zdCBjbGlja1NlcXVlbmNlID0gdGhpcy5nZXRDbGlja1NlcXVlbmNlKCk7XG5cbiAgICBpZiAoIXRlbnRhdGl2ZUZlYXR1cmUpIHtcbiAgICAgIC8vIG5vdGhpbmcgZWxzZSB0byBkb1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjbGlja1NlcXVlbmNlLmxlbmd0aCA9PT0gMyAmJiB0ZW50YXRpdmVGZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgY29uc3QgbGluZVN0cmluZzogTGluZVN0cmluZyA9IHRlbnRhdGl2ZUZlYXR1cmUuZ2VvbWV0cnk7XG5cbiAgICAgIC8vIFR3ZWFrIHRoZSBjbGlja2VkIHBvc2l0aW9uIHRvIGJlIHRoZSBzbmFwcGVkIDkwIGRlZ3JlZSBwb2ludCBhbG9uZyB0aGUgcG9seWdvblxuICAgICAgY2xpY2tTZXF1ZW5jZVtjbGlja1NlcXVlbmNlLmxlbmd0aCAtIDFdID1cbiAgICAgICAgbGluZVN0cmluZy5jb29yZGluYXRlc1tsaW5lU3RyaW5nLmNvb3JkaW5hdGVzLmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSBpZiAoY2xpY2tTZXF1ZW5jZS5sZW5ndGggPiAzICYmIHRlbnRhdGl2ZUZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICBjb25zdCBwb2x5Z29uOiBQb2x5Z29uID0gdGVudGF0aXZlRmVhdHVyZS5nZW9tZXRyeTtcblxuICAgICAgLy8gVHdlYWsgdGhlIGNsaWNrZWQgcG9zaXRpb24gdG8gYmUgdGhlIHNuYXBwZWQgOTAgZGVncmVlIHBvaW50IGFsb25nIHRoZSBwb2x5Z29uXG4gICAgICBjbGlja1NlcXVlbmNlW2NsaWNrU2VxdWVuY2UubGVuZ3RoIC0gMV0gPVxuICAgICAgICBwb2x5Z29uLmNvb3JkaW5hdGVzWzBdW3BvbHlnb24uY29vcmRpbmF0ZXNbMF0ubGVuZ3RoIC0gMl07XG5cbiAgICAgIGNvbnN0IGNsaWNrZWRFZGl0SGFuZGxlID0gZ2V0UGlja2VkRWRpdEhhbmRsZShwaWNrcyk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgY2xpY2tlZEVkaXRIYW5kbGUgJiZcbiAgICAgICAgKGNsaWNrZWRFZGl0SGFuZGxlLnByb3BlcnRpZXMucG9zaXRpb25JbmRleGVzWzFdID09PSAwIHx8XG4gICAgICAgICAgY2xpY2tlZEVkaXRIYW5kbGUucHJvcGVydGllcy5wb3NpdGlvbkluZGV4ZXNbMV0gPT09IHBvbHlnb24uY29vcmRpbmF0ZXNbMF0ubGVuZ3RoIC0gMylcbiAgICAgICkge1xuICAgICAgICAvLyBUaGV5IGNsaWNrZWQgdGhlIGZpcnN0IG9yIGxhc3QgcG9pbnQgKG9yIGRvdWJsZS1jbGlja2VkKSwgc28gY29tcGxldGUgdGhlIHBvbHlnb25cbiAgICAgICAgY29uc3QgcG9seWdvblRvQWRkOiBQb2x5Z29uID0ge1xuICAgICAgICAgIHR5cGU6ICdQb2x5Z29uJyxcbiAgICAgICAgICBjb29yZGluYXRlczogdGhpcy5maW5hbGl6ZWRDb29yZGluYXRlcyhbLi4ucG9seWdvbi5jb29yZGluYXRlc1swXV0pXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZXNldENsaWNrU2VxdWVuY2UoKTtcblxuICAgICAgICBjb25zdCBlZGl0QWN0aW9uID0gdGhpcy5nZXRBZGRGZWF0dXJlT3JCb29sZWFuUG9seWdvbkFjdGlvbihwb2x5Z29uVG9BZGQsIHByb3BzKTtcbiAgICAgICAgaWYgKGVkaXRBY3Rpb24pIHtcbiAgICAgICAgICBwcm9wcy5vbkVkaXQoZWRpdEFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcmlnZ2VyIHBvaW50ZXIgbW92ZSByaWdodCBhd2F5IGluIG9yZGVyIGZvciBpdCB0byB1cGRhdGUgZWRpdCBoYW5kbGVzICh0byBzdXBwb3J0IGRvdWJsZS1jbGljaylcbiAgICBjb25zdCBmYWtlUG9pbnRlck1vdmVFdmVudCA9IHtcbiAgICAgIHNjcmVlbkNvb3JkczogWy0xLCAtMV0sXG4gICAgICBtYXBDb29yZHM6IGV2ZW50Lm1hcENvb3JkcyxcbiAgICAgIHBpY2tzOiBbXSxcbiAgICAgIHBvaW50ZXJEb3duUGlja3M6IG51bGwsXG4gICAgICBwb2ludGVyRG93blNjcmVlbkNvb3JkczogbnVsbCxcbiAgICAgIHBvaW50ZXJEb3duTWFwQ29vcmRzOiBudWxsLFxuICAgICAgY2FuY2VsUGFuOiAoKSA9PiB7fSxcbiAgICAgIHNvdXJjZUV2ZW50OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlKGZha2VQb2ludGVyTW92ZUV2ZW50LCBwcm9wcyk7XG4gIH1cblxuICBmaW5hbGl6ZWRDb29yZGluYXRlcyhjb29yZHM6IFBvc2l0aW9uW10pIHtcbiAgICAvLyBSZW1vdmUgdGhlIGhvdmVyZWQgcG9zaXRpb25cbiAgICBsZXQgY29vcmRpbmF0ZXMgPSBbWy4uLmNvb3Jkcy5zbGljZSgwLCAtMiksIGNvb3Jkc1swXV1dO1xuICAgIGxldCBwdCA9IHRoaXMuZ2V0SW50ZXJtZWRpYXRlUG9pbnQoWy4uLmNvb3Jkc10pO1xuICAgIGlmICghcHQpIHtcbiAgICAgIC8vIGlmIGludGVybWVkaWF0ZSBwb2ludCB3aXRoIDkwIGRlZ3JlZSBub3QgYXZhaWxhYmxlXG4gICAgICAvLyB0cnkgcmVtb3ZlIHRoZSBsYXN0IGNsaWNrZWQgcG9pbnQgYW5kIGdldCB0aGUgaW50ZXJtZWRpYXRlIHBvaW50LlxuICAgICAgY29uc3QgdGMgPSBbLi4uY29vcmRzXTtcbiAgICAgIHRjLnNwbGljZSgtMywgMSk7XG4gICAgICBwdCA9IHRoaXMuZ2V0SW50ZXJtZWRpYXRlUG9pbnQoWy4uLnRjXSk7XG4gICAgICBpZiAocHQpIHtcbiAgICAgICAgY29vcmRpbmF0ZXMgPSBbWy4uLmNvb3Jkcy5zbGljZSgwLCAtMyksIHB0LCBjb29yZHNbMF1dXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29vcmRpbmF0ZXMgPSBbWy4uLmNvb3Jkcy5zbGljZSgwLCAtMiksIHB0LCBjb29yZHNbMF1dXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICB9XG5cbiAgZ2V0SW50ZXJtZWRpYXRlUG9pbnQoY29vcmRpbmF0ZXM6IFBvc2l0aW9uW10pIHtcbiAgICBsZXQgcHQ7XG4gICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+IDQpIHtcbiAgICAgIGNvbnN0IFtwMSwgcDJdID0gWy4uLmNvb3JkaW5hdGVzXTtcbiAgICAgIGNvbnN0IGFuZ2xlMSA9IGJlYXJpbmcocDEsIHAyKTtcbiAgICAgIGNvbnN0IHAzID0gY29vcmRpbmF0ZXNbY29vcmRpbmF0ZXMubGVuZ3RoIC0gM107XG4gICAgICBjb25zdCBwNCA9IGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDRdO1xuICAgICAgY29uc3QgYW5nbGUyID0gYmVhcmluZyhwMywgcDQpO1xuXG4gICAgICBjb25zdCBhbmdsZXMgPSB7IGZpcnN0OiBbXSwgc2Vjb25kOiBbXSB9O1xuICAgICAgLy8gY2FsY3VsYXRlIDMgcmlnaHQgYW5nbGUgcG9pbnRzIGZvciBmaXJzdCBhbmQgbGFzdCBwb2ludHMgaW4gbGluZVN0cmluZ1xuICAgICAgWzEsIDIsIDNdLmZvckVhY2goZmFjdG9yID0+IHtcbiAgICAgICAgY29uc3QgbmV3QW5nbGUxID0gYW5nbGUxICsgZmFjdG9yICogOTA7XG4gICAgICAgIC8vIGNvbnZlcnQgYW5nbGVzIHRvIDAgdG8gLTE4MCBmb3IgYW50aS1jbG9jayBhbmQgMCB0byAxODAgZm9yIGNsb2NrIHdpc2VcbiAgICAgICAgYW5nbGVzLmZpcnN0LnB1c2gobmV3QW5nbGUxID4gMTgwID8gbmV3QW5nbGUxIC0gMzYwIDogbmV3QW5nbGUxKTtcbiAgICAgICAgY29uc3QgbmV3QW5nbGUyID0gYW5nbGUyICsgZmFjdG9yICogOTA7XG4gICAgICAgIGFuZ2xlcy5zZWNvbmQucHVzaChuZXdBbmdsZTIgPiAxODAgPyBuZXdBbmdsZTIgLSAzNjAgOiBuZXdBbmdsZTIpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gdHVyZkRpc3RhbmNlKHBvaW50KHAxKSwgcG9pbnQocDMpKTtcbiAgICAgIC8vIERyYXcgaW1hZ2luYXJ5IHJpZ2h0IGFuZ2xlIGxpbmVzIGZvciBib3RoIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBpbiBsaW5lU3RyaW5nXG4gICAgICAvLyBJZiB0aGVyZSBpcyBpbnRlcnNlY3Rpb24gcG9pbnQgZm9yIGFueSAyIGxpbmVzLCB3aWxsIGJlIHRoZSA5MCBkZWdyZWUgcG9pbnQuXG4gICAgICBbMCwgMSwgMl0uZm9yRWFjaChpbmRleEZpcnN0ID0+IHtcbiAgICAgICAgY29uc3QgbGluZTEgPSB0dXJmTGluZVN0cmluZyhbXG4gICAgICAgICAgcDEsXG4gICAgICAgICAgZGVzdGluYXRpb24ocDEsIGRpc3RhbmNlLCBhbmdsZXMuZmlyc3RbaW5kZXhGaXJzdF0pLmdlb21ldHJ5LmNvb3JkaW5hdGVzXG4gICAgICAgIF0pO1xuICAgICAgICBbMCwgMSwgMl0uZm9yRWFjaChpbmRleFNlY29uZCA9PiB7XG4gICAgICAgICAgY29uc3QgbGluZTIgPSB0dXJmTGluZVN0cmluZyhbXG4gICAgICAgICAgICBwMyxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uKHAzLCBkaXN0YW5jZSwgYW5nbGVzLnNlY29uZFtpbmRleFNlY29uZF0pLmdlb21ldHJ5LmNvb3JkaW5hdGVzXG4gICAgICAgICAgXSk7XG4gICAgICAgICAgY29uc3QgZmMgPSBsaW5lSW50ZXJzZWN0KGxpbmUxLCBsaW5lMik7XG4gICAgICAgICAgaWYgKGZjICYmIGZjLmZlYXR1cmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gZm91bmQgdGhlIGludGVyc2VjdCBwb2ludFxuICAgICAgICAgICAgcHQgPSBmYy5mZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwdDtcbiAgfVxufVxuIl19