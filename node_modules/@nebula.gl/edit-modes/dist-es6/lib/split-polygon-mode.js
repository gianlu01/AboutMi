"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SplitPolygonMode = void 0;

var _booleanPointInPolygon = _interopRequireDefault(require("@turf/boolean-point-in-polygon"));

var _difference = _interopRequireDefault(require("@turf/difference"));

var _buffer = _interopRequireDefault(require("@turf/buffer"));

var _lineIntersect = _interopRequireDefault(require("@turf/line-intersect"));

var _helpers = require("@turf/helpers");

var _bearing = _interopRequireDefault(require("@turf/bearing"));

var _distance = _interopRequireDefault(require("@turf/distance"));

var _destination = _interopRequireDefault(require("@turf/destination"));

var _polygonToLine = _interopRequireDefault(require("@turf/polygon-to-line"));

var _nearestPointOnLine = _interopRequireDefault(require("@turf/nearest-point-on-line"));

var _utils = require("../utils.js");

var _geojsonEditMode = require("./geojson-edit-mode.js");

var _immutableFeatureCollection = require("./immutable-feature-collection.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var SplitPolygonMode =
/*#__PURE__*/
function (_BaseGeoJsonEditMode) {
  _inherits(SplitPolygonMode, _BaseGeoJsonEditMode);

  function SplitPolygonMode() {
    _classCallCheck(this, SplitPolygonMode);

    return _possibleConstructorReturn(this, _getPrototypeOf(SplitPolygonMode).apply(this, arguments));
  }

  _createClass(SplitPolygonMode, [{
    key: "calculateMapCoords",
    value: function calculateMapCoords(clickSequence, mapCoords, props) {
      var modeConfig = props.modeConfig;

      if (!modeConfig || !modeConfig.lock90Degree || !clickSequence.length) {
        return mapCoords;
      }

      if (clickSequence.length === 1) {
        // if first point is clicked, then find closest polygon point and build ~90deg vector
        var firstPoint = clickSequence[0];
        var selectedGeometry = this.getSelectedGeometry(props);
        var feature = (0, _polygonToLine.default)(selectedGeometry);
        var lines = feature.type === 'FeatureCollection' ? feature.features : [feature];
        var minDistance = Number.MAX_SAFE_INTEGER;
        var closestPoint = null; // If Multipolygon, then we should find nearest polygon line and stick split to it.

        lines.forEach(function (line) {
          var snapPoint = (0, _nearestPointOnLine.default)(line, firstPoint);
          var distanceFromOrigin = (0, _distance.default)(snapPoint, firstPoint);

          if (minDistance > distanceFromOrigin) {
            minDistance = distanceFromOrigin;
            closestPoint = snapPoint;
          }
        });

        if (closestPoint) {
          // closest point is used as 90degree entry to the polygon
          var lastBearing = (0, _bearing.default)(firstPoint, closestPoint);
          var currentDistance = (0, _distance.default)(firstPoint, mapCoords, {
            units: 'meters'
          });
          return (0, _destination.default)(firstPoint, currentDistance, lastBearing, {
            units: 'meters'
          }).geometry.coordinates;
        }

        return mapCoords;
      } // Allow only 90 degree turns


      var lastPoint = clickSequence[clickSequence.length - 1];

      var _generatePointsParall = (0, _utils.generatePointsParallelToLinePoints)(clickSequence[clickSequence.length - 2], lastPoint, mapCoords),
          _generatePointsParall2 = _slicedToArray(_generatePointsParall, 1),
          approximatePoint = _generatePointsParall2[0]; // align point with current ground


      var nearestPt = (0, _nearestPointOnLine.default)((0, _helpers.lineString)([lastPoint, approximatePoint]), mapCoords).geometry.coordinates;
      return nearestPt;
    }
  }, {
    key: "getGuides",
    value: function getGuides(props) {
      var clickSequence = this.getClickSequence();
      var guides = {
        type: 'FeatureCollection',
        features: []
      };

      if (clickSequence.length === 0 || !props.lastPointerMoveEvent) {
        // nothing to do yet
        return guides;
      }

      var mapCoords = props.lastPointerMoveEvent.mapCoords;
      guides.features.push({
        type: 'Feature',
        properties: {
          guideType: 'tentative'
        },
        geometry: {
          type: 'LineString',
          coordinates: _toConsumableArray(clickSequence).concat([this.calculateMapCoords(clickSequence, mapCoords, props)])
        }
      });
      return guides;
    }
  }, {
    key: "handleClick",
    value: function handleClick(event, props) {
      var tentativeFeature = this.getTentativeGuide(props);
      var selectedGeometry = this.getSelectedGeometry(props);

      if (!selectedGeometry) {
        // eslint-disable-next-line no-console,no-undef
        console.warn('A polygon must be selected for splitting');
        return;
      }

      var clickSequence = this.getClickSequence();

      if (tentativeFeature && tentativeFeature.geometry.type === 'LineString') {
        clickSequence.push(tentativeFeature.geometry.coordinates[tentativeFeature.geometry.coordinates.length - 1]);
      } else {
        this.addClickSequence(event);
      }

      var pt = {
        type: 'Point',
        coordinates: clickSequence[clickSequence.length - 1]
      };
      var isPointInPolygon = (0, _booleanPointInPolygon.default)(pt, selectedGeometry);

      if (clickSequence.length > 1 && tentativeFeature && !isPointInPolygon) {
        this.resetClickSequence();
        var isLineInterectingWithPolygon = (0, _lineIntersect.default)(tentativeFeature, selectedGeometry);

        if (isLineInterectingWithPolygon.features.length === 0) {
          return;
        }

        var editAction = this.splitPolygon(tentativeFeature, props);

        if (editAction) {
          props.onEdit(editAction);
        }
      }
    }
  }, {
    key: "handlePointerMove",
    value: function handlePointerMove(event, props) {
      props.onUpdateCursor('cell');
    }
  }, {
    key: "splitPolygon",
    value: function splitPolygon(tentativeFeature, props) {
      var selectedGeometry = this.getSelectedGeometry(props);
      var featureIndex = props.selectedIndexes[0];
      var modeConfig = props.modeConfig || {}; // Default gap in between the polygon

      var _modeConfig$gap = modeConfig.gap,
          gap = _modeConfig$gap === void 0 ? 0.1 : _modeConfig$gap,
          _modeConfig$units = modeConfig.units,
          units = _modeConfig$units === void 0 ? 'centimeters' : _modeConfig$units;

      if (gap === 0) {
        gap = 0.1;
        units = 'centimeters';
      }

      var buffer = (0, _buffer.default)(tentativeFeature, gap, {
        units: units
      });
      var updatedGeometry = (0, _difference.default)(selectedGeometry, buffer);

      if (!updatedGeometry) {
        // eslint-disable-next-line no-console,no-undef
        console.warn('Canceling edit. Split Polygon erased');
        return null;
      }

      var _updatedGeometry$geom = updatedGeometry.geometry,
          type = _updatedGeometry$geom.type,
          coordinates = _updatedGeometry$geom.coordinates;
      var updatedCoordinates = [];

      if (type === 'Polygon') {
        // Update the coordinates as per Multipolygon
        updatedCoordinates = coordinates.map(function (c) {
          return [c];
        });
      } else {
        // Handle Case when Multipolygon has holes
        updatedCoordinates = coordinates.reduce(function (agg, prev) {
          prev.forEach(function (p) {
            agg.push([p]);
          });
          return agg;
        }, []);
      } // Update the type to Mulitpolygon


      var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replaceGeometry(featureIndex, {
        type: 'MultiPolygon',
        coordinates: updatedCoordinates
      });
      var editAction = {
        updatedData: updatedData.getObject(),
        editType: 'split',
        editContext: {
          featureIndexes: [featureIndex]
        }
      };
      return editAction;
    }
  }]);

  return SplitPolygonMode;
}(_geojsonEditMode.BaseGeoJsonEditMode);

exports.SplitPolygonMode = SplitPolygonMode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvc3BsaXQtcG9seWdvbi1tb2RlLmpzIl0sIm5hbWVzIjpbIlNwbGl0UG9seWdvbk1vZGUiLCJjbGlja1NlcXVlbmNlIiwibWFwQ29vcmRzIiwicHJvcHMiLCJtb2RlQ29uZmlnIiwibG9jazkwRGVncmVlIiwibGVuZ3RoIiwiZmlyc3RQb2ludCIsInNlbGVjdGVkR2VvbWV0cnkiLCJnZXRTZWxlY3RlZEdlb21ldHJ5IiwiZmVhdHVyZSIsImxpbmVzIiwidHlwZSIsImZlYXR1cmVzIiwibWluRGlzdGFuY2UiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiY2xvc2VzdFBvaW50IiwiZm9yRWFjaCIsImxpbmUiLCJzbmFwUG9pbnQiLCJkaXN0YW5jZUZyb21PcmlnaW4iLCJsYXN0QmVhcmluZyIsImN1cnJlbnREaXN0YW5jZSIsInVuaXRzIiwiZ2VvbWV0cnkiLCJjb29yZGluYXRlcyIsImxhc3RQb2ludCIsImFwcHJveGltYXRlUG9pbnQiLCJuZWFyZXN0UHQiLCJnZXRDbGlja1NlcXVlbmNlIiwiZ3VpZGVzIiwibGFzdFBvaW50ZXJNb3ZlRXZlbnQiLCJwdXNoIiwicHJvcGVydGllcyIsImd1aWRlVHlwZSIsImNhbGN1bGF0ZU1hcENvb3JkcyIsImV2ZW50IiwidGVudGF0aXZlRmVhdHVyZSIsImdldFRlbnRhdGl2ZUd1aWRlIiwiY29uc29sZSIsIndhcm4iLCJhZGRDbGlja1NlcXVlbmNlIiwicHQiLCJpc1BvaW50SW5Qb2x5Z29uIiwicmVzZXRDbGlja1NlcXVlbmNlIiwiaXNMaW5lSW50ZXJlY3RpbmdXaXRoUG9seWdvbiIsImVkaXRBY3Rpb24iLCJzcGxpdFBvbHlnb24iLCJvbkVkaXQiLCJvblVwZGF0ZUN1cnNvciIsImZlYXR1cmVJbmRleCIsInNlbGVjdGVkSW5kZXhlcyIsImdhcCIsImJ1ZmZlciIsInVwZGF0ZWRHZW9tZXRyeSIsInVwZGF0ZWRDb29yZGluYXRlcyIsIm1hcCIsImMiLCJyZWR1Y2UiLCJhZ2ciLCJwcmV2IiwicCIsInVwZGF0ZWREYXRhIiwiSW1tdXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24iLCJkYXRhIiwicmVwbGFjZUdlb21ldHJ5IiwiZ2V0T2JqZWN0IiwiZWRpdFR5cGUiLCJlZGl0Q29udGV4dCIsImZlYXR1cmVJbmRleGVzIiwiQmFzZUdlb0pzb25FZGl0TW9kZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQVNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUVhQSxnQjs7Ozs7Ozs7Ozs7Ozt1Q0FDUUMsYSxFQUFvQkMsUyxFQUFnQkMsSyxFQUFxQztBQUMxRixVQUFNQyxVQUFVLEdBQUdELEtBQUssQ0FBQ0MsVUFBekI7O0FBQ0EsVUFBSSxDQUFDQSxVQUFELElBQWUsQ0FBQ0EsVUFBVSxDQUFDQyxZQUEzQixJQUEyQyxDQUFDSixhQUFhLENBQUNLLE1BQTlELEVBQXNFO0FBQ3BFLGVBQU9KLFNBQVA7QUFDRDs7QUFDRCxVQUFJRCxhQUFhLENBQUNLLE1BQWQsS0FBeUIsQ0FBN0IsRUFBZ0M7QUFDOUI7QUFDQSxZQUFNQyxVQUFVLEdBQUdOLGFBQWEsQ0FBQyxDQUFELENBQWhDO0FBQ0EsWUFBTU8sZ0JBQWdCLEdBQUcsS0FBS0MsbUJBQUwsQ0FBeUJOLEtBQXpCLENBQXpCO0FBQ0EsWUFBTU8sT0FBTyxHQUFHLDRCQUFrQkYsZ0JBQWxCLENBQWhCO0FBRUEsWUFBTUcsS0FBSyxHQUFHRCxPQUFPLENBQUNFLElBQVIsS0FBaUIsbUJBQWpCLEdBQXVDRixPQUFPLENBQUNHLFFBQS9DLEdBQTBELENBQUNILE9BQUQsQ0FBeEU7QUFDQSxZQUFJSSxXQUFXLEdBQUdDLE1BQU0sQ0FBQ0MsZ0JBQXpCO0FBQ0EsWUFBSUMsWUFBWSxHQUFHLElBQW5CLENBUjhCLENBUzlCOztBQUNBTixRQUFBQSxLQUFLLENBQUNPLE9BQU4sQ0FBYyxVQUFBQyxJQUFJ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Q0FBQztBQUFBLGlCQUFJLENBQUNBLENBQUQsQ0FBSjtBQUFBLFNBQWpCLENBQXJCO0FBQ0QsT0FIRCxNQUdPO0FBQ0w7QUFDQUYsUUFBQUEsa0JBQWtCLEdBQUc5QixXQUFXLENBQUNpQyxNQUFaLENBQW1CLFVBQUNDLEdBQUQsRUFBTUMsSUFBTixFQUFlO0FBQ3JEQSxVQUFBQSxJQUFJLENBQUMzQyxPQUFMLENBQWEsVUFBQTRDLENBQUMsRUFBSTtBQUNoQkYsWUFBQUEsR0FBRyxDQUFDM0IsSUFBSixDQUFTLENBQUM2QixDQUFELENBQVQ7QUFDRCxXQUZEO0FBR0EsaUJBQU9GLEdBQVA7QUFDRCxTQUxvQixFQUtsQixFQUxrQixDQUFyQjtBQU1ELE9BakNtRixDQW1DcEY7OztBQUNBLFVBQU1HLFdBQVcsR0FBRyxJQUFJQyxzREFBSixDQUErQjdELEtBQUssQ0FBQzhELElBQXJDLEVBQTJDQyxlQUEzQyxDQUEyRGYsWUFBM0QsRUFBeUU7QUFDM0Z2QyxRQUFBQSxJQUFJLEVBQUUsY0FEcUY7QUFFM0ZjLFFBQUFBLFdBQVcsRUFBRThCO0FBRjhFLE9BQXpFLENBQXBCO0FBS0EsVUFBTVQsVUFBNkIsR0FBRztBQUNwQ2dCLFFBQUFBLFdBQVcsRUFBRUEsV0FBVyxDQUFDSSxTQUFaLEVBRHVCO0FBRXBDQyxRQUFBQSxRQUFRLEVBQUUsT0FGMEI7QUFHcENDLFFBQUFBLFdBQVcsRUFBRTtBQUNYQyxVQUFBQSxjQUFjLEVBQUUsQ0FBQ25CLFlBQUQ7QUFETDtBQUh1QixPQUF0QztBQVFBLGFBQU9KLFVBQVA7QUFDRDs7OztFQTNLbUN3QixvQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCBib29sZWFuUG9pbnRJblBvbHlnb24gZnJvbSAnQHR1cmYvYm9vbGVhbi1wb2ludC1pbi1wb2x5Z29uJztcbmltcG9ydCB0dXJmRGlmZmVyZW5jZSBmcm9tICdAdHVyZi9kaWZmZXJlbmNlJztcbmltcG9ydCB0dXJmQnVmZmVyIGZyb20gJ0B0dXJmL2J1ZmZlcic7XG5pbXBvcnQgbGluZUludGVyc2VjdCBmcm9tICdAdHVyZi9saW5lLWludGVyc2VjdCc7XG5pbXBvcnQgeyBsaW5lU3RyaW5nIH0gZnJvbSAnQHR1cmYvaGVscGVycyc7XG5pbXBvcnQgdHVyZkJlYXJpbmcgZnJvbSAnQHR1cmYvYmVhcmluZyc7XG5pbXBvcnQgdHVyZkRpc3RhbmNlIGZyb20gJ0B0dXJmL2Rpc3RhbmNlJztcbmltcG9ydCB0dXJmRGVzdGluYXRpb24gZnJvbSAnQHR1cmYvZGVzdGluYXRpb24nO1xuaW1wb3J0IHR1cmZQb2x5Z29uVG9MaW5lIGZyb20gJ0B0dXJmL3BvbHlnb24tdG8tbGluZSc7XG5pbXBvcnQgbmVhcmVzdFBvaW50T25MaW5lIGZyb20gJ0B0dXJmL25lYXJlc3QtcG9pbnQtb24tbGluZSc7XG5pbXBvcnQgeyBnZW5lcmF0ZVBvaW50c1BhcmFsbGVsVG9MaW5lUG9pbnRzIH0gZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHR5cGUgeyBGZWF0dXJlQ29sbGVjdGlvbiB9IGZyb20gJy4uL2dlb2pzb24tdHlwZXMuanMnO1xuaW1wb3J0IHR5cGUge1xuICBDbGlja0V2ZW50LFxuICBQb2ludGVyTW92ZUV2ZW50LFxuICBNb2RlUHJvcHMsXG4gIEd1aWRlRmVhdHVyZUNvbGxlY3Rpb24sXG4gIFRlbnRhdGl2ZUZlYXR1cmVcbn0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHsgQmFzZUdlb0pzb25FZGl0TW9kZSwgdHlwZSBHZW9Kc29uRWRpdEFjdGlvbiB9IGZyb20gJy4vZ2VvanNvbi1lZGl0LW1vZGUuanMnO1xuaW1wb3J0IHsgSW1tdXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24gfSBmcm9tICcuL2ltbXV0YWJsZS1mZWF0dXJlLWNvbGxlY3Rpb24uanMnO1xuXG5leHBvcnQgY2xhc3MgU3BsaXRQb2x5Z29uTW9kZSBleHRlbmRzIEJhc2VHZW9Kc29uRWRpdE1vZGUge1xuICBjYWxjdWxhdGVNYXBDb29yZHMoY2xpY2tTZXF1ZW5jZTogYW55LCBtYXBDb29yZHM6IGFueSwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pIHtcbiAgICBjb25zdCBtb2RlQ29uZmlnID0gcHJvcHMubW9kZUNvbmZpZztcbiAgICBpZiAoIW1vZGVDb25maWcgfHwgIW1vZGVDb25maWcubG9jazkwRGVncmVlIHx8ICFjbGlja1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG1hcENvb3JkcztcbiAgICB9XG4gICAgaWYgKGNsaWNrU2VxdWVuY2UubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBpZiBmaXJzdCBwb2ludCBpcyBjbGlja2VkLCB0aGVuIGZpbmQgY2xvc2VzdCBwb2x5Z29uIHBvaW50IGFuZCBidWlsZCB+OTBkZWcgdmVjdG9yXG4gICAgICBjb25zdCBmaXJzdFBvaW50ID0gY2xpY2tTZXF1ZW5jZVswXTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkR2VvbWV0cnkgPSB0aGlzLmdldFNlbGVjdGVkR2VvbWV0cnkocHJvcHMpO1xuICAgICAgY29uc3QgZmVhdHVyZSA9IHR1cmZQb2x5Z29uVG9MaW5lKHNlbGVjdGVkR2VvbWV0cnkpO1xuXG4gICAgICBjb25zdCBsaW5lcyA9IGZlYXR1cmUudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJyA/IGZlYXR1cmUuZmVhdHVyZXMgOiBbZmVhdHVyZV07XG4gICAgICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgIGxldCBjbG9zZXN0UG9pbnQgPSBudWxsO1xuICAgICAgLy8gSWYgTXVsdGlwb2x5Z29uLCB0aGVuIHdlIHNob3VsZCBmaW5kIG5lYXJlc3QgcG9seWdvbiBsaW5lIGFuZCBzdGljayBzcGxpdCB0byBpdC5cbiAgICAgIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgIGNvbnN0IHNuYXBQb2ludCA9IG5lYXJlc3RQb2ludE9uTGluZShsaW5lLCBmaXJzdFBvaW50KTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VGcm9tT3JpZ2luID0gdHVyZkRpc3RhbmNlKHNuYXBQb2ludCwgZmlyc3RQb2ludCk7XG4gICAgICAgIGlmIChtaW5EaXN0YW5jZSA+IGRpc3RhbmNlRnJvbU9yaWdpbikge1xuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2VGcm9tT3JpZ2luO1xuICAgICAgICAgIGNsb3Nlc3RQb2ludCA9IHNuYXBQb2ludDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChjbG9zZXN0UG9pbnQpIHtcbiAgICAgICAgLy8gY2xvc2VzdCBwb2ludCBpcyB1c2VkIGFzIDkwZGVncmVlIGVudHJ5IHRvIHRoZSBwb2x5Z29uXG4gICAgICAgIGNvbnN0IGxhc3RCZWFyaW5nID0gdHVyZkJlYXJpbmcoZmlyc3RQb2ludCwgY2xvc2VzdFBvaW50KTtcbiAgICAgICAgY29uc3QgY3VycmVudERpc3RhbmNlID0gdHVyZkRpc3RhbmNlKGZpcnN0UG9pbnQsIG1hcENvb3JkcywgeyB1bml0czogJ21ldGVycycgfSk7XG4gICAgICAgIHJldHVybiB0dXJmRGVzdGluYXRpb24oZmlyc3RQb2ludCwgY3VycmVudERpc3RhbmNlLCBsYXN0QmVhcmluZywge1xuICAgICAgICAgIHVuaXRzOiAnbWV0ZXJzJ1xuICAgICAgICB9KS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXBDb29yZHM7XG4gICAgfVxuICAgIC8vIEFsbG93IG9ubHkgOTAgZGVncmVlIHR1cm5zXG4gICAgY29uc3QgbGFzdFBvaW50ID0gY2xpY2tTZXF1ZW5jZVtjbGlja1NlcXVlbmNlLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IFthcHByb3hpbWF0ZVBvaW50XSA9IGdlbmVyYXRlUG9pbnRzUGFyYWxsZWxUb0xpbmVQb2ludHMoXG4gICAgICBjbGlja1NlcXVlbmNlW2NsaWNrU2VxdWVuY2UubGVuZ3RoIC0gMl0sXG4gICAgICBsYXN0UG9pbnQsXG4gICAgICBtYXBDb29yZHNcbiAgICApO1xuICAgIC8vIGFsaWduIHBvaW50IHdpdGggY3VycmVudCBncm91bmRcbiAgICBjb25zdCBuZWFyZXN0UHQgPSBuZWFyZXN0UG9pbnRPbkxpbmUobGluZVN0cmluZyhbbGFzdFBvaW50LCBhcHByb3hpbWF0ZVBvaW50XSksIG1hcENvb3JkcylcbiAgICAgIC5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICByZXR1cm4gbmVhcmVzdFB0O1xuICB9XG5cbiAgZ2V0R3VpZGVzKHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KTogR3VpZGVGZWF0dXJlQ29sbGVjdGlvbiB7XG4gICAgY29uc3QgY2xpY2tTZXF1ZW5jZSA9IHRoaXMuZ2V0Q2xpY2tTZXF1ZW5jZSgpO1xuXG4gICAgY29uc3QgZ3VpZGVzOiBHdWlkZUZlYXR1cmVDb2xsZWN0aW9uID0ge1xuICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgIGZlYXR1cmVzOiBbXVxuICAgIH07XG5cbiAgICBpZiAoY2xpY2tTZXF1ZW5jZS5sZW5ndGggPT09IDAgfHwgIXByb3BzLmxhc3RQb2ludGVyTW92ZUV2ZW50KSB7XG4gICAgICAvLyBub3RoaW5nIHRvIGRvIHlldFxuICAgICAgcmV0dXJuIGd1aWRlcztcbiAgICB9XG5cbiAgICBjb25zdCB7IG1hcENvb3JkcyB9ID0gcHJvcHMubGFzdFBvaW50ZXJNb3ZlRXZlbnQ7XG5cbiAgICBndWlkZXMuZmVhdHVyZXMucHVzaCh7XG4gICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGd1aWRlVHlwZTogJ3RlbnRhdGl2ZSdcbiAgICAgIH0sXG4gICAgICBnZW9tZXRyeToge1xuICAgICAgICB0eXBlOiAnTGluZVN0cmluZycsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBbLi4uY2xpY2tTZXF1ZW5jZSwgdGhpcy5jYWxjdWxhdGVNYXBDb29yZHMoY2xpY2tTZXF1ZW5jZSwgbWFwQ29vcmRzLCBwcm9wcyldXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZ3VpZGVzO1xuICB9XG5cbiAgaGFuZGxlQ2xpY2soZXZlbnQ6IENsaWNrRXZlbnQsIHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KSB7XG4gICAgY29uc3QgdGVudGF0aXZlRmVhdHVyZSA9IHRoaXMuZ2V0VGVudGF0aXZlR3VpZGUocHJvcHMpO1xuXG4gICAgY29uc3Qgc2VsZWN0ZWRHZW9tZXRyeSA9IHRoaXMuZ2V0U2VsZWN0ZWRHZW9tZXRyeShwcm9wcyk7XG5cbiAgICBpZiAoIXNlbGVjdGVkR2VvbWV0cnkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlLG5vLXVuZGVmXG4gICAgICBjb25zb2xlLndhcm4oJ0EgcG9seWdvbiBtdXN0IGJlIHNlbGVjdGVkIGZvciBzcGxpdHRpbmcnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjbGlja1NlcXVlbmNlID0gdGhpcy5nZXRDbGlja1NlcXVlbmNlKCk7XG4gICAgaWYgKHRlbnRhdGl2ZUZlYXR1cmUgJiYgdGVudGF0aXZlRmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycpIHtcbiAgICAgIGNsaWNrU2VxdWVuY2UucHVzaChcbiAgICAgICAgdGVudGF0aXZlRmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc1t0ZW50YXRpdmVGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aCAtIDFdXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZENsaWNrU2VxdWVuY2UoZXZlbnQpO1xuICAgIH1cblxuICAgIGNvbnN0IHB0ID0ge1xuICAgICAgdHlwZTogJ1BvaW50JyxcbiAgICAgIGNvb3JkaW5hdGVzOiBjbGlja1NlcXVlbmNlW2NsaWNrU2VxdWVuY2UubGVuZ3RoIC0gMV1cbiAgICB9O1xuICAgIGNvbnN0IGlzUG9pbnRJblBvbHlnb24gPSBib29sZWFuUG9pbnRJblBvbHlnb24ocHQsIHNlbGVjdGVkR2VvbWV0cnkpO1xuICAgIGlmIChjbGlja1NlcXVlbmNlLmxlbmd0aCA+IDEgJiYgdGVudGF0aXZlRmVhdHVyZSAmJiAhaXNQb2ludEluUG9seWdvbikge1xuICAgICAgdGhpcy5yZXNldENsaWNrU2VxdWVuY2UoKTtcbiAgICAgIGNvbnN0IGlzTGluZUludGVyZWN0aW5nV2l0aFBvbHlnb24gPSBsaW5lSW50ZXJzZWN0KHRlbnRhdGl2ZUZlYXR1cmUsIHNlbGVjdGVkR2VvbWV0cnkpO1xuICAgICAgaWYgKGlzTGluZUludGVyZWN0aW5nV2l0aFBvbHlnb24uZmVhdHVyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZWRpdEFjdGlvbiA9IHRoaXMuc3BsaXRQb2x5Z29uKHRlbnRhdGl2ZUZlYXR1cmUsIHByb3BzKTtcblxuICAgICAgaWYgKGVkaXRBY3Rpb24pIHtcbiAgICAgICAgcHJvcHMub25FZGl0KGVkaXRBY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVBvaW50ZXJNb3ZlKGV2ZW50OiBQb2ludGVyTW92ZUV2ZW50LCBwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPikge1xuICAgIHByb3BzLm9uVXBkYXRlQ3Vyc29yKCdjZWxsJyk7XG4gIH1cblxuICBzcGxpdFBvbHlnb24odGVudGF0aXZlRmVhdHVyZTogVGVudGF0aXZlRmVhdHVyZSwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pIHtcbiAgICBjb25zdCBzZWxlY3RlZEdlb21ldHJ5ID0gdGhpcy5nZXRTZWxlY3RlZEdlb21ldHJ5KHByb3BzKTtcbiAgICBjb25zdCBmZWF0dXJlSW5kZXggPSBwcm9wcy5zZWxlY3RlZEluZGV4ZXNbMF07XG4gICAgY29uc3QgbW9kZUNvbmZpZyA9IHByb3BzLm1vZGVDb25maWcgfHwge307XG5cbiAgICAvLyBEZWZhdWx0IGdhcCBpbiBiZXR3ZWVuIHRoZSBwb2x5Z29uXG4gICAgbGV0IHsgZ2FwID0gMC4xLCB1bml0cyA9ICdjZW50aW1ldGVycycgfSA9IG1vZGVDb25maWc7XG4gICAgaWYgKGdhcCA9PT0gMCkge1xuICAgICAgZ2FwID0gMC4xO1xuICAgICAgdW5pdHMgPSAnY2VudGltZXRlcnMnO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IHR1cmZCdWZmZXIodGVudGF0aXZlRmVhdHVyZSwgZ2FwLCB7IHVuaXRzIH0pO1xuICAgIGNvbnN0IHVwZGF0ZWRHZW9tZXRyeSA9IHR1cmZEaWZmZXJlbmNlKHNlbGVjdGVkR2VvbWV0cnksIGJ1ZmZlcik7XG4gICAgaWYgKCF1cGRhdGVkR2VvbWV0cnkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlLG5vLXVuZGVmXG4gICAgICBjb25zb2xlLndhcm4oJ0NhbmNlbGluZyBlZGl0LiBTcGxpdCBQb2x5Z29uIGVyYXNlZCcpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgeyB0eXBlLCBjb29yZGluYXRlcyB9ID0gdXBkYXRlZEdlb21ldHJ5Lmdlb21ldHJ5O1xuICAgIGxldCB1cGRhdGVkQ29vcmRpbmF0ZXMgPSBbXTtcbiAgICBpZiAodHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIGNvb3JkaW5hdGVzIGFzIHBlciBNdWx0aXBvbHlnb25cbiAgICAgIHVwZGF0ZWRDb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzLm1hcChjID0+IFtjXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEhhbmRsZSBDYXNlIHdoZW4gTXVsdGlwb2x5Z29uIGhhcyBob2xlc1xuICAgICAgdXBkYXRlZENvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXMucmVkdWNlKChhZ2csIHByZXYpID0+IHtcbiAgICAgICAgcHJldi5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgIGFnZy5wdXNoKFtwXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYWdnO1xuICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgdHlwZSB0byBNdWxpdHBvbHlnb25cbiAgICBjb25zdCB1cGRhdGVkRGF0YSA9IG5ldyBJbW11dGFibGVGZWF0dXJlQ29sbGVjdGlvbihwcm9wcy5kYXRhKS5yZXBsYWNlR2VvbWV0cnkoZmVhdHVyZUluZGV4LCB7XG4gICAgICB0eXBlOiAnTXVsdGlQb2x5Z29uJyxcbiAgICAgIGNvb3JkaW5hdGVzOiB1cGRhdGVkQ29vcmRpbmF0ZXNcbiAgICB9KTtcblxuICAgIGNvbnN0IGVkaXRBY3Rpb246IEdlb0pzb25FZGl0QWN0aW9uID0ge1xuICAgICAgdXBkYXRlZERhdGE6IHVwZGF0ZWREYXRhLmdldE9iamVjdCgpLFxuICAgICAgZWRpdFR5cGU6ICdzcGxpdCcsXG4gICAgICBlZGl0Q29udGV4dDoge1xuICAgICAgICBmZWF0dXJlSW5kZXhlczogW2ZlYXR1cmVJbmRleF1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGVkaXRBY3Rpb247XG4gIH1cbn1cbiJdfQ==