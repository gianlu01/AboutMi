"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getIntermediatePosition = getIntermediatePosition;
exports.BaseGeoJsonEditMode = void 0;

var _union = _interopRequireDefault(require("@turf/union"));

var _difference = _interopRequireDefault(require("@turf/difference"));

var _intersect = _interopRequireDefault(require("@turf/intersect"));

var _utils = require("../utils.js");

var _editMode = require("./edit-mode.js");

var _immutableFeatureCollection = require("./immutable-feature-collection.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DEFAULT_GUIDES = {
  type: 'FeatureCollection',
  features: []
};
var DEFAULT_TOOLTIPS = []; // Main interface for `EditMode`s that edit GeoJSON

var BaseGeoJsonEditMode =
/*#__PURE__*/
function () {
  function BaseGeoJsonEditMode() {
    _classCallCheck(this, BaseGeoJsonEditMode);

    _defineProperty(this, "_clickSequence", []);
  }

  _createClass(BaseGeoJsonEditMode, [{
    key: "getGuides",
    value: function getGuides(props) {
      return DEFAULT_GUIDES;
    }
  }, {
    key: "getTooltips",
    value: function getTooltips(props) {
      return DEFAULT_TOOLTIPS;
    }
  }, {
    key: "getSelectedFeature",
    value: function getSelectedFeature(props) {
      if (props.selectedIndexes.length === 1) {
        return props.data.features[props.selectedIndexes[0]];
      }

      return null;
    }
  }, {
    key: "getSelectedGeometry",
    value: function getSelectedGeometry(props) {
      var feature = this.getSelectedFeature(props);

      if (feature) {
        return feature.geometry;
      }

      return null;
    }
  }, {
    key: "getSelectedFeaturesAsFeatureCollection",
    value: function getSelectedFeaturesAsFeatureCollection(props) {
      var features = props.data.features;
      var selectedFeatures = props.selectedIndexes.map(function (selectedIndex) {
        return features[selectedIndex];
      });
      return {
        type: 'FeatureCollection',
        features: selectedFeatures
      };
    }
  }, {
    key: "getClickSequence",
    value: function getClickSequence() {
      return this._clickSequence;
    }
  }, {
    key: "addClickSequence",
    value: function addClickSequence(_ref) {
      var mapCoords = _ref.mapCoords;

      this._clickSequence.push(mapCoords);
    }
  }, {
    key: "resetClickSequence",
    value: function resetClickSequence() {
      this._clickSequence = [];
    }
  }, {
    key: "getTentativeGuide",
    value: function getTentativeGuide(props) {
      var guides = this.getGuides(props); // $FlowFixMe

      return guides.features.find(function (f) {
        return f.properties && f.properties.guideType === 'tentative';
      });
    }
  }, {
    key: "isSelectionPicked",
    value: function isSelectionPicked(picks, props) {
      if (!picks.length) return false;
      var pickedFeatures = (0, _utils.getNonGuidePicks)(picks).map(function (_ref2) {
        var index = _ref2.index;
        return index;
      });
      var pickedHandles = (0, _utils.getPickedEditHandles)(picks).map(function (_ref3) {
        var properties = _ref3.properties;
        return properties.featureIndex;
      });
      var pickedIndexes = new Set(_toConsumableArray(pickedFeatures).concat(_toConsumableArray(pickedHandles)));
      return props.selectedIndexes.some(function (index) {
        return pickedIndexes.has(index);
      });
    }
  }, {
    key: "getAddFeatureAction",
    value: function getAddFeatureAction(geometry, features) {
      // Unsure why flow can't deal with Geometry type, but there I fixed it
      var geometryAsAny = geometry;
      var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(features).addFeature({
        type: 'Feature',
        properties: {},
        geometry: geometryAsAny
      }).getObject();
      return {
        updatedData: updatedData,
        editType: 'addFeature',
        editContext: {
          featureIndexes: [updatedData.features.length - 1]
        }
      };
    }
  }, {
    key: "getAddManyFeaturesAction",
    value: function getAddManyFeaturesAction(_ref4, features) {
      var featuresToAdd = _ref4.features;
      var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(features);
      var initialIndex = updatedData.getObject().features.length;
      var updatedIndexes = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = featuresToAdd[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var feature = _step.value;
          var properties = feature.properties,
              geometry = feature.geometry;
          var geometryAsAny = geometry;
          updatedData = updatedData.addFeature({
            type: 'Feature',
            properties: properties,
            geometry: geometryAsAny
          });
          updatedIndexes.push(initialIndex + updatedIndexes.length);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return {
        updatedData: updatedData.getObject(),
        editType: 'addFeature',
        editContext: {
          featureIndexes: updatedIndexes
        }
      };
    }
  }, {
    key: "getAddFeatureOrBooleanPolygonAction",
    value: function getAddFeatureOrBooleanPolygonAction(geometry, props) {
      var selectedFeature = this.getSelectedFeature(props);
      var modeConfig = props.modeConfig;

      if (modeConfig && modeConfig.booleanOperation) {
        if (!selectedFeature || selectedFeature.geometry.type !== 'Polygon' && selectedFeature.geometry.type !== 'MultiPolygon') {
          // eslint-disable-next-line no-console,no-undef
          console.warn('booleanOperation only supported for single Polygon or MultiPolygon selection');
          return null;
        }

        var feature = {
          type: 'Feature',
          geometry: geometry
        };
        var updatedGeometry;

        if (modeConfig.booleanOperation === 'union') {
          updatedGeometry = (0, _union.default)(selectedFeature, feature);
        } else if (modeConfig.booleanOperation === 'difference') {
          updatedGeometry = (0, _difference.default)(selectedFeature, feature);
        } else if (modeConfig.booleanOperation === 'intersection') {
          updatedGeometry = (0, _intersect.default)(selectedFeature, feature);
        } else {
          // eslint-disable-next-line no-console,no-undef
          console.warn("Invalid booleanOperation ".concat(modeConfig.booleanOperation));
          return null;
        }

        if (!updatedGeometry) {
          // eslint-disable-next-line no-console,no-undef
          console.warn('Canceling edit. Boolean operation erased entire polygon.');
          return null;
        }

        var featureIndex = props.selectedIndexes[0];
        var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replaceGeometry(featureIndex, updatedGeometry.geometry).getObject();
        var editAction = {
          updatedData: updatedData,
          editType: 'unionGeometry',
          editContext: {
            featureIndexes: [featureIndex]
          }
        };
        return editAction;
      }

      return this.getAddFeatureAction(geometry, props.data);
    }
  }, {
    key: "handleClick",
    value: function handleClick(event, props) {}
  }, {
    key: "handlePointerMove",
    value: function handlePointerMove(event, props) {}
  }, {
    key: "handleStartDragging",
    value: function handleStartDragging(event, props) {}
  }, {
    key: "handleStopDragging",
    value: function handleStopDragging(event, props) {}
  }, {
    key: "handleDragging",
    value: function handleDragging(event, props) {}
  }]);

  return BaseGeoJsonEditMode;
}();

exports.BaseGeoJsonEditMode = BaseGeoJsonEditMode;

function getIntermediatePosition(position1, position2) {
  var intermediatePosition = [(position1[0] + position2[0]) / 2.0, (position1[1] + position2[1]) / 2.0];
  return intermediatePosition;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZ2VvanNvbi1lZGl0LW1vZGUuanMiXSwibmFtZXMiOlsiREVGQVVMVF9HVUlERVMiLCJ0eXBlIiwiZmVhdHVyZXMiLCJERUZBVUxUX1RPT0xUSVBTIiwiQmFzZUdlb0pzb25FZGl0TW9kZSIsInByb3BzIiwic2VsZWN0ZWRJbmRleGVzIiwibGVuZ3RoIiwiZGF0YSIsImZlYXR1cmUiLCJnZXRTZWxlY3RlZEZlYXR1cmUiLCJnZW9tZXRyeSIsInNlbGVjdGVkRmVhdHVyZXMiLCJtYXAiLCJzZWxlY3RlZEluZGV4IiwiX2NsaWNrU2VxdWVuY2UiLCJtYXBDb29yZHMiLCJwdXNoIiwiZ3VpZGVzIiwiZ2V0R3VpZGVzIiwiZmluZCIsImYiLCJwcm9wZXJ0aWVzIiwiZ3VpZGVUeXBlIiwicGlja3MiLCJwaWNrZWRGZWF0dXJlcyIsImluZGV4IiwicGlja2VkSGFuZGxlcyIsImZlYXR1cmVJbmRleCIsInBpY2tlZEluZGV4ZXMiLCJTZXQiLCJzb21lIiwiaGFzIiwiZ2VvbWV0cnlBc0FueSIsInVwZGF0ZWREYXRhIiwiSW1tdXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24iLCJhZGRGZWF0dXJlIiwiZ2V0T2JqZWN0IiwiZWRpdFR5cGUiLCJlZGl0Q29udGV4dCIsImZlYXR1cmVJbmRleGVzIiwiZmVhdHVyZXNUb0FkZCIsImluaXRpYWxJbmRleCIsInVwZGF0ZWRJbmRleGVzIiwic2VsZWN0ZWRGZWF0dXJlIiwibW9kZUNvbmZpZyIsImJvb2xlYW5PcGVyYXRpb24iLCJjb25zb2xlIiwid2FybiIsInVwZGF0ZWRHZW9tZXRyeSIsInJlcGxhY2VHZW9tZXRyeSIsImVkaXRBY3Rpb24iLCJnZXRBZGRGZWF0dXJlQWN0aW9uIiwiZXZlbnQiLCJnZXRJbnRlcm1lZGlhdGVQb3NpdGlvbiIsInBvc2l0aW9uMSIsInBvc2l0aW9uMiIsImludGVybWVkaWF0ZVBvc2l0aW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUVBOztBQUNBOztBQUNBOztBQWdC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cEVnRCxLLEVBQTJCaEQsSyxFQUEyQyxDQUFFOzs7dUNBQ3pFZ0QsSyxFQUEwQmhELEssRUFBMkMsQ0FBRTs7O21DQUMzRWdELEssRUFBc0JoRCxLLEVBQTJDLENBQUU7Ozs7Ozs7O0FBRzdFLFNBQVNpRCx1QkFBVCxDQUFpQ0MsU0FBakMsRUFBc0RDLFNBQXRELEVBQXFGO0FBQzFGLE1BQU1DLG9CQUFvQixHQUFHLENBQzNCLENBQUNGLFNBQVMsQ0FBQyxDQUFELENBQVQsR0FBZUMsU0FBUyxDQUFDLENBQUQsQ0FBekIsSUFBZ0MsR0FETCxFQUUzQixDQUFDRCxTQUFTLENBQUMsQ0FBRCxDQUFULEdBQWVDLFNBQVMsQ0FBQyxDQUFELENBQXpCLElBQWdDLEdBRkwsQ0FBN0I7QUFJQSxTQUFPQyxvQkFBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxuaW1wb3J0IHR1cmZVbmlvbiBmcm9tICdAdHVyZi91bmlvbic7XG5pbXBvcnQgdHVyZkRpZmZlcmVuY2UgZnJvbSAnQHR1cmYvZGlmZmVyZW5jZSc7XG5pbXBvcnQgdHVyZkludGVyc2VjdCBmcm9tICdAdHVyZi9pbnRlcnNlY3QnO1xuXG5pbXBvcnQgdHlwZSB7XG4gIEVkaXRBY3Rpb24sXG4gIENsaWNrRXZlbnQsXG4gIFBvaW50ZXJNb3ZlRXZlbnQsXG4gIFN0YXJ0RHJhZ2dpbmdFdmVudCxcbiAgU3RvcERyYWdnaW5nRXZlbnQsXG4gIERyYWdnaW5nRXZlbnQsXG4gIFBpY2ssXG4gIFRvb2x0aXAsXG4gIE1vZGVQcm9wcyxcbiAgR3VpZGVGZWF0dXJlQ29sbGVjdGlvbixcbiAgVGVudGF0aXZlRmVhdHVyZVxufSBmcm9tICcuLi90eXBlcy5qcyc7XG5pbXBvcnQgdHlwZSB7IEZlYXR1cmVDb2xsZWN0aW9uLCBGZWF0dXJlLCBQb2x5Z29uLCBHZW9tZXRyeSwgUG9zaXRpb24gfSBmcm9tICcuLi9nZW9qc29uLXR5cGVzLmpzJztcbmltcG9ydCB7IGdldFBpY2tlZEVkaXRIYW5kbGVzLCBnZXROb25HdWlkZVBpY2tzIH0gZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHsgRWRpdE1vZGUgfSBmcm9tICcuL2VkaXQtbW9kZS5qcyc7XG5pbXBvcnQgeyBJbW11dGFibGVGZWF0dXJlQ29sbGVjdGlvbiB9IGZyb20gJy4vaW1tdXRhYmxlLWZlYXR1cmUtY29sbGVjdGlvbi5qcyc7XG5cbmV4cG9ydCB0eXBlIEdlb0pzb25FZGl0QWN0aW9uID0gRWRpdEFjdGlvbjxGZWF0dXJlQ29sbGVjdGlvbj47XG5cbmNvbnN0IERFRkFVTFRfR1VJREVTOiBHdWlkZUZlYXR1cmVDb2xsZWN0aW9uID0ge1xuICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICBmZWF0dXJlczogW11cbn07XG5jb25zdCBERUZBVUxUX1RPT0xUSVBTOiBUb29sdGlwW10gPSBbXTtcblxuLy8gTWFpbiBpbnRlcmZhY2UgZm9yIGBFZGl0TW9kZWBzIHRoYXQgZWRpdCBHZW9KU09OXG5leHBvcnQgdHlwZSBHZW9Kc29uRWRpdE1vZGUgPSBFZGl0TW9kZTxGZWF0dXJlQ29sbGVjdGlvbiwgRmVhdHVyZUNvbGxlY3Rpb24+O1xuXG5leHBvcnQgY2xhc3MgQmFzZUdlb0pzb25FZGl0TW9kZSBpbXBsZW1lbnRzIEVkaXRNb2RlPEZlYXR1cmVDb2xsZWN0aW9uLCBHdWlkZUZlYXR1cmVDb2xsZWN0aW9uPiB7XG4gIF9jbGlja1NlcXVlbmNlOiBQb3NpdGlvbltdID0gW107XG5cbiAgZ2V0R3VpZGVzKHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KTogR3VpZGVGZWF0dXJlQ29sbGVjdGlvbiB7XG4gICAgcmV0dXJuIERFRkFVTFRfR1VJREVTO1xuICB9XG5cbiAgZ2V0VG9vbHRpcHMocHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pOiBUb29sdGlwW10ge1xuICAgIHJldHVybiBERUZBVUxUX1RPT0xUSVBTO1xuICB9XG5cbiAgZ2V0U2VsZWN0ZWRGZWF0dXJlKHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KTogP0ZlYXR1cmUge1xuICAgIGlmIChwcm9wcy5zZWxlY3RlZEluZGV4ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcHJvcHMuZGF0YS5mZWF0dXJlc1twcm9wcy5zZWxlY3RlZEluZGV4ZXNbMF1dO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldFNlbGVjdGVkR2VvbWV0cnkocHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pOiA/R2VvbWV0cnkge1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZShwcm9wcyk7XG4gICAgaWYgKGZlYXR1cmUpIHtcbiAgICAgIHJldHVybiBmZWF0dXJlLmdlb21ldHJ5O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldFNlbGVjdGVkRmVhdHVyZXNBc0ZlYXR1cmVDb2xsZWN0aW9uKHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KTogRmVhdHVyZUNvbGxlY3Rpb24ge1xuICAgIGNvbnN0IHsgZmVhdHVyZXMgfSA9IHByb3BzLmRhdGE7XG4gICAgY29uc3Qgc2VsZWN0ZWRGZWF0dXJlcyA9IHByb3BzLnNlbGVjdGVkSW5kZXhlcy5tYXAoc2VsZWN0ZWRJbmRleCA9PiBmZWF0dXJlc1tzZWxlY3RlZEluZGV4XSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICBmZWF0dXJlczogc2VsZWN0ZWRGZWF0dXJlc1xuICAgIH07XG4gIH1cblxuICBnZXRDbGlja1NlcXVlbmNlKCk6IFBvc2l0aW9uW10ge1xuICAgIHJldHVybiB0aGlzLl9jbGlja1NlcXVlbmNlO1xuICB9XG5cbiAgYWRkQ2xpY2tTZXF1ZW5jZSh7IG1hcENvb3JkcyB9OiBDbGlja0V2ZW50KTogdm9pZCB7XG4gICAgdGhpcy5fY2xpY2tTZXF1ZW5jZS5wdXNoKG1hcENvb3Jkcyk7XG4gIH1cblxuICByZXNldENsaWNrU2VxdWVuY2UoKTogdm9pZCB7XG4gICAgdGhpcy5fY2xpY2tTZXF1ZW5jZSA9IFtdO1xuICB9XG5cbiAgZ2V0VGVudGF0aXZlR3VpZGUocHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pOiA/VGVudGF0aXZlRmVhdHVyZSB7XG4gICAgY29uc3QgZ3VpZGVzID0gdGhpcy5nZXRHdWlkZXMocHJvcHMpO1xuXG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIHJldHVybiBndWlkZXMuZmVhdHVyZXMuZmluZChmID0+IGYucHJvcGVydGllcyAmJiBmLnByb3BlcnRpZXMuZ3VpZGVUeXBlID09PSAndGVudGF0aXZlJyk7XG4gIH1cblxuICBpc1NlbGVjdGlvblBpY2tlZChwaWNrczogUGlja1tdLCBwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPik6IGJvb2xlYW4ge1xuICAgIGlmICghcGlja3MubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcGlja2VkRmVhdHVyZXMgPSBnZXROb25HdWlkZVBpY2tzKHBpY2tzKS5tYXAoKHsgaW5kZXggfSkgPT4gaW5kZXgpO1xuICAgIGNvbnN0IHBpY2tlZEhhbmRsZXMgPSBnZXRQaWNrZWRFZGl0SGFuZGxlcyhwaWNrcykubWFwKFxuICAgICAgKHsgcHJvcGVydGllcyB9KSA9PiBwcm9wZXJ0aWVzLmZlYXR1cmVJbmRleFxuICAgICk7XG4gICAgY29uc3QgcGlja2VkSW5kZXhlcyA9IG5ldyBTZXQoWy4uLnBpY2tlZEZlYXR1cmVzLCAuLi5waWNrZWRIYW5kbGVzXSk7XG4gICAgcmV0dXJuIHByb3BzLnNlbGVjdGVkSW5kZXhlcy5zb21lKGluZGV4ID0+IHBpY2tlZEluZGV4ZXMuaGFzKGluZGV4KSk7XG4gIH1cblxuICBnZXRBZGRGZWF0dXJlQWN0aW9uKGdlb21ldHJ5OiBHZW9tZXRyeSwgZmVhdHVyZXM6IEZlYXR1cmVDb2xsZWN0aW9uKTogR2VvSnNvbkVkaXRBY3Rpb24ge1xuICAgIC8vIFVuc3VyZSB3aHkgZmxvdyBjYW4ndCBkZWFsIHdpdGggR2VvbWV0cnkgdHlwZSwgYnV0IHRoZXJlIEkgZml4ZWQgaXRcbiAgICBjb25zdCBnZW9tZXRyeUFzQW55OiBhbnkgPSBnZW9tZXRyeTtcblxuICAgIGNvbnN0IHVwZGF0ZWREYXRhID0gbmV3IEltbXV0YWJsZUZlYXR1cmVDb2xsZWN0aW9uKGZlYXR1cmVzKVxuICAgICAgLmFkZEZlYXR1cmUoe1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnlBc0FueVxuICAgICAgfSlcbiAgICAgIC5nZXRPYmplY3QoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB1cGRhdGVkRGF0YSxcbiAgICAgIGVkaXRUeXBlOiAnYWRkRmVhdHVyZScsXG4gICAgICBlZGl0Q29udGV4dDoge1xuICAgICAgICBmZWF0dXJlSW5kZXhlczogW3VwZGF0ZWREYXRhLmZlYXR1cmVzLmxlbmd0aCAtIDFdXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGdldEFkZE1hbnlGZWF0dXJlc0FjdGlvbihcbiAgICB7IGZlYXR1cmVzOiBmZWF0dXJlc1RvQWRkIH06IEZlYXR1cmVDb2xsZWN0aW9uLFxuICAgIGZlYXR1cmVzOiBGZWF0dXJlQ29sbGVjdGlvblxuICApOiBHZW9Kc29uRWRpdEFjdGlvbiB7XG4gICAgbGV0IHVwZGF0ZWREYXRhID0gbmV3IEltbXV0YWJsZUZlYXR1cmVDb2xsZWN0aW9uKGZlYXR1cmVzKTtcbiAgICBjb25zdCBpbml0aWFsSW5kZXggPSB1cGRhdGVkRGF0YS5nZXRPYmplY3QoKS5mZWF0dXJlcy5sZW5ndGg7XG4gICAgY29uc3QgdXBkYXRlZEluZGV4ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZlYXR1cmUgb2YgZmVhdHVyZXNUb0FkZCkge1xuICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzLCBnZW9tZXRyeSB9ID0gZmVhdHVyZTtcbiAgICAgIGNvbnN0IGdlb21ldHJ5QXNBbnk6IGFueSA9IGdlb21ldHJ5O1xuICAgICAgdXBkYXRlZERhdGEgPSB1cGRhdGVkRGF0YS5hZGRGZWF0dXJlKHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnlBc0FueVxuICAgICAgfSk7XG4gICAgICB1cGRhdGVkSW5kZXhlcy5wdXNoKGluaXRpYWxJbmRleCArIHVwZGF0ZWRJbmRleGVzLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVwZGF0ZWREYXRhOiB1cGRhdGVkRGF0YS5nZXRPYmplY3QoKSxcbiAgICAgIGVkaXRUeXBlOiAnYWRkRmVhdHVyZScsXG4gICAgICBlZGl0Q29udGV4dDoge1xuICAgICAgICBmZWF0dXJlSW5kZXhlczogdXBkYXRlZEluZGV4ZXNcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZ2V0QWRkRmVhdHVyZU9yQm9vbGVhblBvbHlnb25BY3Rpb24oXG4gICAgZ2VvbWV0cnk6IFBvbHlnb24sXG4gICAgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj5cbiAgKTogP0dlb0pzb25FZGl0QWN0aW9uIHtcbiAgICBjb25zdCBzZWxlY3RlZEZlYXR1cmUgPSB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZShwcm9wcyk7XG4gICAgY29uc3QgeyBtb2RlQ29uZmlnIH0gPSBwcm9wcztcbiAgICBpZiAobW9kZUNvbmZpZyAmJiBtb2RlQ29uZmlnLmJvb2xlYW5PcGVyYXRpb24pIHtcbiAgICAgIGlmIChcbiAgICAgICAgIXNlbGVjdGVkRmVhdHVyZSB8fFxuICAgICAgICAoc2VsZWN0ZWRGZWF0dXJlLmdlb21ldHJ5LnR5cGUgIT09ICdQb2x5Z29uJyAmJlxuICAgICAgICAgIHNlbGVjdGVkRmVhdHVyZS5nZW9tZXRyeS50eXBlICE9PSAnTXVsdGlQb2x5Z29uJylcbiAgICAgICkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZSxuby11bmRlZlxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ2Jvb2xlYW5PcGVyYXRpb24gb25seSBzdXBwb3J0ZWQgZm9yIHNpbmdsZSBQb2x5Z29uIG9yIE11bHRpUG9seWdvbiBzZWxlY3Rpb24nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmZWF0dXJlID0ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIGdlb21ldHJ5XG4gICAgICB9O1xuXG4gICAgICBsZXQgdXBkYXRlZEdlb21ldHJ5O1xuICAgICAgaWYgKG1vZGVDb25maWcuYm9vbGVhbk9wZXJhdGlvbiA9PT0gJ3VuaW9uJykge1xuICAgICAgICB1cGRhdGVkR2VvbWV0cnkgPSB0dXJmVW5pb24oc2VsZWN0ZWRGZWF0dXJlLCBmZWF0dXJlKTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZUNvbmZpZy5ib29sZWFuT3BlcmF0aW9uID09PSAnZGlmZmVyZW5jZScpIHtcbiAgICAgICAgdXBkYXRlZEdlb21ldHJ5ID0gdHVyZkRpZmZlcmVuY2Uoc2VsZWN0ZWRGZWF0dXJlLCBmZWF0dXJlKTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZUNvbmZpZy5ib29sZWFuT3BlcmF0aW9uID09PSAnaW50ZXJzZWN0aW9uJykge1xuICAgICAgICB1cGRhdGVkR2VvbWV0cnkgPSB0dXJmSW50ZXJzZWN0KHNlbGVjdGVkRmVhdHVyZSwgZmVhdHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZSxuby11bmRlZlxuICAgICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgYm9vbGVhbk9wZXJhdGlvbiAke21vZGVDb25maWcuYm9vbGVhbk9wZXJhdGlvbn1gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghdXBkYXRlZEdlb21ldHJ5KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlLG5vLXVuZGVmXG4gICAgICAgIGNvbnNvbGUud2FybignQ2FuY2VsaW5nIGVkaXQuIEJvb2xlYW4gb3BlcmF0aW9uIGVyYXNlZCBlbnRpcmUgcG9seWdvbi4nKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZlYXR1cmVJbmRleCA9IHByb3BzLnNlbGVjdGVkSW5kZXhlc1swXTtcblxuICAgICAgY29uc3QgdXBkYXRlZERhdGEgPSBuZXcgSW1tdXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24ocHJvcHMuZGF0YSlcbiAgICAgICAgLnJlcGxhY2VHZW9tZXRyeShmZWF0dXJlSW5kZXgsIHVwZGF0ZWRHZW9tZXRyeS5nZW9tZXRyeSlcbiAgICAgICAgLmdldE9iamVjdCgpO1xuXG4gICAgICBjb25zdCBlZGl0QWN0aW9uOiBHZW9Kc29uRWRpdEFjdGlvbiA9IHtcbiAgICAgICAgdXBkYXRlZERhdGEsXG4gICAgICAgIGVkaXRUeXBlOiAndW5pb25HZW9tZXRyeScsXG4gICAgICAgIGVkaXRDb250ZXh0OiB7XG4gICAgICAgICAgZmVhdHVyZUluZGV4ZXM6IFtmZWF0dXJlSW5kZXhdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBlZGl0QWN0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRBZGRGZWF0dXJlQWN0aW9uKGdlb21ldHJ5LCBwcm9wcy5kYXRhKTtcbiAgfVxuXG4gIGhhbmRsZUNsaWNrKGV2ZW50OiBDbGlja0V2ZW50LCBwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPik6IHZvaWQge31cbiAgaGFuZGxlUG9pbnRlck1vdmUoZXZlbnQ6IFBvaW50ZXJNb3ZlRXZlbnQsIHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KTogdm9pZCB7fVxuICBoYW5kbGVTdGFydERyYWdnaW5nKGV2ZW50OiBTdGFydERyYWdnaW5nRXZlbnQsIHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KTogdm9pZCB7fVxuICBoYW5kbGVTdG9wRHJhZ2dpbmcoZXZlbnQ6IFN0b3BEcmFnZ2luZ0V2ZW50LCBwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPik6IHZvaWQge31cbiAgaGFuZGxlRHJhZ2dpbmcoZXZlbnQ6IERyYWdnaW5nRXZlbnQsIHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KTogdm9pZCB7fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJtZWRpYXRlUG9zaXRpb24ocG9zaXRpb24xOiBQb3NpdGlvbiwgcG9zaXRpb24yOiBQb3NpdGlvbik6IFBvc2l0aW9uIHtcbiAgY29uc3QgaW50ZXJtZWRpYXRlUG9zaXRpb24gPSBbXG4gICAgKHBvc2l0aW9uMVswXSArIHBvc2l0aW9uMlswXSkgLyAyLjAsXG4gICAgKHBvc2l0aW9uMVsxXSArIHBvc2l0aW9uMlsxXSkgLyAyLjBcbiAgXTtcbiAgcmV0dXJuIGludGVybWVkaWF0ZVBvc2l0aW9uO1xufVxuIl19