"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeasureDistanceMode = void 0;

var _distance = _interopRequireDefault(require("@turf/distance"));

var _memoizee = _interopRequireDefault(require("memoizee"));

var _geojsonEditMode = require("./geojson-edit-mode.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DEFAULT_TOOLTIPS = [];

var MeasureDistanceMode =
/*#__PURE__*/
function (_BaseGeoJsonEditMode) {
  _inherits(MeasureDistanceMode, _BaseGeoJsonEditMode);

  function MeasureDistanceMode() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, MeasureDistanceMode);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MeasureDistanceMode)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "startingPoint", null);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "endingPoint", null);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "endingPointLocked", false);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_getTooltips", (0, _memoizee.default)(function (modeConfig, startingPoint, endingPoint) {
      var tooltips = DEFAULT_TOOLTIPS;

      if (startingPoint && endingPoint) {
        var _ref = modeConfig || {},
            formatTooltip = _ref.formatTooltip,
            turfOptions = _ref.turfOptions,
            measurementCallback = _ref.measurementCallback;

        var units = turfOptions && turfOptions.units || 'kilometers';
        var distance = (0, _distance.default)(startingPoint, endingPoint, turfOptions);
        var text;

        if (formatTooltip) {
          text = formatTooltip(distance);
        }

        if (!formatTooltip) {
          // By default, round to 2 decimal places and append units
          text = "".concat(parseFloat(distance).toFixed(2), " ").concat(units);
        }

        if (measurementCallback) {
          measurementCallback(distance);
        }

        tooltips = [{
          position: endingPoint.geometry.coordinates,
          text: text
        }];
      }

      return tooltips;
    }));

    return _this;
  }

  _createClass(MeasureDistanceMode, [{
    key: "_setEndingPoint",
    value: function _setEndingPoint(mapCoords) {
      this.endingPoint = {
        type: 'Feature',
        properties: {
          guideType: 'editHandle',
          editHandleType: 'existing',
          featureIndex: -1,
          positionIndexes: []
        },
        geometry: {
          type: 'Point',
          coordinates: mapCoords
        }
      };
    }
  }, {
    key: "handleClick",
    value: function handleClick(event, props) {
      if (!this.startingPoint || this.endingPointLocked) {
        this.startingPoint = {
          type: 'Feature',
          properties: {
            guideType: 'editHandle',
            editHandleType: 'existing',
            featureIndex: -1,
            positionIndexes: []
          },
          geometry: {
            type: 'Point',
            coordinates: event.mapCoords
          }
        };
        this.endingPoint = null;
        this.endingPointLocked = false;
      } else if (this.startingPoint) {
        this._setEndingPoint(event.mapCoords);

        this.endingPointLocked = true;
      }
    } // Called when the pointer moved, regardless of whether the pointer is down, up, and whether something was picked

  }, {
    key: "handlePointerMove",
    value: function handlePointerMove(event, props) {
      if (this.startingPoint && !this.endingPointLocked) {
        this._setEndingPoint(event.mapCoords);
      }

      props.onUpdateCursor('cell');
    } // Called when the pointer went down on something rendered by this layer and the pointer started to move

  }, {
    key: "handleStartDragging",
    value: function handleStartDragging(event, props) {} // Called when the pointer went down on something rendered by this layer, the pointer moved, and now the pointer is up

  }, {
    key: "handleStopDragging",
    value: function handleStopDragging(event, props) {} // Return features that can be used as a guide for editing the data

  }, {
    key: "getGuides",
    value: function getGuides(props) {
      var guides = {
        type: 'FeatureCollection',
        features: []
      };
      var features = guides.features;

      if (this.startingPoint) {
        features.push(this.startingPoint);
      }

      if (this.endingPoint) {
        features.push(this.endingPoint);
      }

      if (this.startingPoint && this.endingPoint) {
        features.push({
          type: 'Feature',
          properties: {
            guideType: 'tentative'
          },
          geometry: {
            type: 'LineString',
            coordinates: [this.startingPoint.geometry.coordinates, this.endingPoint.geometry.coordinates]
          }
        });
      }

      return guides;
    }
  }, {
    key: "getTooltips",
    value: function getTooltips(props) {
      return this._getTooltips(props.modeConfig, this.startingPoint, this.endingPoint);
    }
  }]);

  return MeasureDistanceMode;
}(_geojsonEditMode.BaseGeoJsonEditMode);

exports.MeasureDistanceMode = MeasureDistanceMode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbWVhc3VyZS1kaXN0YW5jZS1tb2RlLmpzIl0sIm5hbWVzIjpbIkRFRkFVTFRfVE9PTFRJUFMiLCJNZWFzdXJlRGlzdGFuY2VNb2RlIiwibW9kZUNvbmZpZyIsInN0YXJ0aW5nUG9pbnQiLCJlbmRpbmdQb2ludCIsInRvb2x0aXBzIiwiZm9ybWF0VG9vbHRpcCIsInR1cmZPcHRpb25zIiwibWVhc3VyZW1lbnRDYWxsYmFjayIsInVuaXRzIiwiZGlzdGFuY2UiLCJ0ZXh0IiwicGFyc2VGbG9hdCIsInRvRml4ZWQiLCJwb3NpdGlvbiIsImdlb21ldHJ5IiwiY29vcmRpbmF0ZXMiLCJtYXBDb29yZHMiLCJ0eXBlIiwicHJvcGVydGllcyIsImd1aWRlVHlwZSIsImVkaXRIYW5kbGVUeXBlIiwiZmVhdHVyZUluZGV4IiwicG9zaXRpb25JbmRleGVzIiwiZXZlbnQiLCJwcm9wcyIsImVuZGluZ1BvaW50TG9ja2VkIiwiX3NldEVuZGluZ1BvaW50Iiwib25VcGRhdGVDdXJzb3IiLCJndWlkZXMiLCJmZWF0dXJlcyIsInB1c2giLCJfZ2V0VG9vbHRpcHMiLCJCYXNlR2VvSnNvbkVkaXRNb2RlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBRUE7O0FBQ0E7O0FBWUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLGdCQUFnQixHQUFHLEVBQXpCOztJQUVhQyxtQjs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRGQUNvQyxJOzswRkFDRixJOztnR0FDekIsSzs7MkZBa0JMLHVCQUFRLFVBQUNDLFVBQUQsRUFBYUMsYUFBYixFQUE0QkMsV0FBNUIsRUFBNEM7QUFDakUsVUFBSUMsUUFBUSxHQUFHTCxnQkFBZjs7QUFFQSxVQUFJRyxhQUFhLElBQUlDLFdBQXJCLEVBQWtDO0FBQUEsbUJBQzRCRixVQUFVLElBQUksRUFEMUM7QUFBQSxZQUN4QkksYUFEd0IsUUFDeEJBLGFBRHdCO0FBQUEsWUFDVEMsV0FEUyxRQUNUQSxXQURTO0FBQUEsWUFDSUMsbUJB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QVEsRUFBRTtBQUF2QyxPQUF2QztBQURxRSxVQUU3REEsUUFGNkQsR0FFaERELE1BRmdELENBRTdEQyxRQUY2RDs7QUFJckUsVUFBSSxLQUFLM0IsYUFBVCxFQUF3QjtBQUN0QjJCLFFBQUFBLFFBQVEsQ0FBQ0MsSUFBVCxDQUFjLEtBQUs1QixhQUFuQjtBQUNEOztBQUNELFVBQUksS0FBS0MsV0FBVCxFQUFzQjtBQUNwQjBCLFFBQUFBLFFBQVEsQ0FBQ0MsSUFBVCxDQUFjLEtBQUszQixXQUFuQjtBQUNEOztBQUNELFVBQUksS0FBS0QsYUFBTCxJQUFzQixLQUFLQyxXQUEvQixFQUE0QztBQUMxQzBCLFFBQUFBLFFBQVEsQ0FBQ0MsSUFBVCxDQUFjO0FBQ1piLFVBQUFBLElBQUksRUFBRSxTQURNO0FBRVpDLFVBQUFBLFVBQVUsRUFBRTtBQUFFQyxZQUFBQSxTQUFTLEVBQUU7QUFBYixXQUZBO0FBR1pMLFVBQUFBLFFBQVEsRUFBRTtBQUNSRyxZQUFBQSxJQUFJLEVBQUUsWUFERTtBQUVSRixZQUFBQSxXQUFXLEVBQUUsQ0FDWCxLQUFLYixhQUFMLENBQW1CWSxRQUFuQixDQUE0QkMsV0FEakIsRUFFWCxLQUFLWixXQUFMLENBQWlCVyxRQUFqQixDQUEwQkMsV0FGZjtBQUZMO0FBSEUsU0FBZDtBQVdEOztBQUNELGFBQU9hLE1BQVA7QUFDRDs7O2dDQUVXSixLLEVBQWdEO0FBQzFELGFBQU8sS0FBS08sWUFBTCxDQUFrQlAsS0FBSyxDQUFDdkIsVUFBeEIsRUFBb0MsS0FBS0MsYUFBekMsRUFBd0QsS0FBS0MsV0FBN0QsQ0FBUDtBQUNEOzs7O0VBekhzQzZCLG9DIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxuaW1wb3J0IHR1cmZEaXN0YW5jZSBmcm9tICdAdHVyZi9kaXN0YW5jZSc7XG5pbXBvcnQgbWVtb2l6ZSBmcm9tICdtZW1vaXplZSc7XG5pbXBvcnQgdHlwZSB7XG4gIENsaWNrRXZlbnQsXG4gIFBvaW50ZXJNb3ZlRXZlbnQsXG4gIFN0YXJ0RHJhZ2dpbmdFdmVudCxcbiAgU3RvcERyYWdnaW5nRXZlbnQsXG4gIFRvb2x0aXAsXG4gIE1vZGVQcm9wcyxcbiAgR3VpZGVGZWF0dXJlQ29sbGVjdGlvbixcbiAgRWRpdEhhbmRsZUZlYXR1cmVcbn0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHR5cGUgeyBGZWF0dXJlQ29sbGVjdGlvbiwgUG9zaXRpb24gfSBmcm9tICcuLi9nZW9qc29uLXR5cGVzLmpzJztcbmltcG9ydCB7IEJhc2VHZW9Kc29uRWRpdE1vZGUgfSBmcm9tICcuL2dlb2pzb24tZWRpdC1tb2RlLmpzJztcblxuY29uc3QgREVGQVVMVF9UT09MVElQUyA9IFtdO1xuXG5leHBvcnQgY2xhc3MgTWVhc3VyZURpc3RhbmNlTW9kZSBleHRlbmRzIEJhc2VHZW9Kc29uRWRpdE1vZGUge1xuICBzdGFydGluZ1BvaW50OiA/JFJlYWRPbmx5PEVkaXRIYW5kbGVGZWF0dXJlPiA9IG51bGw7XG4gIGVuZGluZ1BvaW50OiA/JFJlYWRPbmx5PEVkaXRIYW5kbGVGZWF0dXJlPiA9IG51bGw7XG4gIGVuZGluZ1BvaW50TG9ja2VkID0gZmFsc2U7XG5cbiAgX3NldEVuZGluZ1BvaW50KG1hcENvb3JkczogUG9zaXRpb24pIHtcbiAgICB0aGlzLmVuZGluZ1BvaW50ID0ge1xuICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBndWlkZVR5cGU6ICdlZGl0SGFuZGxlJyxcbiAgICAgICAgZWRpdEhhbmRsZVR5cGU6ICdleGlzdGluZycsXG4gICAgICAgIGZlYXR1cmVJbmRleDogLTEsXG4gICAgICAgIHBvc2l0aW9uSW5kZXhlczogW11cbiAgICAgIH0sXG4gICAgICBnZW9tZXRyeToge1xuICAgICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgICBjb29yZGluYXRlczogbWFwQ29vcmRzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIF9nZXRUb29sdGlwcyA9IG1lbW9pemUoKG1vZGVDb25maWcsIHN0YXJ0aW5nUG9pbnQsIGVuZGluZ1BvaW50KSA9PiB7XG4gICAgbGV0IHRvb2x0aXBzID0gREVGQVVMVF9UT09MVElQUztcblxuICAgIGlmIChzdGFydGluZ1BvaW50ICYmIGVuZGluZ1BvaW50KSB7XG4gICAgICBjb25zdCB7IGZvcm1hdFRvb2x0aXAsIHR1cmZPcHRpb25zLCBtZWFzdXJlbWVudENhbGxiYWNrIH0gPSBtb2RlQ29uZmlnIHx8IHt9O1xuICAgICAgY29uc3QgdW5pdHMgPSAodHVyZk9wdGlvbnMgJiYgdHVyZk9wdGlvbnMudW5pdHMpIHx8ICdraWxvbWV0ZXJzJztcblxuICAgICAgY29uc3QgZGlzdGFuY2UgPSB0dXJmRGlzdGFuY2Uoc3RhcnRpbmdQb2ludCwgZW5kaW5nUG9pbnQsIHR1cmZPcHRpb25zKTtcblxuICAgICAgbGV0IHRleHQ7XG4gICAgICBpZiAoZm9ybWF0VG9vbHRpcCkge1xuICAgICAgICB0ZXh0ID0gZm9ybWF0VG9vbHRpcChkaXN0YW5jZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWZvcm1hdFRvb2x0aXApIHtcbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgcm91bmQgdG8gMiBkZWNpbWFsIHBsYWNlcyBhbmQgYXBwZW5kIHVuaXRzXG4gICAgICAgIHRleHQgPSBgJHtwYXJzZUZsb2F0KGRpc3RhbmNlKS50b0ZpeGVkKDIpfSAke3VuaXRzfWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWFzdXJlbWVudENhbGxiYWNrKSB7XG4gICAgICAgIG1lYXN1cmVtZW50Q2FsbGJhY2soZGlzdGFuY2UpO1xuICAgICAgfVxuXG4gICAgICB0b29sdGlwcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHBvc2l0aW9uOiBlbmRpbmdQb2ludC5nZW9tZXRyeS5jb29yZGluYXRlcyxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvb2x0aXBzO1xuICB9KTtcblxuICBoYW5kbGVDbGljayhldmVudDogQ2xpY2tFdmVudCwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuc3RhcnRpbmdQb2ludCB8fCB0aGlzLmVuZGluZ1BvaW50TG9ja2VkKSB7XG4gICAgICB0aGlzLnN0YXJ0aW5nUG9pbnQgPSB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGd1aWRlVHlwZTogJ2VkaXRIYW5kbGUnLFxuICAgICAgICAgIGVkaXRIYW5kbGVUeXBlOiAnZXhpc3RpbmcnLFxuICAgICAgICAgIGZlYXR1cmVJbmRleDogLTEsXG4gICAgICAgICAgcG9zaXRpb25JbmRleGVzOiBbXVxuICAgICAgICB9LFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IGV2ZW50Lm1hcENvb3Jkc1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5lbmRpbmdQb2ludCA9IG51bGw7XG4gICAgICB0aGlzLmVuZGluZ1BvaW50TG9ja2VkID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXJ0aW5nUG9pbnQpIHtcbiAgICAgIHRoaXMuX3NldEVuZGluZ1BvaW50KGV2ZW50Lm1hcENvb3Jkcyk7XG4gICAgICB0aGlzLmVuZGluZ1BvaW50TG9ja2VkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgd2hlbiB0aGUgcG9pbnRlciBtb3ZlZCwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBwb2ludGVyIGlzIGRvd24sIHVwLCBhbmQgd2hldGhlciBzb21ldGhpbmcgd2FzIHBpY2tlZFxuICBoYW5kbGVQb2ludGVyTW92ZShldmVudDogUG9pbnRlck1vdmVFdmVudCwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zdGFydGluZ1BvaW50ICYmICF0aGlzLmVuZGluZ1BvaW50TG9ja2VkKSB7XG4gICAgICB0aGlzLl9zZXRFbmRpbmdQb2ludChldmVudC5tYXBDb29yZHMpO1xuICAgIH1cblxuICAgIHByb3BzLm9uVXBkYXRlQ3Vyc29yKCdjZWxsJyk7XG4gIH1cblxuICAvLyBDYWxsZWQgd2hlbiB0aGUgcG9pbnRlciB3ZW50IGRvd24gb24gc29tZXRoaW5nIHJlbmRlcmVkIGJ5IHRoaXMgbGF5ZXIgYW5kIHRoZSBwb2ludGVyIHN0YXJ0ZWQgdG8gbW92ZVxuICBoYW5kbGVTdGFydERyYWdnaW5nKGV2ZW50OiBTdGFydERyYWdnaW5nRXZlbnQsIHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KTogdm9pZCB7fVxuXG4gIC8vIENhbGxlZCB3aGVuIHRoZSBwb2ludGVyIHdlbnQgZG93biBvbiBzb21ldGhpbmcgcmVuZGVyZWQgYnkgdGhpcyBsYXllciwgdGhlIHBvaW50ZXIgbW92ZWQsIGFuZCBub3cgdGhlIHBvaW50ZXIgaXMgdXBcbiAgaGFuZGxlU3RvcERyYWdnaW5nKGV2ZW50OiBTdG9wRHJhZ2dpbmdFdmVudCwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pOiB2b2lkIHt9XG5cbiAgLy8gUmV0dXJuIGZlYXR1cmVzIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBndWlkZSBmb3IgZWRpdGluZyB0aGUgZGF0YVxuICBnZXRHdWlkZXMocHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pOiBHdWlkZUZlYXR1cmVDb2xsZWN0aW9uIHtcbiAgICBjb25zdCBndWlkZXM6IEd1aWRlRmVhdHVyZUNvbGxlY3Rpb24gPSB7IHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsIGZlYXR1cmVzOiBbXSB9O1xuICAgIGNvbnN0IHsgZmVhdHVyZXMgfSA9IGd1aWRlcztcblxuICAgIGlmICh0aGlzLnN0YXJ0aW5nUG9pbnQpIHtcbiAgICAgIGZlYXR1cmVzLnB1c2godGhpcy5zdGFydGluZ1BvaW50KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZW5kaW5nUG9pbnQpIHtcbiAgICAgIGZlYXR1cmVzLnB1c2godGhpcy5lbmRpbmdQb2ludCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXJ0aW5nUG9pbnQgJiYgdGhpcy5lbmRpbmdQb2ludCkge1xuICAgICAgZmVhdHVyZXMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgcHJvcGVydGllczogeyBndWlkZVR5cGU6ICd0ZW50YXRpdmUnIH0sXG4gICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICB0aGlzLnN0YXJ0aW5nUG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMsXG4gICAgICAgICAgICB0aGlzLmVuZGluZ1BvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzXG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGd1aWRlcztcbiAgfVxuXG4gIGdldFRvb2x0aXBzKHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KTogVG9vbHRpcFtdIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VG9vbHRpcHMocHJvcHMubW9kZUNvbmZpZywgdGhpcy5zdGFydGluZ1BvaW50LCB0aGlzLmVuZGluZ1BvaW50KTtcbiAgfVxufVxuIl19