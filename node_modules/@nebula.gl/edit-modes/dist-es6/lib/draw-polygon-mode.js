"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawPolygonMode = void 0;

var _utils = require("../utils.js");

var _geojsonEditMode = require("./geojson-edit-mode.js");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var DrawPolygonMode =
/*#__PURE__*/
function (_BaseGeoJsonEditMode) {
  _inherits(DrawPolygonMode, _BaseGeoJsonEditMode);

  function DrawPolygonMode() {
    _classCallCheck(this, DrawPolygonMode);

    return _possibleConstructorReturn(this, _getPrototypeOf(DrawPolygonMode).apply(this, arguments));
  }

  _createClass(DrawPolygonMode, [{
    key: "getGuides",
    value: function getGuides(props) {
      var _guides$features;

      var lastPointerMoveEvent = props.lastPointerMoveEvent;
      var clickSequence = this.getClickSequence();
      var lastCoords = lastPointerMoveEvent ? [lastPointerMoveEvent.mapCoords] : [];
      var guides = {
        type: 'FeatureCollection',
        features: []
      };
      var tentativeFeature;

      if (clickSequence.length === 1 || clickSequence.length === 2) {
        tentativeFeature = {
          type: 'Feature',
          properties: {
            guideType: 'tentative'
          },
          geometry: {
            type: 'LineString',
            coordinates: _toConsumableArray(clickSequence).concat(lastCoords)
          }
        };
      } else if (clickSequence.length > 2) {
        tentativeFeature = {
          type: 'Feature',
          properties: {
            guideType: 'tentative'
          },
          geometry: {
            type: 'Polygon',
            coordinates: [_toConsumableArray(clickSequence).concat(lastCoords, [clickSequence[0]])]
          }
        };
      }

      if (tentativeFeature) {
        guides.features.push(tentativeFeature);
      }

      var editHandles = clickSequence.map(function (clickedCoord, index) {
        return {
          type: 'Feature',
          properties: {
            guideType: 'editHandle',
            editHandleType: 'existing',
            featureIndex: -1,
            positionIndexes: [index]
          },
          geometry: {
            type: 'Point',
            coordinates: clickedCoord
          }
        };
      });

      (_guides$features = guides.features).push.apply(_guides$features, _toConsumableArray(editHandles));

      return guides;
    }
  }, {
    key: "handleClick",
    value: function handleClick(event, props) {
      var picks = event.picks;
      var clickedEditHandle = (0, _utils.getPickedEditHandle)(picks);

      if (!clickedEditHandle) {
        // Don't add another point right next to an existing one
        this.addClickSequence(event);
      }

      var clickSequence = this.getClickSequence();

      if (clickSequence.length > 2 && clickedEditHandle && (clickedEditHandle.properties.positionIndexes[0] === 0 || clickedEditHandle.properties.positionIndexes[0] === clickSequence.length - 1)) {
        // They clicked the first or last point (or double-clicked), so complete the polygon
        // Remove the hovered position
        var polygonToAdd = {
          type: 'Polygon',
          coordinates: [_toConsumableArray(clickSequence).concat([clickSequence[0]])]
        };
        this.resetClickSequence();
        var editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd, props);

        if (editAction) {
          props.onEdit(editAction);
        }
      } // Trigger pointer move right away in order for it to update edit handles (to support double-click)


      var fakePointerMoveEvent = {
        screenCoords: [-1, -1],
        mapCoords: event.mapCoords,
        picks: [],
        pointerDownPicks: null,
        pointerDownScreenCoords: null,
        pointerDownMapCoords: null,
        cancelPan: function cancelPan() {},
        sourceEvent: null
      };
      this.handlePointerMove(fakePointerMoveEvent, props);
    }
  }, {
    key: "handlePointerMove",
    value: function handlePointerMove(_ref, props) {
      var mapCoords = _ref.mapCoords;
      props.onUpdateCursor('cell');
    }
  }]);

  return DrawPolygonMode;
}(_geojsonEditMode.BaseGeoJsonEditMode);

exports.DrawPolygonMode = DrawPolygonMode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZHJhdy1wb2x5Z29uLW1vZGUuanMiXSwibmFtZXMiOlsiRHJhd1BvbHlnb25Nb2RlIiwicHJvcHMiLCJsYXN0UG9pbnRlck1vdmVFdmVudCIsImNsaWNrU2VxdWVuY2UiLCJnZXRDbGlja1NlcXVlbmNlIiwibGFzdENvb3JkcyIsIm1hcENvb3JkcyIsImd1aWRlcyIsInR5cGUiLCJmZWF0dXJlcyIsInRlbnRhdGl2ZUZlYXR1cmUiLCJsZW5ndGgiLCJwcm9wZXJ0aWVzIiwiZ3VpZGVUeXBlIiwiZ2VvbWV0cnkiLCJjb29yZGluYXRlcyIsInB1c2giLCJlZGl0SGFuZGxlcyIsIm1hcCIsImNsaWNrZWRDb29yZCIsImluZGV4IiwiZWRpdEhhbmRsZVR5cGUiLCJmZWF0dXJlSW5kZXgiLCJwb3NpdGlvbkluZGV4ZXMiLCJldmVudCIsInBpY2tzIiwiY2xpY2tlZEVkaXRIYW5kbGUiLCJhZGRDbGlja1NlcXVlbmNlIiwicG9seWdvblRvQWRkIiwicmVzZXRDbGlja1NlcXVlbmNlIiwiZWRpdEFjdGlvbiIsImdldEFkZEZlYXR1cmVPckJvb2xlYW5Qb2x5Z29uQWN0aW9uIiwib25FZGl0IiwiZmFrZVBvaW50ZXJNb3ZlRXZlbnQiLCJzY3JlZW5Db29yZHMiLCJwb2ludGVyRG93blBpY2tzIiwicG9pbnRlckRvd25TY3JlZW5Db29yZHMiLCJwb2ludGVyRG93bk1hcENvb3JkcyIsImNhbmNlbFBhbiIsInNvdXJjZUV2ZW50IiwiaGFuZGxlUG9pbnRlck1vdmUiLCJvblVwZGF0ZUN1cnNvciIsIkJhc2VHZW9Kc29uRWRpdE1vZGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFJQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUVhQSxlOzs7Ozs7Ozs7Ozs7OzhCQUNEQyxLLEVBQTZEO0FBQUE7O0FBQUEsVUFDN0RDLG9CQUQ2RCxHQUNwQ0QsS0FEb0MsQ0FDN0RDLG9CQUQ2RDtBQUVyRSxVQUFNQyxhQUFhLEdBQUcsS0FBS0Ms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LFVBQUFBLElBQUksRUFBRSxTQURzQjtBQUU1Qk8sVUFBQUEsV0FBVyxFQUFFLG9CQUFLWixhQUFMLFVBQW9CQSxhQUFhLENBQUMsQ0FBRCxDQUFqQztBQUZlLFNBQTlCO0FBS0EsYUFBSzBCLGtCQUFMO0FBRUEsWUFBTUMsVUFBVSxHQUFHLEtBQUtDLG1DQUFMLENBQXlDSCxZQUF6QyxFQUF1RDNCLEtBQXZELENBQW5COztBQUNBLFlBQUk2QixVQUFKLEVBQWdCO0FBQ2Q3QixVQUFBQSxLQUFLLENBQUMrQixNQUFOLENBQWFGLFVBQWI7QUFDRDtBQUNGLE9BOUJpRSxDQWdDbEU7OztBQUNBLFVBQU1HLG9CQUFvQixHQUFHO0FBQzNCQyxRQUFBQSxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUYsRUFBSyxDQUFDLENBQU4sQ0FEYTtBQUUzQjVCLFFBQUFBLFNBQVMsRUFBRWtCLEtBQUssQ0FBQ2xCLFNBRlU7QUFHM0JtQixRQUFBQSxLQUFLLEVBQUUsRUFIb0I7QUFJM0JVLFFBQUFBLGdCQUFnQixFQUFFLElBSlM7QUFLM0JDLFFBQUFBLHVCQUF1QixFQUFFLElBTEU7QUFNM0JDLFFBQUFBLG9CQUFvQixFQUFFLElBTks7QUFPM0JDLFFBQUFBLFNBQVMsRUFBRSxxQkFBTSxDQUFFLENBUFE7QUFRM0JDLFFBQUFBLFdBQVcsRUFBRTtBQVJjLE9BQTdCO0FBV0EsV0FBS0MsaUJBQUwsQ0FBdUJQLG9CQUF2QixFQUE2Q2hDLEtBQTdDO0FBQ0Q7Ozs0Q0FFa0RBLEssRUFBcUM7QUFBQSxVQUFwRUssU0FBb0UsUUFBcEVBLFNBQW9FO0FBQ3RGTCxNQUFBQSxLQUFLLENBQUN3QyxjQUFOLENBQXFCLE1BQXJCO0FBQ0Q7Ozs7RUE3R2tDQyxvQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCB0eXBlIHsgQ2xpY2tFdmVudCwgUG9pbnRlck1vdmVFdmVudCwgTW9kZVByb3BzLCBHdWlkZUZlYXR1cmVDb2xsZWN0aW9uIH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHR5cGUgeyBQb2x5Z29uLCBGZWF0dXJlQ29sbGVjdGlvbiB9IGZyb20gJy4uL2dlb2pzb24tdHlwZXMuanMnO1xuaW1wb3J0IHsgZ2V0UGlja2VkRWRpdEhhbmRsZSB9IGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCB7IEJhc2VHZW9Kc29uRWRpdE1vZGUgfSBmcm9tICcuL2dlb2pzb24tZWRpdC1tb2RlLmpzJztcblxuZXhwb3J0IGNsYXNzIERyYXdQb2x5Z29uTW9kZSBleHRlbmRzIEJhc2VHZW9Kc29uRWRpdE1vZGUge1xuICBnZXRHdWlkZXMocHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pOiBHdWlkZUZlYXR1cmVDb2xsZWN0aW9uIHtcbiAgICBjb25zdCB7IGxhc3RQb2ludGVyTW92ZUV2ZW50IH0gPSBwcm9wcztcbiAgICBjb25zdCBjbGlja1NlcXVlbmNlID0gdGhpcy5nZXRDbGlja1NlcXVlbmNlKCk7XG5cbiAgICBjb25zdCBsYXN0Q29vcmRzID0gbGFzdFBvaW50ZXJNb3ZlRXZlbnQgPyBbbGFzdFBvaW50ZXJNb3ZlRXZlbnQubWFwQ29vcmRzXSA6IFtdO1xuXG4gICAgY29uc3QgZ3VpZGVzID0ge1xuICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgIGZlYXR1cmVzOiBbXVxuICAgIH07XG5cbiAgICBsZXQgdGVudGF0aXZlRmVhdHVyZTtcbiAgICBpZiAoY2xpY2tTZXF1ZW5jZS5sZW5ndGggPT09IDEgfHwgY2xpY2tTZXF1ZW5jZS5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRlbnRhdGl2ZUZlYXR1cmUgPSB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGd1aWRlVHlwZTogJ3RlbnRhdGl2ZSdcbiAgICAgICAgfSxcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICB0eXBlOiAnTGluZVN0cmluZycsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IFsuLi5jbGlja1NlcXVlbmNlLCAuLi5sYXN0Q29vcmRzXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoY2xpY2tTZXF1ZW5jZS5sZW5ndGggPiAyKSB7XG4gICAgICB0ZW50YXRpdmVGZWF0dXJlID0ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBndWlkZVR5cGU6ICd0ZW50YXRpdmUnXG4gICAgICAgIH0sXG4gICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgdHlwZTogJ1BvbHlnb24nLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiBbWy4uLmNsaWNrU2VxdWVuY2UsIC4uLmxhc3RDb29yZHMsIGNsaWNrU2VxdWVuY2VbMF1dXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0ZW50YXRpdmVGZWF0dXJlKSB7XG4gICAgICBndWlkZXMuZmVhdHVyZXMucHVzaCh0ZW50YXRpdmVGZWF0dXJlKTtcbiAgICB9XG5cbiAgICBjb25zdCBlZGl0SGFuZGxlcyA9IGNsaWNrU2VxdWVuY2UubWFwKChjbGlja2VkQ29vcmQsIGluZGV4KSA9PiAoe1xuICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBndWlkZVR5cGU6ICdlZGl0SGFuZGxlJyxcbiAgICAgICAgZWRpdEhhbmRsZVR5cGU6ICdleGlzdGluZycsXG4gICAgICAgIGZlYXR1cmVJbmRleDogLTEsXG4gICAgICAgIHBvc2l0aW9uSW5kZXhlczogW2luZGV4XVxuICAgICAgfSxcbiAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjbGlja2VkQ29vcmRcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBndWlkZXMuZmVhdHVyZXMucHVzaCguLi5lZGl0SGFuZGxlcyk7XG5cbiAgICByZXR1cm4gZ3VpZGVzO1xuICB9XG5cbiAgaGFuZGxlQ2xpY2soZXZlbnQ6IENsaWNrRXZlbnQsIHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KSB7XG4gICAgY29uc3QgeyBwaWNrcyB9ID0gZXZlbnQ7XG4gICAgY29uc3QgY2xpY2tlZEVkaXRIYW5kbGUgPSBnZXRQaWNrZWRFZGl0SGFuZGxlKHBpY2tzKTtcblxuICAgIGlmICghY2xpY2tlZEVkaXRIYW5kbGUpIHtcbiAgICAgIC8vIERvbid0IGFkZCBhbm90aGVyIHBvaW50IHJpZ2h0IG5leHQgdG8gYW4gZXhpc3Rpbmcgb25lXG4gICAgICB0aGlzLmFkZENsaWNrU2VxdWVuY2UoZXZlbnQpO1xuICAgIH1cbiAgICBjb25zdCBjbGlja1NlcXVlbmNlID0gdGhpcy5nZXRDbGlja1NlcXVlbmNlKCk7XG5cbiAgICBpZiAoXG4gICAgICBjbGlja1NlcXVlbmNlLmxlbmd0aCA+IDIgJiZcbiAgICAgIGNsaWNrZWRFZGl0SGFuZGxlICYmXG4gICAgICAoY2xpY2tlZEVkaXRIYW5kbGUucHJvcGVydGllcy5wb3NpdGlvbkluZGV4ZXNbMF0gPT09IDAgfHxcbiAgICAgICAgY2xpY2tlZEVkaXRIYW5kbGUucHJvcGVydGllcy5wb3NpdGlvbkluZGV4ZXNbMF0gPT09IGNsaWNrU2VxdWVuY2UubGVuZ3RoIC0gMSlcbiAgICApIHtcbiAgICAgIC8vIFRoZXkgY2xpY2tlZCB0aGUgZmlyc3Qgb3IgbGFzdCBwb2ludCAob3IgZG91YmxlLWNsaWNrZWQpLCBzbyBjb21wbGV0ZSB0aGUgcG9seWdvblxuXG4gICAgICAvLyBSZW1vdmUgdGhlIGhvdmVyZWQgcG9zaXRpb25cbiAgICAgIGNvbnN0IHBvbHlnb25Ub0FkZDogUG9seWdvbiA9IHtcbiAgICAgICAgdHlwZTogJ1BvbHlnb24nLFxuICAgICAgICBjb29yZGluYXRlczogW1suLi5jbGlja1NlcXVlbmNlLCBjbGlja1NlcXVlbmNlWzBdXV1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMucmVzZXRDbGlja1NlcXVlbmNlKCk7XG5cbiAgICAgIGNvbnN0IGVkaXRBY3Rpb24gPSB0aGlzLmdldEFkZEZlYXR1cmVPckJvb2xlYW5Qb2x5Z29uQWN0aW9uKHBvbHlnb25Ub0FkZCwgcHJvcHMpO1xuICAgICAgaWYgKGVkaXRBY3Rpb24pIHtcbiAgICAgICAgcHJvcHMub25FZGl0KGVkaXRBY3Rpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyaWdnZXIgcG9pbnRlciBtb3ZlIHJpZ2h0IGF3YXkgaW4gb3JkZXIgZm9yIGl0IHRvIHVwZGF0ZSBlZGl0IGhhbmRsZXMgKHRvIHN1cHBvcnQgZG91YmxlLWNsaWNrKVxuICAgIGNvbnN0IGZha2VQb2ludGVyTW92ZUV2ZW50ID0ge1xuICAgICAgc2NyZWVuQ29vcmRzOiBbLTEsIC0xXSxcbiAgICAgIG1hcENvb3JkczogZXZlbnQubWFwQ29vcmRzLFxuICAgICAgcGlja3M6IFtdLFxuICAgICAgcG9pbnRlckRvd25QaWNrczogbnVsbCxcbiAgICAgIHBvaW50ZXJEb3duU2NyZWVuQ29vcmRzOiBudWxsLFxuICAgICAgcG9pbnRlckRvd25NYXBDb29yZHM6IG51bGwsXG4gICAgICBjYW5jZWxQYW46ICgpID0+IHt9LFxuICAgICAgc291cmNlRXZlbnQ6IG51bGxcbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVQb2ludGVyTW92ZShmYWtlUG9pbnRlck1vdmVFdmVudCwgcHJvcHMpO1xuICB9XG5cbiAgaGFuZGxlUG9pbnRlck1vdmUoeyBtYXBDb29yZHMgfTogUG9pbnRlck1vdmVFdmVudCwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pIHtcbiAgICBwcm9wcy5vblVwZGF0ZUN1cnNvcignY2VsbCcpO1xuICB9XG59XG4iXX0=