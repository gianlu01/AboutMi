"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompositeMode = void 0;

var _geojsonEditMode = require("./geojson-edit-mode.js");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var CompositeMode =
/*#__PURE__*/
function (_BaseGeoJsonEditMode) {
  _inherits(CompositeMode, _BaseGeoJsonEditMode);

  function CompositeMode(modes) {
    var _this;

    _classCallCheck(this, CompositeMode);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CompositeMode).call(this));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_modes", void 0);

    _this._modes = modes;
    return _this;
  }

  _createClass(CompositeMode, [{
    key: "_coalesce",
    value: function _coalesce(callback) {
      var resultEval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var result;

      for (var i = 0; i < this._modes.length; i++) {
        result = callback(this._modes[i]);

        if (resultEval ? resultEval(result) : result) {
          break;
        }
      }

      return result;
    }
  }, {
    key: "handleClick",
    value: function handleClick(event, props) {
      this._coalesce(function (handler) {
        return handler.handleClick(event, props);
      });
    }
  }, {
    key: "handlePointerMove",
    value: function handlePointerMove(event, props) {
      return this._coalesce(function (handler) {
        return handler.handlePointerMove(event, props);
      });
    }
  }, {
    key: "handleStartDragging",
    value: function handleStartDragging(event, props) {
      return this._coalesce(function (handler) {
        return handler.handleStartDragging(event, props);
      });
    }
  }, {
    key: "handleStopDragging",
    value: function handleStopDragging(event, props) {
      return this._coalesce(function (handler) {
        return handler.handleStopDragging(event, props);
      });
    }
  }, {
    key: "handleDragging",
    value: function handleDragging(event, props) {
      return this._coalesce(function (handler) {
        return handler.handleDragging(event, props);
      });
    }
  }, {
    key: "getGuides",
    value: function getGuides(props) {
      // TODO: Combine the guides *BUT* make sure if none of the results have
      // changed to return the same object so that "guides !== this.state.guides"
      // in editable-geojson-layer works.
      var allGuides = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._modes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var mode = _step.value;
          allGuides.push.apply(allGuides, _toConsumableArray(mode.getGuides(props).features));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return {
        type: 'FeatureCollection',
        features: allGuides
      };
    }
  }]);

  return CompositeMode;
}(_geojsonEditMode.BaseGeoJsonEditMode);

exports.CompositeMode = CompositeMode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvY29tcG9zaXRlLW1vZGUuanMiXSwibmFtZXMiOlsiQ29tcG9zaXRlTW9kZSIsIm1vZGVzIiwiX21vZGVzIiwiY2FsbGJhY2siLCJyZXN1bHRFdmFsIiwicmVzdWx0IiwiaSIsImxlbmd0aCIsImV2ZW50IiwicHJvcHMiLCJfY29hbGVzY2UiLCJoYW5kbGVyIiwiaGFuZGxlQ2xpY2siLCJoYW5kbGVQb2ludGVyTW92ZSIsImhhbmRsZVN0YXJ0RHJhZ2dpbmciLCJoYW5kbGVTdG9wRHJhZ2dpbmciLCJoYW5kbGVEcmFnZ2luZyIsImFsbEd1aWRlcyIsIm1vZGUiLCJwdXNoIiwiZ2V0R3VpZGVzIiwiZmVhdHVyZXMiLCJ0eXBlIiwiQmFzZUdlb0pzb25FZGl0TW9kZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFYUEsYTs7Ozs7QUFHWCx5QkFBWUMsS0FBWixFQUErQztBQUFBOztBQUFBOztBQUM3Qzs7QUFENkM7O0FBRTdDLFVBQUtDLE1BQUwsR0FBY0QsS0FBZDtBQUY2QztBQUc5Qzs7Ozs4QkFFWUUsUSxFQUEyRTtBQUFBLFVBQXZDQyxVQUF1Qyx1RUFBVCxJQUFTO0FBQ3RGLFVBQUlDLE1BQUo7O0FBRUEsV0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUtKLE1BQUwsQ0FBWUssTUFBaEMsRUFBd0NELENBQUMsRUFBekMsRUFBNkM7QUFDM0NELFFBQUFBLE1BQU0sR0FBR0YsUUFBUSxDQUFDLEtBQUtELE1BQUwsQ0FBWUksQ0FBWixDQUFELENBQWpCOztBQUNBLFlBQUlGLFVBQVUsR0FBR0EsVUFBVSxDQUFDQyxNQUFELENBQWIsR0FBd0JBLE1BQXRDLEVBQThDO0FBQzVDO0FBQ0Q7QUFDRjs7QUFFRCxhQUFRQSxNQUFSO0FBQ0Q7OztnQ0FFV0csSyxFQUFtQkMsSyxFQUEyQztBQUN4RSxXQUFLQyxTQUFMLENBQWUsVUFBQUMsT0FBTztBQUFBLGVBQUlBLE9BQU8sQ0FBQ0MsV0FBUixDQUFvQkosS0FBcEIsRUFBMkJDLEtBQTNCLENBQUo7QUFBQSxPQUF0QjtBQUNEOzs7c0NBRWlCRCxLLEVBQXlCQyxLLEVBQTJDO0FBQ3BGLGFBQU8sS0FBS0MsU0FBTCxDQUFlLFVBQUFDLE9BQU87QUFBQSxlQUFJQSxPQUFPLENBQUNFLGlCQUFSLENBQTBCTCxLQUExQixFQUFpQ0MsS0FBakMsQ0FBSjtBQUFBLE9BQXRCLENBQVA7QUFDRDs7O3dDQUVtQkQsSyxFQUEyQkMsSyxFQUEyQztBQUN4RixhQUFPLEtBQUtDLFNBQUwsQ0FBZSxVQUFBQyxPQUFPO0FBQUEsZUFBSUEsT0FBTyxDQUFDRyxtQkFBUixDQUE0Qk4sS0FBNUIsRUFBbUNDLEtBQW5DLENBQUo7QUFBQSxPQUF0QixDQUFQO0FBQ0Q7Ozt1Q0FFa0JELEssRUFBMEJDLEssRUFBMkM7QUFDdEYsYUFBTyxLQUFLQyxTQUFMLENBQWUsVUFBQUMsT0FBTztBQUFBLGVBQUlBLE9BQU8sQ0FBQ0ksa0JBQVIsQ0FBMkJQLEtBQTNCLEVBQWtDQyxLQUFsQyxDQUFKO0FBQUEsT0FBdEIsQ0FBUDtBQUNEOzs7bUNBRWNELEssRUFBc0JDLEssRUFBMkM7QUFDOUUsYUFBTyxLQUFLQyxTQUFMLENBQWUsVUFBQUMsT0FBTztBQUFBLGVBQUlBLE9BQU8sQ0FBQ0ssY0FBUixDQUF1QlIsS0FBdkIsRUFBOEJDLEtBQTlCLENBQUo7QUFBQSxPQUF0QixDQUFQO0FBQ0Q7Ozs4QkFFU0EsSyxFQUE2RDtBQUNyRTtBQUNBO0FBQ0E7QUFFQSxVQUFNUSxTQUFTLEdBQUcsRUFBbEI7QUFMcUU7QUFBQTtBQUFBOztBQUFBO0FBTXJFLDZCQUFtQixLQUFLZixNQUF4Qiw4SEFBZ0M7QUFBQSxjQUFyQmdCLElBQXFCO0FBQzlCRCxVQUFBQSxTQUFTLENBQUNFLElBQVYsT0FBQUYsU0FBUyxxQkFBU0MsSUFBSSxDQUFDRSxTQUFMLENBQWVYLEtBQWYsRUFBc0JZLFFBQS9CLEVBQVQ7QUFDRDtBQVJvRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVVyRSxhQUFPO0FBQ0xDLFFBQUFBLElBQUksRUFBRSxtQkFERDtBQUVMRCxRQUFBQSxRQUFRLEVBQUVKO0FBRkwsT0FBUDtBQUlEOzs7O0VBdkRnQ00sb0MiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQgdHlwZSB7IEZlYXR1cmVDb2xsZWN0aW9uIH0gZnJvbSAnLi4vZ2VvanNvbi10eXBlcy5qcyc7XG5pbXBvcnQgdHlwZSB7XG4gIE1vZGVQcm9wcyxcbiAgQ2xpY2tFdmVudCxcbiAgUG9pbnRlck1vdmVFdmVudCxcbiAgU3RhcnREcmFnZ2luZ0V2ZW50LFxuICBTdG9wRHJhZ2dpbmdFdmVudCxcbiAgRHJhZ2dpbmdFdmVudCxcbiAgR3VpZGVGZWF0dXJlQ29sbGVjdGlvblxufSBmcm9tICcuLi90eXBlcy5qcyc7XG5pbXBvcnQgeyBCYXNlR2VvSnNvbkVkaXRNb2RlIH0gZnJvbSAnLi9nZW9qc29uLWVkaXQtbW9kZS5qcyc7XG5cbmV4cG9ydCBjbGFzcyBDb21wb3NpdGVNb2RlIGV4dGVuZHMgQmFzZUdlb0pzb25FZGl0TW9kZSB7XG4gIF9tb2RlczogQXJyYXk8QmFzZUdlb0pzb25FZGl0TW9kZT47XG5cbiAgY29uc3RydWN0b3IobW9kZXM6IEFycmF5PEJhc2VHZW9Kc29uRWRpdE1vZGU+KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9tb2RlcyA9IG1vZGVzO1xuICB9XG5cbiAgX2NvYWxlc2NlPFQ+KGNhbGxiYWNrOiBCYXNlR2VvSnNvbkVkaXRNb2RlID0+IFQsIHJlc3VsdEV2YWw6ID8oVCkgPT4gYm9vbGVhbiA9IG51bGwpOiBUIHtcbiAgICBsZXQgcmVzdWx0OiBUO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9tb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0ID0gY2FsbGJhY2sodGhpcy5fbW9kZXNbaV0pO1xuICAgICAgaWYgKHJlc3VsdEV2YWwgPyByZXN1bHRFdmFsKHJlc3VsdCkgOiByZXN1bHQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChyZXN1bHQ6IGFueSk7XG4gIH1cblxuICBoYW5kbGVDbGljayhldmVudDogQ2xpY2tFdmVudCwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pOiB2b2lkIHtcbiAgICB0aGlzLl9jb2FsZXNjZShoYW5kbGVyID0+IGhhbmRsZXIuaGFuZGxlQ2xpY2soZXZlbnQsIHByb3BzKSk7XG4gIH1cblxuICBoYW5kbGVQb2ludGVyTW92ZShldmVudDogUG9pbnRlck1vdmVFdmVudCwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pOiB2b2lkIHtcbiAgICByZXR1cm4gdGhpcy5fY29hbGVzY2UoaGFuZGxlciA9PiBoYW5kbGVyLmhhbmRsZVBvaW50ZXJNb3ZlKGV2ZW50LCBwcm9wcykpO1xuICB9XG5cbiAgaGFuZGxlU3RhcnREcmFnZ2luZyhldmVudDogU3RhcnREcmFnZ2luZ0V2ZW50LCBwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPik6IHZvaWQge1xuICAgIHJldHVybiB0aGlzLl9jb2FsZXNjZShoYW5kbGVyID0+IGhhbmRsZXIuaGFuZGxlU3RhcnREcmFnZ2luZyhldmVudCwgcHJvcHMpKTtcbiAgfVxuXG4gIGhhbmRsZVN0b3BEcmFnZ2luZyhldmVudDogU3RvcERyYWdnaW5nRXZlbnQsIHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KTogdm9pZCB7XG4gICAgcmV0dXJuIHRoaXMuX2NvYWxlc2NlKGhhbmRsZXIgPT4gaGFuZGxlci5oYW5kbGVTdG9wRHJhZ2dpbmcoZXZlbnQsIHByb3BzKSk7XG4gIH1cblxuICBoYW5kbGVEcmFnZ2luZyhldmVudDogRHJhZ2dpbmdFdmVudCwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pOiB2b2lkIHtcbiAgICByZXR1cm4gdGhpcy5fY29hbGVzY2UoaGFuZGxlciA9PiBoYW5kbGVyLmhhbmRsZURyYWdnaW5nKGV2ZW50LCBwcm9wcykpO1xuICB9XG5cbiAgZ2V0R3VpZGVzKHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KTogR3VpZGVGZWF0dXJlQ29sbGVjdGlvbiB7XG4gICAgLy8gVE9ETzogQ29tYmluZSB0aGUgZ3VpZGVzICpCVVQqIG1ha2Ugc3VyZSBpZiBub25lIG9mIHRoZSByZXN1bHRzIGhhdmVcbiAgICAvLyBjaGFuZ2VkIHRvIHJldHVybiB0aGUgc2FtZSBvYmplY3Qgc28gdGhhdCBcImd1aWRlcyAhPT0gdGhpcy5zdGF0ZS5ndWlkZXNcIlxuICAgIC8vIGluIGVkaXRhYmxlLWdlb2pzb24tbGF5ZXIgd29ya3MuXG5cbiAgICBjb25zdCBhbGxHdWlkZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG1vZGUgb2YgdGhpcy5fbW9kZXMpIHtcbiAgICAgIGFsbEd1aWRlcy5wdXNoKC4uLm1vZGUuZ2V0R3VpZGVzKHByb3BzKS5mZWF0dXJlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICBmZWF0dXJlczogYWxsR3VpZGVzXG4gICAgfTtcbiAgfVxufVxuIl19