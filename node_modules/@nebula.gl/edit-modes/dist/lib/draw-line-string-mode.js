"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawLineStringMode = void 0;

var _geojsonEditMode = require("./geojson-edit-mode.js");

var _immutableFeatureCollection = require("./immutable-feature-collection.js");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var DrawLineStringMode =
/*#__PURE__*/
function (_BaseGeoJsonEditMode) {
  _inherits(DrawLineStringMode, _BaseGeoJsonEditMode);

  function DrawLineStringMode() {
    _classCallCheck(this, DrawLineStringMode);

    return _possibleConstructorReturn(this, _getPrototypeOf(DrawLineStringMode).apply(this, arguments));
  }

  _createClass(DrawLineStringMode, [{
    key: "handleClick",
    value: function handleClick(event, props) {
      var selectedFeatureIndexes = props.selectedIndexes;
      var selectedGeometry = this.getSelectedGeometry(props);

      if (selectedFeatureIndexes.length > 1 || selectedGeometry && selectedGeometry.type !== 'LineString') {
        console.warn("drawLineString mode only supported for single LineString selection"); // eslint-disable-line

        return;
      }

      this.addClickSequence(event);
      var tentativeFeature = this.getTentativeGuide(props);
      var clickSequence = this.getClickSequence();

      if (selectedGeometry && selectedGeometry.type === 'LineString') {
        // Extend the LineString
        var lineString = selectedGeometry;
        var positionIndexes = [lineString.coordinates.length];
        var modeConfig = props.modeConfig;

        if (modeConfig && modeConfig.drawAtFront) {
          positionIndexes = [0];
        }

        var featureIndex = selectedFeatureIndexes[0];
        var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).addPosition(featureIndex, positionIndexes, event.mapCoords).getObject();
        props.onEdit({
          updatedData: updatedData,
          editType: 'addPosition',
          editContext: {
            featureIndexes: [featureIndex],
            positionIndexes: positionIndexes,
            position: event.mapCoords
          }
        });
        this.resetClickSequence();
      } else if (clickSequence.length === 2 && tentativeFeature) {
        // Add a new LineString
        var geometry = tentativeFeature.geometry;
        props.onEdit(this.getAddFeatureAction(geometry, props.data));
        this.resetClickSequence();
      }
    }
  }, {
    key: "getGuides",
    value: function getGuides(props) {
      var guides = {
        type: 'FeatureCollection',
        features: []
      };
      var clickSequence = this.getClickSequence();
      var mapCoords = props.lastPointerMoveEvent && props.lastPointerMoveEvent.mapCoords;
      var startPosition = null;
      var selectedFeatureIndexes = props.selectedIndexes;
      var selectedGeometry = this.getSelectedGeometry(props);

      if (selectedFeatureIndexes.length > 1 || selectedGeometry && selectedGeometry.type !== 'LineString') {
        // unsupported
        return guides;
      }

      if (selectedGeometry && selectedGeometry.type === 'LineString') {
        // Draw an extension line starting from one end of the selected LineString
        startPosition = selectedGeometry.coordinates[selectedGeometry.coordinates.length - 1];
        var modeConfig = props.modeConfig;

        if (modeConfig && modeConfig.drawAtFront) {
          startPosition = selectedGeometry.coordinates[0];
        }
      } else if (clickSequence.length > 0) {
        startPosition = clickSequence[0];
      }

      if (startPosition) {
        guides.features.push({
          type: 'Feature',
          properties: {
            guideType: 'tentative'
          },
          geometry: {
            type: 'LineString',
            coordinates: [startPosition, mapCoords]
          }
        });
      }

      return guides;
    }
  }, {
    key: "handlePointerMove",
    value: function handlePointerMove(event, props) {
      props.onUpdateCursor('cell');
    }
  }]);

  return DrawLineStringMode;
}(_geojsonEditMode.BaseGeoJsonEditMode);

exports.DrawLineStringMode = DrawLineStringMode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZHJhdy1saW5lLXN0cmluZy1tb2RlLmpzIl0sIm5hbWVzIjpbIkRyYXdMaW5lU3RyaW5nTW9kZSIsImV2ZW50IiwicHJvcHMiLCJzZWxlY3RlZEZlYXR1cmVJbmRleGVzIiwic2VsZWN0ZWRJbmRleGVzIiwic2VsZWN0ZWRHZW9tZXRyeSIsImdldFNlbGVjdGVkR2VvbWV0cnkiLCJsZW5ndGgiLCJ0eXBlIiwiY29uc29sZSIsIndhcm4iLCJhZGRDbGlja1NlcXVlbmNlIiwidGVudGF0aXZlRmVhdHVyZSIsImdldFRlbnRhdGl2ZUd1aWRlIiwiY2xpY2tTZXF1ZW5jZSIsImdldENsaWNrU2VxdWVuY2UiLCJsaW5lU3RyaW5nIiwicG9zaXRpb25JbmRleGVzIiwiY29vcmRpbmF0ZXMiLCJtb2RlQ29uZmlnIiwiZHJhd0F0RnJvbnQiLCJmZWF0dXJlSW5kZXgiLCJ1cGRhdGVkRGF0YSIsIkltbXV0YWJsZUZlYXR1cmVDb2xsZWN0aW9uIiwiZGF0YSIsImFkZFBvc2l0aW9uIiwibWFwQ29vcmRzIiwiZ2V0T2JqZWN0Iiwib25FZGl0IiwiZWRpdFR5cGUiLCJlZGl0Q29udGV4dCIsImZlYXR1cmVJbmRleGVzIiwicG9zaXRpb24iLCJyZXNldENsaWNrU2VxdWVuY2UiLCJnZW9tZXRyeSIsImdldEFkZEZlYXR1cmVBY3Rpb24iLCJndWlkZXMiLCJmZWF0dXJlcyIsImxhc3RQb2ludGVyTW92ZUV2ZW50Iiwic3RhcnRQb3NpdGlvbiIsInB1c2giLCJwcm9wZXJ0aWVzIiwiZ3VpZGVUeXBlIiwib25VcGRhdGVDdXJzb3IiLCJCYXNlR2VvSnNvbkVkaXRNb2RlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBSUE7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRWFBLGtCOzs7Ozs7Ozs7Ozs7O2dDQUNDQyxLLEVBQW1CQyxLLEVBQXFDO0FBQ2xFLFVBQU1DLHNCQUFzQixHQUFHRCxLQUFLLENBQUNFLGVBQXJDO0FBQ0EsVUFBTUMsZ0JBQWdCLEdB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LFlBQWxELEVBQWdFO0FBQzlEO0FBQ0ErQixRQUFBQSxhQUFhLEdBQUdsQyxnQkFBZ0IsQ0FBQ2EsV0FBakIsQ0FBNkJiLGdCQUFnQixDQUFDYSxXQUFqQixDQUE2QlgsTUFBN0IsR0FBc0MsQ0FBbkUsQ0FBaEI7QUFFQSxZQUFNWSxVQUFVLEdBQUdqQixLQUFLLENBQUNpQixVQUF6Qjs7QUFDQSxZQUFJQSxVQUFVLElBQUlBLFVBQVUsQ0FBQ0MsV0FBN0IsRUFBMEM7QUFDeENtQixVQUFBQSxhQUFhLEdBQUdsQyxnQkFBZ0IsQ0FBQ2EsV0FBakIsQ0FBNkIsQ0FBN0IsQ0FBaEI7QUFDRDtBQUNGLE9BUkQsTUFRTyxJQUFJSixhQUFhLENBQUNQLE1BQWQsR0FBdUIsQ0FBM0IsRUFBOEI7QUFDbkNnQyxRQUFBQSxhQUFhLEdBQUd6QixhQUFhLENBQUMsQ0FBRCxDQUE3QjtBQUNEOztBQUVELFVBQUl5QixhQUFKLEVBQW1CO0FBQ2pCSCxRQUFBQSxNQUFNLENBQUNDLFFBQVAsQ0FBZ0JHLElBQWhCLENBQXFCO0FBQ25CaEMsVUFBQUEsSUFBSSxFQUFFLFNBRGE7QUFFbkJpQyxVQUFBQSxVQUFVLEVBQUU7QUFDVkMsWUFBQUEsU0FBUyxFQUFFO0FBREQsV0FGTztBQUtuQlIsVUFBQUEsUUFBUSxFQUFFO0FBQ1IxQixZQUFBQSxJQUFJLEVBQUUsWUFERTtBQUVSVSxZQUFBQSxXQUFXLEVBQUUsQ0FBQ3FCLGFBQUQsRUFBZ0JiLFNBQWhCO0FBRkw7QUFMUyxTQUFyQjtBQVVEOztBQUVELGFBQU9VLE1BQVA7QUFDRDs7O3NDQUVpQm5DLEssRUFBeUJDLEssRUFBcUM7QUFDOUVBLE1BQUFBLEtBQUssQ0FBQ3lDLGNBQU4sQ0FBcUIsTUFBckI7QUFDRDs7OztFQXZHcUNDLG9DIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxuaW1wb3J0IHR5cGUgeyBQb3NpdGlvbiwgTGluZVN0cmluZywgRmVhdHVyZUNvbGxlY3Rpb24gfSBmcm9tICcuLi9nZW9qc29uLXR5cGVzLmpzJztcbmltcG9ydCB0eXBlIHsgQ2xpY2tFdmVudCwgUG9pbnRlck1vdmVFdmVudCwgTW9kZVByb3BzLCBHdWlkZUZlYXR1cmVDb2xsZWN0aW9uIH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHsgQmFzZUdlb0pzb25FZGl0TW9kZSB9IGZyb20gJy4vZ2VvanNvbi1lZGl0LW1vZGUuanMnO1xuaW1wb3J0IHsgSW1tdXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24gfSBmcm9tICcuL2ltbXV0YWJsZS1mZWF0dXJlLWNvbGxlY3Rpb24uanMnO1xuXG5leHBvcnQgY2xhc3MgRHJhd0xpbmVTdHJpbmdNb2RlIGV4dGVuZHMgQmFzZUdlb0pzb25FZGl0TW9kZSB7XG4gIGhhbmRsZUNsaWNrKGV2ZW50OiBDbGlja0V2ZW50LCBwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPikge1xuICAgIGNvbnN0IHNlbGVjdGVkRmVhdHVyZUluZGV4ZXMgPSBwcm9wcy5zZWxlY3RlZEluZGV4ZXM7XG4gICAgY29uc3Qgc2VsZWN0ZWRHZW9tZXRyeSA9IHRoaXMuZ2V0U2VsZWN0ZWRHZW9tZXRyeShwcm9wcyk7XG5cbiAgICBpZiAoXG4gICAgICBzZWxlY3RlZEZlYXR1cmVJbmRleGVzLmxlbmd0aCA+IDEgfHxcbiAgICAgIChzZWxlY3RlZEdlb21ldHJ5ICYmIHNlbGVjdGVkR2VvbWV0cnkudHlwZSAhPT0gJ0xpbmVTdHJpbmcnKVxuICAgICkge1xuICAgICAgY29uc29sZS53YXJuKGBkcmF3TGluZVN0cmluZyBtb2RlIG9ubHkgc3VwcG9ydGVkIGZvciBzaW5nbGUgTGluZVN0cmluZyBzZWxlY3Rpb25gKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYWRkQ2xpY2tTZXF1ZW5jZShldmVudCk7XG4gICAgY29uc3QgdGVudGF0aXZlRmVhdHVyZSA9IHRoaXMuZ2V0VGVudGF0aXZlR3VpZGUocHJvcHMpO1xuICAgIGNvbnN0IGNsaWNrU2VxdWVuY2UgPSB0aGlzLmdldENsaWNrU2VxdWVuY2UoKTtcblxuICAgIGlmIChzZWxlY3RlZEdlb21ldHJ5ICYmIHNlbGVjdGVkR2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAvLyBFeHRlbmQgdGhlIExpbmVTdHJpbmdcbiAgICAgIGNvbnN0IGxpbmVTdHJpbmc6IExpbmVTdHJpbmcgPSBzZWxlY3RlZEdlb21ldHJ5O1xuXG4gICAgICBsZXQgcG9zaXRpb25JbmRleGVzID0gW2xpbmVTdHJpbmcuY29vcmRpbmF0ZXMubGVuZ3RoXTtcblxuICAgICAgY29uc3QgbW9kZUNvbmZpZyA9IHByb3BzLm1vZGVDb25maWc7XG4gICAgICBpZiAobW9kZUNvbmZpZyAmJiBtb2RlQ29uZmlnLmRyYXdBdEZyb250KSB7XG4gICAgICAgIHBvc2l0aW9uSW5kZXhlcyA9IFswXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZlYXR1cmVJbmRleCA9IHNlbGVjdGVkRmVhdHVyZUluZGV4ZXNbMF07XG4gICAgICBjb25zdCB1cGRhdGVkRGF0YSA9IG5ldyBJbW11dGFibGVGZWF0dXJlQ29sbGVjdGlvbihwcm9wcy5kYXRhKVxuICAgICAgICAuYWRkUG9zaXRpb24oZmVhdHVyZUluZGV4LCBwb3NpdGlvbkluZGV4ZXMsIGV2ZW50Lm1hcENvb3JkcylcbiAgICAgICAgLmdldE9iamVjdCgpO1xuXG4gICAgICBwcm9wcy5vbkVkaXQoe1xuICAgICAgICB1cGRhdGVkRGF0YSxcbiAgICAgICAgZWRpdFR5cGU6ICdhZGRQb3NpdGlvbicsXG4gICAgICAgIGVkaXRDb250ZXh0OiB7XG4gICAgICAgICAgZmVhdHVyZUluZGV4ZXM6IFtmZWF0dXJlSW5kZXhdLFxuICAgICAgICAgIHBvc2l0aW9uSW5kZXhlcyxcbiAgICAgICAgICBwb3NpdGlvbjogZXZlbnQubWFwQ29vcmRzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnJlc2V0Q2xpY2tTZXF1ZW5jZSgpO1xuICAgIH0gZWxzZSBpZiAoY2xpY2tTZXF1ZW5jZS5sZW5ndGggPT09IDIgJiYgdGVudGF0aXZlRmVhdHVyZSkge1xuICAgICAgLy8gQWRkIGEgbmV3IExpbmVTdHJpbmdcbiAgICAgIGNvbnN0IHsgZ2VvbWV0cnkgfSA9IHRlbnRhdGl2ZUZlYXR1cmU7XG4gICAgICBwcm9wcy5vbkVkaXQodGhpcy5nZXRBZGRGZWF0dXJlQWN0aW9uKGdlb21ldHJ5LCBwcm9wcy5kYXRhKSk7XG5cbiAgICAgIHRoaXMucmVzZXRDbGlja1NlcXVlbmNlKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0R3VpZGVzKHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KTogR3VpZGVGZWF0dXJlQ29sbGVjdGlvbiB7XG4gICAgY29uc3QgZ3VpZGVzID0ge1xuICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgIGZlYXR1cmVzOiBbXVxuICAgIH07XG5cbiAgICBjb25zdCBjbGlja1NlcXVlbmNlID0gdGhpcy5nZXRDbGlja1NlcXVlbmNlKCk7XG4gICAgY29uc3QgbWFwQ29vcmRzID0gcHJvcHMubGFzdFBvaW50ZXJNb3ZlRXZlbnQgJiYgcHJvcHMubGFzdFBvaW50ZXJNb3ZlRXZlbnQubWFwQ29vcmRzO1xuXG4gICAgbGV0IHN0YXJ0UG9zaXRpb246ID9Qb3NpdGlvbiA9IG51bGw7XG4gICAgY29uc3Qgc2VsZWN0ZWRGZWF0dXJlSW5kZXhlcyA9IHByb3BzLnNlbGVjdGVkSW5kZXhlcztcbiAgICBjb25zdCBzZWxlY3RlZEdlb21ldHJ5ID0gdGhpcy5nZXRTZWxlY3RlZEdlb21ldHJ5KHByb3BzKTtcblxuICAgIGlmIChcbiAgICAgIHNlbGVjdGVkRmVhdHVyZUluZGV4ZXMubGVuZ3RoID4gMSB8fFxuICAgICAgKHNlbGVjdGVkR2VvbWV0cnkgJiYgc2VsZWN0ZWRHZW9tZXRyeS50eXBlICE9PSAnTGluZVN0cmluZycpXG4gICAgKSB7XG4gICAgICAvLyB1bnN1cHBvcnRlZFxuICAgICAgcmV0dXJuIGd1aWRlcztcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0ZWRHZW9tZXRyeSAmJiBzZWxlY3RlZEdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgLy8gRHJhdyBhbiBleHRlbnNpb24gbGluZSBzdGFydGluZyBmcm9tIG9uZSBlbmQgb2YgdGhlIHNlbGVjdGVkIExpbmVTdHJpbmdcbiAgICAgIHN0YXJ0UG9zaXRpb24gPSBzZWxlY3RlZEdlb21ldHJ5LmNvb3JkaW5hdGVzW3NlbGVjdGVkR2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgIGNvbnN0IG1vZGVDb25maWcgPSBwcm9wcy5tb2RlQ29uZmlnO1xuICAgICAgaWYgKG1vZGVDb25maWcgJiYgbW9kZUNvbmZpZy5kcmF3QXRGcm9udCkge1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gc2VsZWN0ZWRHZW9tZXRyeS5jb29yZGluYXRlc1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNsaWNrU2VxdWVuY2UubGVuZ3RoID4gMCkge1xuICAgICAgc3RhcnRQb3NpdGlvbiA9IGNsaWNrU2VxdWVuY2VbMF07XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0UG9zaXRpb24pIHtcbiAgICAgIGd1aWRlcy5mZWF0dXJlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgZ3VpZGVUeXBlOiAndGVudGF0aXZlJ1xuICAgICAgICB9LFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAgICAgICAgICBjb29yZGluYXRlczogW3N0YXJ0UG9zaXRpb24sIG1hcENvb3Jkc11cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGd1aWRlcztcbiAgfVxuXG4gIGhhbmRsZVBvaW50ZXJNb3ZlKGV2ZW50OiBQb2ludGVyTW92ZUV2ZW50LCBwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPikge1xuICAgIHByb3BzLm9uVXBkYXRlQ3Vyc29yKCdjZWxsJyk7XG4gIH1cbn1cbiJdfQ==