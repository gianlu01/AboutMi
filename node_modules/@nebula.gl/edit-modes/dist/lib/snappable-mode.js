"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SnappableMode = void 0;

var _utils = require("../utils.js");

var _geojsonEditMode = require("./geojson-edit-mode.js");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SnappableMode =
/*#__PURE__*/
function (_BaseGeoJsonEditMode) {
  _inherits(SnappableMode, _BaseGeoJsonEditMode);

  function SnappableMode(handler) {
    var _this;

    _classCallCheck(this, SnappableMode);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SnappableMode).call(this));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handler", void 0);

    _this._handler = handler;
    return _this;
  }

  _createClass(SnappableMode, [{
    key: "_getSnappedMouseEvent",
    value: function _getSnappedMouseEvent(event, snapSource, snapTarget) {
      return Object.assign(event, {
        mapCoords: snapTarget.geometry.coordinates,
        pointerDownMapCoords: snapSource && snapSource.geometry.coordinates
      });
    }
  }, {
    key: "_getPickedSnapTarget",
    value: function _getPickedSnapTarget(picks) {
      return (0, _utils.getPickedEditHandles)(picks).find(function (handle) {
        return handle.properties.editHandleType === 'snap-target';
      });
    }
  }, {
    key: "_getPickedSnapSource",
    value: function _getPickedSnapSource(pointerDownPicks) {
      return (0, _utils.getPickedEditHandle)(pointerDownPicks);
    }
  }, {
    key: "_getUpdatedSnapSourceHandle",
    value: function _getUpdatedSnapSourceHandle(snapSourceHandle, data) {
      var _snapSourceHandle$pro = snapSourceHandle.properties,
          featureIndex = _snapSourceHandle$pro.featureIndex,
          positionIndexes = _snapSourceHandle$pro.positionIndexes;
      var snapSourceFeature = data.features[featureIndex]; // $FlowFixMe

      var snapSourceCoordinates = positionIndexes.reduce(function (a, b) {
        return a[b];
      }, snapSourceFeature.geometry.coordinates);
      return _objectSpread({}, snapSourceHandle, {
        geometry: {
          type: 'Point',
          coordinates: snapSourceCoordinates
        }
      });
    } // If additionalSnapTargets is present in modeConfig and is populated, this
    // method will return those features along with the features
    // that live in the current layer. Otherwise, this method will simply return the
    // features from the current layer

  }, {
    key: "_getSnapTargets",
    value: function _getSnapTargets(props) {
      var _ref = props.modeConfig || {},
          additionalSnapTargets = _ref.additionalSnapTargets;

      additionalSnapTargets = additionalSnapTargets || [];

      var features = _toConsumableArray(props.data.features).concat(_toConsumableArray(additionalSnapTargets));

      return features;
    }
  }, {
    key: "_getSnapTargetHandles",
    value: function _getSnapTargetHandles(props) {
      var handles = [];

      var features = this._getSnapTargets(props);

      for (var i = 0; i < features.length; i++) {
        // Filter out the currently selected feature(s)
        var isCurrentIndexFeatureNotSelected = !props.selectedIndexes.includes(i);

        if (isCurrentIndexFeatureNotSelected) {
          var geometry = features[i].geometry;
          handles.push.apply(handles, _toConsumableArray((0, _utils.getEditHandlesForGeometry)(geometry, i, 'snap-target')));
        }
      }

      return handles;
    } // If no snap handle has been picked, only display the edit handles of the
    // selected feature. If a snap handle has been picked, display said snap handle
    // along with all snappable points on all non-selected features.

  }, {
    key: "getGuides",
    value: function getGuides(props) {
      var modeConfig = props.modeConfig,
          lastPointerMoveEvent = props.lastPointerMoveEvent;

      var _ref2 = modeConfig || {},
          enableSnapping = _ref2.enableSnapping;

      var guides = {
        type: 'FeatureCollection',
        features: _toConsumableArray(this._handler.getGuides(props).features)
      };

      if (!enableSnapping) {
        return guides;
      }

      var snapSourceHandle = lastPointerMoveEvent && this._getPickedSnapSource(lastPointerMoveEvent.pointerDownPicks); // They started dragging a handle
      // So render the picked handle (in its updated location) and all possible snap targets


      if (snapSourceHandle) {
        var _guides$features;

        (_guides$features = guides.features).push.apply(_guides$features, _toConsumableArray(this._getSnapTargetHandles(props)).concat([this._getUpdatedSnapSourceHandle(snapSourceHandle, props.data)]));

        return guides;
      } // Render the possible snap source handles


      var features = props.data.features;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = props.selectedIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var index = _step.value;

          if (index < features.length) {
            var _guides$features2;

            var geometry = features[index].geometry;

            (_guides$features2 = guides.features).push.apply(_guides$features2, _toConsumableArray((0, _utils.getEditHandlesForGeometry)(geometry, index, 'snap-source')));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return guides;
    }
  }, {
    key: "_getSnapAwareEvent",
    value: function _getSnapAwareEvent(event, props) {
      var snapSource = this._getPickedSnapSource(props.lastPointerMoveEvent.pointerDownPicks);

      var snapTarget = this._getPickedSnapTarget(event.picks);

      return snapSource && snapTarget ? this._getSnappedMouseEvent(event, snapSource, snapTarget) : event;
    }
  }, {
    key: "handleStartDragging",
    value: function handleStartDragging(event, props) {
      this._handler.handleStartDragging(event, props);
    }
  }, {
    key: "handleStopDragging",
    value: function handleStopDragging(event, props) {
      this._handler.handleStopDragging(this._getSnapAwareEvent(event, props), props);
    }
  }, {
    key: "handleDragging",
    value: function handleDragging(event, props) {
      this._handler.handleDragging(this._getSnapAwareEvent(event, props), props);
    }
  }, {
    key: "handlePointerMove",
    value: function handlePointerMove(event, props) {
      this._handler.handlePointerMove(this._getSnapAwareEvent(event, props), props);
    }
  }]);

  return SnappableMode;
}(_geojsonEditMode.BaseGeoJsonEditMode);

exports.SnappableMode = SnappableMode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvc25hcHBhYmxlLW1vZGUuanMiXSwibmFtZXMiOlsiU25hcHBhYmxlTW9kZSIsImhhbmRsZXIiLCJfaGFuZGxlciIsImV2ZW50Iiwic25hcFNvdXJjZSIsInNuYXBUYXJnZXQiLCJPYmplY3QiLCJhc3NpZ24iLCJtYXBDb29yZHMiLCJnZW9tZXRyeSIsImNvb3JkaW5hdGVzIiwicG9pbnRlckRvd25NYXBDb29yZHMiLCJwaWNrcyIsImZpbmQiLCJoYW5kbGUiLCJwcm9wZXJ0aWVzIiwiZWRpdEhhbmRsZVR5cGUiLCJwb2ludGVyRG93blBpY2tzIiwic25hcFNvdXJjZUhhbmRsZSIsImRhdGEiLCJmZWF0dXJlSW5kZXgiLCJwb3NpdGlvbkluZGV4ZXMiLCJzbmFwU291cmNlRmVhdHVyZSIsImZlYXR1cmVzIiwic25hcFNvdXJjZUNvb3JkaW5hdGVzIiwicmVkdWNlIiwiYSIsImIiLCJ0eXBlIiwicHJvcHMiLCJtb2RlQ29uZmlnIiwiYWRkaXRpb25hbFNuYXBUYXJnZXRzIiwiaGFuZGxlcyIsIl9nZXRTbmFwVGFyZ2V0cyIsImkiLCJsZW5ndGgiLCJpc0N1cnJlbnRJbmRleEZlYXR1cmVOb3RTZWxlY3RlZCIsInNlbGVjdGVkSW5kZXhlcyIsImluY2x1ZGVzIiwicHVzaCIsImxhc3RQb2ludGVyTW92ZUV2ZW50IiwiZW5hYmxlU25hcHBpbmciLCJndWlkZXMiLCJnZXRHdWlkZXMiLCJfZ2V0UGlja2VkU25hcFNvdXJjZSIsIl9nZXRTbmFwVGFyZ2V0SGFuZGxlcyIsIl9nZXRVcGRhdGVkU25hcFNvdXJjZUhhbmRsZSIsImluZGV4IiwiX2dldFBpY2tlZFNuYXBUYXJnZXQiLCJfZ2V0U25hcHBlZE1vdXNlRXZlbnQiLCJoYW5kbGVTdGFydERyYWdnaW5nIiwiaGFuZGxlU3RvcERyYWdnaW5nIiwiX2dldFNuYXBBd2FyZUV2ZW50IiwiaGFuZGxlRHJhZ2dpbmciLCJoYW5kbGVQb2ludGVyTW92ZSIsIkJhc2VHZW9Kc29uRWRpdE1vZGUi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QUwsQ0FBY29ELGlCQUFkLENBQWdDLEtBQUtGLGtCQUFMLENBQXdCakQsS0FBeEIsRUFBK0IwQixLQUEvQixDQUFoQyxFQUF1RUEsS0FBdkU7QUFDRDs7OztFQWhKZ0MwQixvQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCB0eXBlIHsgUG9zaXRpb24sIEZlYXR1cmUsIEZlYXR1cmVDb2xsZWN0aW9uIH0gZnJvbSAnLi4vZ2VvanNvbi10eXBlcy5qcyc7XG5pbXBvcnQgdHlwZSB7XG4gIFBvaW50ZXJNb3ZlRXZlbnQsXG4gIFN0YXJ0RHJhZ2dpbmdFdmVudCxcbiAgU3RvcERyYWdnaW5nRXZlbnQsXG4gIERyYWdnaW5nRXZlbnQsXG4gIE1vZGVQcm9wcyxcbiAgUGljayxcbiAgR3VpZGVGZWF0dXJlQ29sbGVjdGlvbixcbiAgRWRpdEhhbmRsZUZlYXR1cmVcbn0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHsgZ2V0UGlja2VkRWRpdEhhbmRsZSwgZ2V0UGlja2VkRWRpdEhhbmRsZXMsIGdldEVkaXRIYW5kbGVzRm9yR2VvbWV0cnkgfSBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgeyBCYXNlR2VvSnNvbkVkaXRNb2RlIH0gZnJvbSAnLi9nZW9qc29uLWVkaXQtbW9kZS5qcyc7XG5cbnR5cGUgTW92ZW1lbnRUeXBlRXZlbnQgPSBQb2ludGVyTW92ZUV2ZW50IHwgU3RhcnREcmFnZ2luZ0V2ZW50IHwgU3RvcERyYWdnaW5nRXZlbnQgfCBEcmFnZ2luZ0V2ZW50O1xuXG5leHBvcnQgY2xhc3MgU25hcHBhYmxlTW9kZSBleHRlbmRzIEJhc2VHZW9Kc29uRWRpdE1vZGUge1xuICBfaGFuZGxlcjogQmFzZUdlb0pzb25FZGl0TW9kZTtcblxuICBjb25zdHJ1Y3RvcihoYW5kbGVyOiBCYXNlR2VvSnNvbkVkaXRNb2RlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9oYW5kbGVyID0gaGFuZGxlcjtcbiAgfVxuXG4gIF9nZXRTbmFwcGVkTW91c2VFdmVudDxUOiBNb3ZlbWVudFR5cGVFdmVudD4oXG4gICAgZXZlbnQ6IFQsXG4gICAgc25hcFNvdXJjZTogRWRpdEhhbmRsZUZlYXR1cmUsXG4gICAgc25hcFRhcmdldDogRWRpdEhhbmRsZUZlYXR1cmVcbiAgKTogVCB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZXZlbnQsIHtcbiAgICAgIG1hcENvb3Jkczogc25hcFRhcmdldC5nZW9tZXRyeS5jb29yZGluYXRlcyxcbiAgICAgIHBvaW50ZXJEb3duTWFwQ29vcmRzOiBzbmFwU291cmNlICYmIHNuYXBTb3VyY2UuZ2VvbWV0cnkuY29vcmRpbmF0ZXNcbiAgICB9KTtcbiAgfVxuXG4gIF9nZXRQaWNrZWRTbmFwVGFyZ2V0KHBpY2tzOiBQaWNrW10pOiA/RWRpdEhhbmRsZUZlYXR1cmUge1xuICAgIHJldHVybiBnZXRQaWNrZWRFZGl0SGFuZGxlcyhwaWNrcykuZmluZChcbiAgICAgIGhhbmRsZSA9PiBoYW5kbGUucHJvcGVydGllcy5lZGl0SGFuZGxlVHlwZSA9PT0gJ3NuYXAtdGFyZ2V0J1xuICAgICk7XG4gIH1cblxuICBfZ2V0UGlja2VkU25hcFNvdXJjZShwb2ludGVyRG93blBpY2tzOiA/KFBpY2tbXSkpOiA/RWRpdEhhbmRsZUZlYXR1cmUge1xuICAgIHJldHVybiBnZXRQaWNrZWRFZGl0SGFuZGxlKHBvaW50ZXJEb3duUGlja3MpO1xuICB9XG5cbiAgX2dldFVwZGF0ZWRTbmFwU291cmNlSGFuZGxlKFxuICAgIHNuYXBTb3VyY2VIYW5kbGU6IEVkaXRIYW5kbGVGZWF0dXJlLFxuICAgIGRhdGE6IEZlYXR1cmVDb2xsZWN0aW9uXG4gICk6IEVkaXRIYW5kbGVGZWF0dXJlIHtcbiAgICBjb25zdCB7IGZlYXR1cmVJbmRleCwgcG9zaXRpb25JbmRleGVzIH0gPSBzbmFwU291cmNlSGFuZGxlLnByb3BlcnRpZXM7XG4gICAgY29uc3Qgc25hcFNvdXJjZUZlYXR1cmUgPSBkYXRhLmZlYXR1cmVzW2ZlYXR1cmVJbmRleF07XG5cbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgY29uc3Qgc25hcFNvdXJjZUNvb3JkaW5hdGVzOiBQb3NpdGlvbiA9IHBvc2l0aW9uSW5kZXhlcy5yZWR1Y2UoXG4gICAgICAoYTogYW55W10sIGI6IG51bWJlcikgPT4gYVtiXSxcbiAgICAgIHNuYXBTb3VyY2VGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5zbmFwU291cmNlSGFuZGxlLFxuICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgdHlwZTogJ1BvaW50JyxcbiAgICAgICAgY29vcmRpbmF0ZXM6IHNuYXBTb3VyY2VDb29yZGluYXRlc1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBJZiBhZGRpdGlvbmFsU25hcFRhcmdldHMgaXMgcHJlc2VudCBpbiBtb2RlQ29uZmlnIGFuZCBpcyBwb3B1bGF0ZWQsIHRoaXNcbiAgLy8gbWV0aG9kIHdpbGwgcmV0dXJuIHRob3NlIGZlYXR1cmVzIGFsb25nIHdpdGggdGhlIGZlYXR1cmVzXG4gIC8vIHRoYXQgbGl2ZSBpbiB0aGUgY3VycmVudCBsYXllci4gT3RoZXJ3aXNlLCB0aGlzIG1ldGhvZCB3aWxsIHNpbXBseSByZXR1cm4gdGhlXG4gIC8vIGZlYXR1cmVzIGZyb20gdGhlIGN1cnJlbnQgbGF5ZXJcbiAgX2dldFNuYXBUYXJnZXRzKHByb3BzOiBNb2RlUHJvcHM8RmVhdHVyZUNvbGxlY3Rpb24+KTogRmVhdHVyZVtdIHtcbiAgICBsZXQgeyBhZGRpdGlvbmFsU25hcFRhcmdldHMgfSA9IHByb3BzLm1vZGVDb25maWcgfHwge307XG4gICAgYWRkaXRpb25hbFNuYXBUYXJnZXRzID0gYWRkaXRpb25hbFNuYXBUYXJnZXRzIHx8IFtdO1xuXG4gICAgY29uc3QgZmVhdHVyZXMgPSBbLi4ucHJvcHMuZGF0YS5mZWF0dXJlcywgLi4uYWRkaXRpb25hbFNuYXBUYXJnZXRzXTtcbiAgICByZXR1cm4gZmVhdHVyZXM7XG4gIH1cblxuICBfZ2V0U25hcFRhcmdldEhhbmRsZXMocHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pOiBFZGl0SGFuZGxlRmVhdHVyZVtdIHtcbiAgICBjb25zdCBoYW5kbGVzID0gW107XG4gICAgY29uc3QgZmVhdHVyZXMgPSB0aGlzLl9nZXRTbmFwVGFyZ2V0cyhwcm9wcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZmVhdHVyZShzKVxuICAgICAgY29uc3QgaXNDdXJyZW50SW5kZXhGZWF0dXJlTm90U2VsZWN0ZWQgPSAhcHJvcHMuc2VsZWN0ZWRJbmRleGVzLmluY2x1ZGVzKGkpO1xuXG4gICAgICBpZiAoaXNDdXJyZW50SW5kZXhGZWF0dXJlTm90U2VsZWN0ZWQpIHtcbiAgICAgICAgY29uc3QgeyBnZW9tZXRyeSB9ID0gZmVhdHVyZXNbaV07XG4gICAgICAgIGhhbmRsZXMucHVzaCguLi5nZXRFZGl0SGFuZGxlc0Zvckdlb21ldHJ5KGdlb21ldHJ5LCBpLCAnc25hcC10YXJnZXQnKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVzO1xuICB9XG5cbiAgLy8gSWYgbm8gc25hcCBoYW5kbGUgaGFzIGJlZW4gcGlja2VkLCBvbmx5IGRpc3BsYXkgdGhlIGVkaXQgaGFuZGxlcyBvZiB0aGVcbiAgLy8gc2VsZWN0ZWQgZmVhdHVyZS4gSWYgYSBzbmFwIGhhbmRsZSBoYXMgYmVlbiBwaWNrZWQsIGRpc3BsYXkgc2FpZCBzbmFwIGhhbmRsZVxuICAvLyBhbG9uZyB3aXRoIGFsbCBzbmFwcGFibGUgcG9pbnRzIG9uIGFsbCBub24tc2VsZWN0ZWQgZmVhdHVyZXMuXG4gIGdldEd1aWRlcyhwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPik6IEd1aWRlRmVhdHVyZUNvbGxlY3Rpb24ge1xuICAgIGNvbnN0IHsgbW9kZUNvbmZpZywgbGFzdFBvaW50ZXJNb3ZlRXZlbnQgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgZW5hYmxlU25hcHBpbmcgfSA9IG1vZGVDb25maWcgfHwge307XG5cbiAgICBjb25zdCBndWlkZXM6IEd1aWRlRmVhdHVyZUNvbGxlY3Rpb24gPSB7XG4gICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgZmVhdHVyZXM6IFsuLi50aGlzLl9oYW5kbGVyLmdldEd1aWRlcyhwcm9wcykuZmVhdHVyZXNdXG4gICAgfTtcblxuICAgIGlmICghZW5hYmxlU25hcHBpbmcpIHtcbiAgICAgIHJldHVybiBndWlkZXM7XG4gICAgfVxuXG4gICAgY29uc3Qgc25hcFNvdXJjZUhhbmRsZTogP0VkaXRIYW5kbGVGZWF0dXJlID1cbiAgICAgIGxhc3RQb2ludGVyTW92ZUV2ZW50ICYmIHRoaXMuX2dldFBpY2tlZFNuYXBTb3VyY2UobGFzdFBvaW50ZXJNb3ZlRXZlbnQucG9pbnRlckRvd25QaWNrcyk7XG5cbiAgICAvLyBUaGV5IHN0YXJ0ZWQgZHJhZ2dpbmcgYSBoYW5kbGVcbiAgICAvLyBTbyByZW5kZXIgdGhlIHBpY2tlZCBoYW5kbGUgKGluIGl0cyB1cGRhdGVkIGxvY2F0aW9uKSBhbmQgYWxsIHBvc3NpYmxlIHNuYXAgdGFyZ2V0c1xuICAgIGlmIChzbmFwU291cmNlSGFuZGxlKSB7XG4gICAgICBndWlkZXMuZmVhdHVyZXMucHVzaChcbiAgICAgICAgLi4udGhpcy5fZ2V0U25hcFRhcmdldEhhbmRsZXMocHJvcHMpLFxuICAgICAgICB0aGlzLl9nZXRVcGRhdGVkU25hcFNvdXJjZUhhbmRsZShzbmFwU291cmNlSGFuZGxlLCBwcm9wcy5kYXRhKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGd1aWRlcztcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgdGhlIHBvc3NpYmxlIHNuYXAgc291cmNlIGhhbmRsZXNcbiAgICBjb25zdCB7IGZlYXR1cmVzIH0gPSBwcm9wcy5kYXRhO1xuICAgIGZvciAoY29uc3QgaW5kZXggb2YgcHJvcHMuc2VsZWN0ZWRJbmRleGVzKSB7XG4gICAgICBpZiAoaW5kZXggPCBmZWF0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgeyBnZW9tZXRyeSB9ID0gZmVhdHVyZXNbaW5kZXhdO1xuICAgICAgICBndWlkZXMuZmVhdHVyZXMucHVzaCguLi5nZXRFZGl0SGFuZGxlc0Zvckdlb21ldHJ5KGdlb21ldHJ5LCBpbmRleCwgJ3NuYXAtc291cmNlJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBndWlkZXM7XG4gIH1cblxuICBfZ2V0U25hcEF3YXJlRXZlbnQ8VDogTW92ZW1lbnRUeXBlRXZlbnQ+KGV2ZW50OiBULCBwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPik6IFQge1xuICAgIGNvbnN0IHNuYXBTb3VyY2UgPSB0aGlzLl9nZXRQaWNrZWRTbmFwU291cmNlKHByb3BzLmxhc3RQb2ludGVyTW92ZUV2ZW50LnBvaW50ZXJEb3duUGlja3MpO1xuICAgIGNvbnN0IHNuYXBUYXJnZXQgPSB0aGlzLl9nZXRQaWNrZWRTbmFwVGFyZ2V0KGV2ZW50LnBpY2tzKTtcblxuICAgIHJldHVybiBzbmFwU291cmNlICYmIHNuYXBUYXJnZXRcbiAgICAgID8gdGhpcy5fZ2V0U25hcHBlZE1vdXNlRXZlbnQoZXZlbnQsIHNuYXBTb3VyY2UsIHNuYXBUYXJnZXQpXG4gICAgICA6IGV2ZW50O1xuICB9XG5cbiAgaGFuZGxlU3RhcnREcmFnZ2luZyhldmVudDogU3RhcnREcmFnZ2luZ0V2ZW50LCBwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPikge1xuICAgIHRoaXMuX2hhbmRsZXIuaGFuZGxlU3RhcnREcmFnZ2luZyhldmVudCwgcHJvcHMpO1xuICB9XG5cbiAgaGFuZGxlU3RvcERyYWdnaW5nKGV2ZW50OiBTdG9wRHJhZ2dpbmdFdmVudCwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pIHtcbiAgICB0aGlzLl9oYW5kbGVyLmhhbmRsZVN0b3BEcmFnZ2luZyh0aGlzLl9nZXRTbmFwQXdhcmVFdmVudChldmVudCwgcHJvcHMpLCBwcm9wcyk7XG4gIH1cblxuICBoYW5kbGVEcmFnZ2luZyhldmVudDogRHJhZ2dpbmdFdmVudCwgcHJvcHM6IE1vZGVQcm9wczxGZWF0dXJlQ29sbGVjdGlvbj4pIHtcbiAgICB0aGlzLl9oYW5kbGVyLmhhbmRsZURyYWdnaW5nKHRoaXMuX2dldFNuYXBBd2FyZUV2ZW50KGV2ZW50LCBwcm9wcyksIHByb3BzKTtcbiAgfVxuXG4gIGhhbmRsZVBvaW50ZXJNb3ZlKGV2ZW50OiBQb2ludGVyTW92ZUV2ZW50LCBwcm9wczogTW9kZVByb3BzPEZlYXR1cmVDb2xsZWN0aW9uPikge1xuICAgIHRoaXMuX2hhbmRsZXIuaGFuZGxlUG9pbnRlck1vdmUodGhpcy5fZ2V0U25hcEF3YXJlRXZlbnQoZXZlbnQsIHByb3BzKSwgcHJvcHMpO1xuICB9XG59XG4iXX0=