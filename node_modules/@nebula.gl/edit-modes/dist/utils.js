"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toDeckColor = toDeckColor;
exports.recursivelyTraverseNestedArrays = recursivelyTraverseNestedArrays;
exports.generatePointsParallelToLinePoints = generatePointsParallelToLinePoints;
exports.distance2d = distance2d;
exports.mix = mix;
exports.nearestPointOnProjectedLine = nearestPointOnProjectedLine;
exports.getPickedEditHandle = getPickedEditHandle;
exports.getNonGuidePicks = getNonGuidePicks;
exports.getPickedExistingEditHandle = getPickedExistingEditHandle;
exports.getPickedIntermediateEditHandle = getPickedIntermediateEditHandle;
exports.getPickedEditHandles = getPickedEditHandles;
exports.getEditHandlesForGeometry = getEditHandlesForGeometry;

var _destination = _interopRequireDefault(require("@turf/destination"));

var _bearing = _interopRequireDefault(require("@turf/bearing"));

var _pointToLineDistance = _interopRequireDefault(require("@turf/point-to-line-distance"));

var _helpers = require("@turf/helpers");

var _viewportMercatorProject = _interopRequireDefault(require("viewport-mercator-project"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function toDeckColor(color) {
  var defaultColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [255, 0, 0, 255];

  if (!Array.isArray(color)) {
    return defaultColor;
  }

  return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];
} //
// a GeoJSON helper function that calls the provided function with
// an argument that is the most deeply-nested array having elements
// that are arrays of primitives as an argument, e.g.
//
// {
//   "type": "MultiPolygon",
//   "coordinates": [
//       [
//           [[30, 20], [45, 40], [10, 40], [30, 20]]
//       ],
//       [
//           [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]
//       ]
//   ]
// }
//
// the function would be called on:
//
// [[30, 20], [45, 40], [10, 40], [30, 20]]
//
// and
//
// [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]
//


function recursivelyTraverseNestedArrays(array, prefix, fn) {
  if (!Array.isArray(array[0])) {
    return true;
  }

  for (var i = 0; i < array.length; i++) {
    if (recursivelyTraverseNestedArrays(array[i], _toConsumableArray(prefix).concat([i]), fn)) {
      fn(array, prefix);
      break;
    }
  }

  return false;
}

function generatePointsParallelToLinePoints(p1, p2, mapCoords) {
  var lineString = {
    type: 'LineString',
    coordinates: [p1, p2]
  };
  var pt = (0, _helpers.point)(mapCoords);
  var ddistance = (0, _pointToLineDistance.default)(pt, lineString);
  var lineBearing = (0, _bearing.default)(p1, p2); // Check if current point is to the left or right of line
  // Line from A=(x1,y1) to B=(x2,y2) a point P=(x,y)
  // then (x−x1)(y2−y1)−(y−y1)(x2−x1)

  var isPointToLeftOfLine = (mapCoords[0] - p1[0]) * (p2[1] - p1[1]) - (mapCoords[1] - p1[1]) * (p2[0] - p1[0]); // Bearing to draw perpendicular to the line string

  var orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270; // Get coordinates for the point p3 and p4 which are perpendicular to the lineString
  // Add the distance as the current position moves away from the lineString

  var p3 = (0, _destination.default)(p2, ddistance, orthogonalBearing);
  var p4 = (0, _destination.default)(p1, ddistance, orthogonalBearing);
  return [p3.geometry.coordinates, p4.geometry.coordinates];
}

function distance2d(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}

function mix(a, b, ratio) {
  return b * ratio + a * (1 - ratio);
}

function nearestPointOnProjectedLine(line, inPoint, viewport) {
  var wmViewport = new _viewportMercatorProject.default(viewport); // Project the line to viewport, then find the nearest point

  var coordinates = line.geometry.coordinates;
  var projectedCoords = coordinates.map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 3),
        x = _ref2[0],
        y = _ref2[1],
        _ref2$ = _ref2[2],
        z = _ref2$ === void 0 ? 0 : _ref2$;

    return wmViewport.project([x, y, z]);
  });

  var _wmViewport$project = wmViewport.project(inPoint.geometry.coordinates),
      _wmViewport$project2 = _slicedToArray(_wmViewport$project, 2),
      x = _wmViewport$project2[0],
      y = _wmViewport$project2[1]; // console.log('projectedCoords', JSON.stringify(projectedCoords));


  var minDistance = Infinity;
  var minPointInfo = {};
  projectedCoords.forEach(function (_ref3, index) {
    var _ref4 = _slicedToArray(_ref3, 2),
        x2 = _ref4[0],
        y2 = _ref4[1];

    if (index === 0) {
      return;
    }

    var _projectedCoords = _slicedToArray(projectedCoords[index - 1], 2),
        x1 = _projectedCoords[0],
        y1 = _projectedCoords[1]; // line from projectedCoords[index - 1] to projectedCoords[index]
    // convert to Ax + By + C = 0


    var A = y1 - y2;
    var B = x2 - x1;
    var C = x1 * y2 - x2 * y1; // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line

    var div = A * A + B * B;
    var distance = Math.abs(A * x + B * y + C) / Math.sqrt(div); // TODO: Check if inside bounds

    if (distance < minDistance) {
      minDistance = distance;
      minPointInfo = {
        index: index,
        x0: (B * (B * x - A * y) - A * C) / div,
        y0: (A * (-B * x + A * y) - B * C) / div
      };
    }
  });
  var _minPointInfo = minPointInfo,
      index = _minPointInfo.index,
      x0 = _minPointInfo.x0,
      y0 = _minPointInfo.y0;

  var _projectedCoords2 = _slicedToArray(projectedCoords[index - 1], 3),
      x1 = _projectedCoords2[0],
      y1 = _projectedCoords2[1],
      _projectedCoords2$ = _projectedCoords2[2],
      z1 = _projectedCoords2$ === void 0 ? 0 : _projectedCoords2$;

  var _projectedCoords$inde = _slicedToArray(projectedCoords[index], 3),
      x2 = _projectedCoords$inde[0],
      y2 = _projectedCoords$inde[1],
      _projectedCoords$inde2 = _projectedCoords$inde[2],
      z2 = _projectedCoords$inde2 === void 0 ? 0 : _projectedCoords$inde2; // calculate what ratio of the line we are on to find the proper z


  var lineLength = distance2d(x1, y1, x2, y2);
  var startToPointLength = distance2d(x1, y1, x0, y0);
  var ratio = startToPointLength / lineLength;
  var z0 = mix(z1, z2, ratio);
  return {
    type: 'Feature',
    geometry: {
      type: 'Point',
      coordinates: wmViewport.unproject([x0, y0, z0])
    },
    properties: {
      // TODO: calculate the distance in proper units
      dist: minDistance,
      index: index - 1
    }
  };
}

function getPickedEditHandle(picks) {
  var handles = getPickedEditHandles(picks);
  return handles.length ? handles[0] : null;
}

function getNonGuidePicks(picks) {
  return picks && picks.filter(function (pick) {
    return !pick.isGuide;
  });
}

function getPickedExistingEditHandle(picks) {
  var handles = getPickedEditHandles(picks);
  return handles.find(function (_ref5) {
    var properties = _ref5.properties;
    return properties.featureIndex >= 0 && properties.editHandleType === 'existing';
  });
}

function getPickedIntermediateEditHandle(picks) {
  var handles = getPickedEditHandles(picks);
  return handles.find(function (_ref6) {
    var properties = _ref6.properties;
    return properties.featureIndex >= 0 && properties.editHandleType === 'intermediate';
  });
}

function getPickedEditHandles(picks) {
  var handles = picks && picks.filter(function (pick) {
    return pick.isGuide && pick.object.properties.guideType === 'editHandle';
  }).map(function (pick) {
    return pick.object;
  }) || [];
  return handles;
}

function getEditHandlesForGeometry(geometry, featureIndex) {
  var editHandleType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'existing';
  var handles = [];

  switch (geometry.type) {
    case 'Point':
      // positions are not nested
      handles = [{
        type: 'Feature',
        properties: {
          guideType: 'editHandle',
          editHandleType: editHandleType,
          positionIndexes: [],
          featureIndex: featureIndex
        },
        geometry: {
          type: 'Point',
          coordinates: geometry.coordinates
        }
      }];
      break;

    case 'MultiPoint':
    case 'LineString':
      // positions are nested 1 level
      handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates, [], featureIndex, editHandleType));
      break;

    case 'Polygon':
    case 'MultiLineString':
      // positions are nested 2 levels
      for (var a = 0; a < geometry.coordinates.length; a++) {
        handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[a], [a], featureIndex, editHandleType));

        if (geometry.type === 'Polygon') {
          // Don't repeat the first/last handle for Polygons
          handles = handles.slice(0, -1);
        }
      }

      break;

    case 'MultiPolygon':
      // positions are nested 3 levels
      for (var _a = 0; _a < geometry.coordinates.length; _a++) {
        for (var b = 0; b < geometry.coordinates[_a].length; b++) {
          handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[_a][b], [_a, b], featureIndex, editHandleType)); // Don't repeat the first/last handle for Polygons

          handles = handles.slice(0, -1);
        }
      }

      break;

    default:
      throw Error("Unhandled geometry type: ".concat(geometry.type));
  }

  return handles;
}

function getEditHandlesForCoordinates(coordinates, positionIndexPrefix, featureIndex) {
  var editHandleType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'existing';
  var editHandles = [];

  for (var i = 0; i < coordinates.length; i++) {
    var position = coordinates[i];
    editHandles.push({
      type: 'Feature',
      properties: {
        guideType: 'editHandle',
        positionIndexes: _toConsumableArray(positionIndexPrefix).concat([i]),
        featureIndex: featureIndex,
        editHandleType: editHandleType
      },
      geometry: {
        type: 'Point',
        coordinates: position
      }
    });
  }

  return editHandles;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy91dGlscy5qcyJdLCJuYW1lcyI6WyJ0b0RlY2tDb2xvciIsImNvbG9yIiwiZGVmYXVsdENvbG9yIiwiQXJyYXkiLCJpc0FycmF5IiwicmVjdXJzaXZlbHlUcmF2ZXJzZU5lc3RlZEFycmF5cyIsImFycmF5IiwicHJlZml4IiwiZm4iLCJpIiwibGVuZ3RoIiwiZ2VuZXJhdGVQb2ludHNQYXJhbGxlbFRvTGluZVBvaW50cyIsInAxIiwicDIiLCJtYXBDb29yZHMiLCJsaW5lU3RyaW5nIiwidHlwZSIsImNvb3JkaW5hdGVzIiwicHQiLCJkZGlzdGFuY2UiLCJsaW5lQmVhcmluZyIsImlzUG9pbnRUb0xlZnRPZkxpbmUiLCJvcnRob2dvbmFsQmVhcmluZyIsInAzIiwicDQiLCJnZW9tZXRyeSIsImRpc3RhbmNlMmQiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImR4IiwiZHkiLCJNYXRoIiwic3FydCIsIm1peCIsImEiLCJiIiwicmF0aW8iLCJuZWFyZXN0UG9pbnRPblByb2plY3RlZExpbmUiLCJsaW5lIiwiaW5Qb2ludCIsInZpZXdwb3J0Iiwid21WaWV3cG9ydCIsIldlYk1lcmNhdG9yVmlld3BvcnQiLCJwcm9qZWN0ZWRDb29yZHMiLCJtYXAiLCJ4IiwieSIsInoiLCJwcm9qZWN0IiwibWluRGlzdGFuY2UiLCJJbmZpbml0eSIsIm1pblBvaW50SW5mbyIsImZvckVhY2giLCJpbmRleCIsIkEiLCJCIiwiQyIsImRpdiIsImRpc3RhbmNlIiwiYWJzIiwieDAiLCJ5MCIsInoxIiwiejIiLCJsaW5lTGVuZ3RoIiwic3RhcnRUb1BvaW50TGVuZ3RoIiwiejAiLCJ1bnByb2plY3QiLCJwcm9wZXJ0aWVzIiwiZGlzdCIsImdldFBpY2tlZEVkaXRIYW5kbGUiLCJwaWNrcyIsImhhbmRsZXMiLCJnZXRQaWNrZWRFZGl0SGFuZGxlcyIsImdldE5vbkd1aWRlUGlja3MiLCJmaWx0ZXIiLCJwaWNrIiwiaXNHdWlkZSIsImdldFBpY2tlZEV4aXN0aW5nRWRpdEhhbmRsZSIsImZpbmQiLCJmZWF0dXJlSW5kZXgiLCJlZGl0SGFuZGxlVHlwZSIsImdldFBpY2tlZEludGVybWVkaWF0ZUVkaXRIYW5kbGUiLCJvYmplY3QiLCJndWlkZVR5cGUiLCJnZXRFZGl0SGFuZGxlc0Zvckdlb21ldHJ5IiwicG9zaXRpb25JbmRleGVzIiwiY29uY2F0IiwiZ2V0RWRpdEhhbmRsZXNGb3JDb29yZGluYXRlcyIsInNsaWNlIiwiRXJyb3IiLCJwb3NpdGlvbkluZGV4UHJlZml4IiwiZWRpdEhhbmRsZXMiLCJwb3NpdGlvbiIsInB1c2giXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWFPLFNBQVNBLFdBQVQsQ0FDTEMsS0FESyxFQUc2QjtBQUFBLE1BRGxDQyxZQUNrQyx1RUFEZSxDQUFDLEdBQUQsRUFBTSxDQUFOLEVBQVMsQ0FBVCxFQUFZLEdBQVosQ0FDZjs7QUFDbEMsTUFBSSxDQUFDQyxLQUFLLENBQUNDLE9BQU4sQ0FBY0gsS0FBZCxDQUFMLEVBQTJCO0FBQ3pCLFdBQU9DLFlBQVA7QUFDRDs7QUFDRCxTQUFPLENBQUNELEtBQUssQ0FBQyxDQUFELENBQUwsR0FBVyxHQUFaLEVBQWlCQSxLQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVcsR0FBNUIsRUFBaUNBLEtBQUssQ0FBQyxDQUFELENBQUwsR0FBVyxHQUE1QyxFQUFpREEsS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXLEdBQTVELENBQVA7QUFDRCxDLENBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLFNBQVNJLCtCQUFULENBQ0xDLEtBREssRUFFTEMsTUFGSyxFQUdMQyxFQUhLLEVBSUw7QUFDQSxNQUFJLENBQUNMLEtBQUssQ0FBQ0MsT0FBTixD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O0FBRVZFLFFBQUFBLGVBQWUscUJBQU1LLG1CQUFOLFVBQTJCcEYsQ0FBM0IsRUFGTDtBQUdWeUUsUUFBQUEsWUFBWSxFQUFaQSxZQUhVO0FBSVZDLFFBQUFBLGNBQWMsRUFBZEE7QUFKVSxPQUZHO0FBUWYxRCxNQUFBQSxRQUFRLEVBQUU7QUFDUlQsUUFBQUEsSUFBSSxFQUFFLE9BREU7QUFFUkMsUUFBQUEsV0FBVyxFQUFFOEU7QUFGTDtBQVJLLEtBQWpCO0FBYUQ7O0FBQ0QsU0FBT0QsV0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxuaW1wb3J0IGRlc3RpbmF0aW9uIGZyb20gJ0B0dXJmL2Rlc3RpbmF0aW9uJztcbmltcG9ydCBiZWFyaW5nIGZyb20gJ0B0dXJmL2JlYXJpbmcnO1xuaW1wb3J0IHBvaW50VG9MaW5lRGlzdGFuY2UgZnJvbSAnQHR1cmYvcG9pbnQtdG8tbGluZS1kaXN0YW5jZSc7XG5pbXBvcnQgeyBwb2ludCB9IGZyb20gJ0B0dXJmL2hlbHBlcnMnO1xuaW1wb3J0IFdlYk1lcmNhdG9yVmlld3BvcnQgZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5pbXBvcnQgdHlwZSB7IFZpZXdwb3J0LCBQaWNrLCBFZGl0SGFuZGxlRmVhdHVyZSwgRWRpdEhhbmRsZVR5cGUgfSBmcm9tICcuL3R5cGVzLmpzJztcbmltcG9ydCB0eXBlIHtcbiAgR2VvbWV0cnksXG4gIFBvc2l0aW9uLFxuICBQb2ludCxcbiAgTGluZVN0cmluZyxcbiAgRmVhdHVyZU9mLFxuICBGZWF0dXJlV2l0aFByb3BzXG59IGZyb20gJy4vZ2VvanNvbi10eXBlcy5qcyc7XG5cbmV4cG9ydCB0eXBlIE5lYXJlc3RQb2ludFR5cGUgPSBGZWF0dXJlV2l0aFByb3BzPFBvaW50LCB7IGRpc3Q6IG51bWJlciwgaW5kZXg6IG51bWJlciB9PjtcblxuZXhwb3J0IGZ1bmN0aW9uIHRvRGVja0NvbG9yKFxuICBjb2xvcj86ID9bbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgZGVmYXVsdENvbG9yOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFsyNTUsIDAsIDAsIDI1NV1cbik6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbG9yKSkge1xuICAgIHJldHVybiBkZWZhdWx0Q29sb3I7XG4gIH1cbiAgcmV0dXJuIFtjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1LCBjb2xvclszXSAqIDI1NV07XG59XG5cbi8vXG4vLyBhIEdlb0pTT04gaGVscGVyIGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIHdpdGhcbi8vIGFuIGFyZ3VtZW50IHRoYXQgaXMgdGhlIG1vc3QgZGVlcGx5LW5lc3RlZCBhcnJheSBoYXZpbmcgZWxlbWVudHNcbi8vIHRoYXQgYXJlIGFycmF5cyBvZiBwcmltaXRpdmVzIGFzIGFuIGFyZ3VtZW50LCBlLmcuXG4vL1xuLy8ge1xuLy8gICBcInR5cGVcIjogXCJNdWx0aVBvbHlnb25cIixcbi8vICAgXCJjb29yZGluYXRlc1wiOiBbXG4vLyAgICAgICBbXG4vLyAgICAgICAgICAgW1szMCwgMjBdLCBbNDUsIDQwXSwgWzEwLCA0MF0sIFszMCwgMjBdXVxuLy8gICAgICAgXSxcbi8vICAgICAgIFtcbi8vICAgICAgICAgICBbWzE1LCA1XSwgWzQwLCAxMF0sIFsxMCwgMjBdLCBbNSwgMTBdLCBbMTUsIDVdXVxuLy8gICAgICAgXVxuLy8gICBdXG4vLyB9XG4vL1xuLy8gdGhlIGZ1bmN0aW9uIHdvdWxkIGJlIGNhbGxlZCBvbjpcbi8vXG4vLyBbWzMwLCAyMF0sIFs0NSwgNDBdLCBbMTAsIDQwXSwgWzMwLCAyMF1dXG4vL1xuLy8gYW5kXG4vL1xuLy8gW1sxNSwgNV0sIFs0MCwgMTBdLCBbMTAsIDIwXSwgWzUsIDEwXSwgWzE1LCA1XV1cbi8vXG5leHBvcnQgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZU5lc3RlZEFycmF5cyhcbiAgYXJyYXk6IEFycmF5PGFueT4sXG4gIHByZWZpeDogQXJyYXk8bnVtYmVyPixcbiAgZm46IEZ1bmN0aW9uXG4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5WzBdKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocmVjdXJzaXZlbHlUcmF2ZXJzZU5lc3RlZEFycmF5cyhhcnJheVtpXSwgWy4uLnByZWZpeCwgaV0sIGZuKSkge1xuICAgICAgZm4oYXJyYXksIHByZWZpeCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQb2ludHNQYXJhbGxlbFRvTGluZVBvaW50cyhcbiAgcDE6IFBvc2l0aW9uLFxuICBwMjogUG9zaXRpb24sXG4gIG1hcENvb3JkczogUG9zaXRpb25cbik6IFBvc2l0aW9uW10ge1xuICBjb25zdCBsaW5lU3RyaW5nOiBMaW5lU3RyaW5nID0ge1xuICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAgICBjb29yZGluYXRlczogW3AxLCBwMl1cbiAgfTtcbiAgY29uc3QgcHQgPSBwb2ludChtYXBDb29yZHMpO1xuICBjb25zdCBkZGlzdGFuY2UgPSBwb2ludFRvTGluZURpc3RhbmNlKHB0LCBsaW5lU3RyaW5nKTtcbiAgY29uc3QgbGluZUJlYXJpbmcgPSBiZWFyaW5nKHAxLCBwMik7XG5cbiAgLy8gQ2hlY2sgaWYgY3VycmVudCBwb2ludCBpcyB0byB0aGUgbGVmdCBvciByaWdodCBvZiBsaW5lXG4gIC8vIExpbmUgZnJvbSBBPSh4MSx5MSkgdG8gQj0oeDIseTIpIGEgcG9pbnQgUD0oeCx5KVxuICAvLyB0aGVuICh44oiSeDEpKHky4oiSeTEp4oiSKHniiJJ5MSkoeDLiiJJ4MSlcbiAgY29uc3QgaXNQb2ludFRvTGVmdE9mTGluZSA9XG4gICAgKG1hcENvb3Jkc1swXSAtIHAxWzBdKSAqIChwMlsxXSAtIHAxWzFdKSAtIChtYXBDb29yZHNbMV0gLSBwMVsxXSkgKiAocDJbMF0gLSBwMVswXSk7XG5cbiAgLy8gQmVhcmluZyB0byBkcmF3IHBlcnBlbmRpY3VsYXIgdG8gdGhlIGxpbmUgc3RyaW5nXG4gIGNvbnN0IG9ydGhvZ29uYWxCZWFyaW5nID0gaXNQb2ludFRvTGVmdE9mTGluZSA8IDAgPyBsaW5lQmVhcmluZyAtIDkwIDogbGluZUJlYXJpbmcgLSAyNzA7XG5cbiAgLy8gR2V0IGNvb3JkaW5hdGVzIGZvciB0aGUgcG9pbnQgcDMgYW5kIHA0IHdoaWNoIGFyZSBwZXJwZW5kaWN1bGFyIHRvIHRoZSBsaW5lU3RyaW5nXG4gIC8vIEFkZCB0aGUgZGlzdGFuY2UgYXMgdGhlIGN1cnJlbnQgcG9zaXRpb24gbW92ZXMgYXdheSBmcm9tIHRoZSBsaW5lU3RyaW5nXG4gIGNvbnN0IHAzID0gZGVzdGluYXRpb24ocDIsIGRkaXN0YW5jZSwgb3J0aG9nb25hbEJlYXJpbmcpO1xuICBjb25zdCBwNCA9IGRlc3RpbmF0aW9uKHAxLCBkZGlzdGFuY2UsIG9ydGhvZ29uYWxCZWFyaW5nKTtcblxuICByZXR1cm4gW3AzLmdlb21ldHJ5LmNvb3JkaW5hdGVzLCBwNC5nZW9tZXRyeS5jb29yZGluYXRlc107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZTJkKHgxOiBudW1iZXIsIHkxOiBudW1iZXIsIHgyOiBudW1iZXIsIHkyOiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCBkeCA9IHgxIC0geDI7XG4gIGNvbnN0IGR5ID0geTEgLSB5MjtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtaXgoYTogbnVtYmVyLCBiOiBudW1iZXIsIHJhdGlvOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gYiAqIHJhdGlvICsgYSAqICgxIC0gcmF0aW8pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmVhcmVzdFBvaW50T25Qcm9qZWN0ZWRMaW5lKFxuICBsaW5lOiBGZWF0dXJlT2Y8TGluZVN0cmluZz4sXG4gIGluUG9pbnQ6IEZlYXR1cmVPZjxQb2ludD4sXG4gIHZpZXdwb3J0OiBWaWV3cG9ydFxuKTogTmVhcmVzdFBvaW50VHlwZSB7XG4gIGNvbnN0IHdtVmlld3BvcnQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh2aWV3cG9ydCk7XG4gIC8vIFByb2plY3QgdGhlIGxpbmUgdG8gdmlld3BvcnQsIHRoZW4gZmluZCB0aGUgbmVhcmVzdCBwb2ludFxuICBjb25zdCBjb29yZGluYXRlczogQXJyYXk8QXJyYXk8bnVtYmVyPj4gPSAobGluZS5nZW9tZXRyeS5jb29yZGluYXRlczogYW55KTtcbiAgY29uc3QgcHJvamVjdGVkQ29vcmRzID0gY29vcmRpbmF0ZXMubWFwKChbeCwgeSwgeiA9IDBdKSA9PiB3bVZpZXdwb3J0LnByb2plY3QoW3gsIHksIHpdKSk7XG4gIGNvbnN0IFt4LCB5XSA9IHdtVmlld3BvcnQucHJvamVjdChpblBvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgLy8gY29uc29sZS5sb2coJ3Byb2plY3RlZENvb3JkcycsIEpTT04uc3RyaW5naWZ5KHByb2plY3RlZENvb3JkcykpO1xuXG4gIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICBsZXQgbWluUG9pbnRJbmZvID0ge307XG5cbiAgcHJvamVjdGVkQ29vcmRzLmZvckVhY2goKFt4MiwgeTJdLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IFt4MSwgeTFdID0gcHJvamVjdGVkQ29vcmRzW2luZGV4IC0gMV07XG5cbiAgICAvLyBsaW5lIGZyb20gcHJvamVjdGVkQ29vcmRzW2luZGV4IC0gMV0gdG8gcHJvamVjdGVkQ29vcmRzW2luZGV4XVxuICAgIC8vIGNvbnZlcnQgdG8gQXggKyBCeSArIEMgPSAwXG4gICAgY29uc3QgQSA9IHkxIC0geTI7XG4gICAgY29uc3QgQiA9IHgyIC0geDE7XG4gICAgY29uc3QgQyA9IHgxICogeTIgLSB4MiAqIHkxO1xuXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzdGFuY2VfZnJvbV9hX3BvaW50X3RvX2FfbGluZVxuICAgIGNvbnN0IGRpdiA9IEEgKiBBICsgQiAqIEI7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLmFicyhBICogeCArIEIgKiB5ICsgQykgLyBNYXRoLnNxcnQoZGl2KTtcblxuICAgIC8vIFRPRE86IENoZWNrIGlmIGluc2lkZSBib3VuZHNcblxuICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgbWluUG9pbnRJbmZvID0ge1xuICAgICAgICBpbmRleCxcbiAgICAgICAgeDA6IChCICogKEIgKiB4IC0gQSAqIHkpIC0gQSAqIEMpIC8gZGl2LFxuICAgICAgICB5MDogKEEgKiAoLUIgKiB4ICsgQSAqIHkpIC0gQiAqIEMpIC8gZGl2XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgeyBpbmRleCwgeDAsIHkwIH0gPSBtaW5Qb2ludEluZm87XG4gIGNvbnN0IFt4MSwgeTEsIHoxID0gMF0gPSBwcm9qZWN0ZWRDb29yZHNbaW5kZXggLSAxXTtcbiAgY29uc3QgW3gyLCB5MiwgejIgPSAwXSA9IHByb2plY3RlZENvb3Jkc1tpbmRleF07XG5cbiAgLy8gY2FsY3VsYXRlIHdoYXQgcmF0aW8gb2YgdGhlIGxpbmUgd2UgYXJlIG9uIHRvIGZpbmQgdGhlIHByb3BlciB6XG4gIGNvbnN0IGxpbmVMZW5ndGggPSBkaXN0YW5jZTJkKHgxLCB5MSwgeDIsIHkyKTtcbiAgY29uc3Qgc3RhcnRUb1BvaW50TGVuZ3RoID0gZGlzdGFuY2UyZCh4MSwgeTEsIHgwLCB5MCk7XG4gIGNvbnN0IHJhdGlvID0gc3RhcnRUb1BvaW50TGVuZ3RoIC8gbGluZUxlbmd0aDtcbiAgY29uc3QgejAgPSBtaXgoejEsIHoyLCByYXRpbyk7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICBjb29yZGluYXRlczogd21WaWV3cG9ydC51bnByb2plY3QoW3gwLCB5MCwgejBdKVxuICAgIH0sXG4gICAgcHJvcGVydGllczoge1xuICAgICAgLy8gVE9ETzogY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBpbiBwcm9wZXIgdW5pdHNcbiAgICAgIGRpc3Q6IG1pbkRpc3RhbmNlLFxuICAgICAgaW5kZXg6IGluZGV4IC0gMVxuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBpY2tlZEVkaXRIYW5kbGUocGlja3M6ID8oUGlja1tdKSk6ID9FZGl0SGFuZGxlRmVhdHVyZSB7XG4gIGNvbnN0IGhhbmRsZXMgPSBnZXRQaWNrZWRFZGl0SGFuZGxlcyhwaWNrcyk7XG4gIHJldHVybiBoYW5kbGVzLmxlbmd0aCA/IGhhbmRsZXNbMF0gOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9uR3VpZGVQaWNrcyhwaWNrczogUGlja1tdKTogUGlja1tdIHtcbiAgcmV0dXJuIHBpY2tzICYmIHBpY2tzLmZpbHRlcihwaWNrID0+ICFwaWNrLmlzR3VpZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGlja2VkRXhpc3RpbmdFZGl0SGFuZGxlKHBpY2tzOiA/KFBpY2tbXSkpOiA/RWRpdEhhbmRsZUZlYXR1cmUge1xuICBjb25zdCBoYW5kbGVzID0gZ2V0UGlja2VkRWRpdEhhbmRsZXMocGlja3MpO1xuICByZXR1cm4gaGFuZGxlcy5maW5kKFxuICAgICh7IHByb3BlcnRpZXMgfSkgPT4gcHJvcGVydGllcy5mZWF0dXJlSW5kZXggPj0gMCAmJiBwcm9wZXJ0aWVzLmVkaXRIYW5kbGVUeXBlID09PSAnZXhpc3RpbmcnXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQaWNrZWRJbnRlcm1lZGlhdGVFZGl0SGFuZGxlKHBpY2tzOiA/KFBpY2tbXSkpOiA/RWRpdEhhbmRsZUZlYXR1cmUge1xuICBjb25zdCBoYW5kbGVzID0gZ2V0UGlja2VkRWRpdEhhbmRsZXMocGlja3MpO1xuICByZXR1cm4gaGFuZGxlcy5maW5kKFxuICAgICh7IHByb3BlcnRpZXMgfSkgPT4gcHJvcGVydGllcy5mZWF0dXJlSW5kZXggPj0gMCAmJiBwcm9wZXJ0aWVzLmVkaXRIYW5kbGVUeXBlID09PSAnaW50ZXJtZWRpYXRlJ1xuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGlja2VkRWRpdEhhbmRsZXMocGlja3M6ID8oUGlja1tdKSk6IEVkaXRIYW5kbGVGZWF0dXJlW10ge1xuICBjb25zdCBoYW5kbGVzID1cbiAgICAocGlja3MgJiZcbiAgICAgIHBpY2tzXG4gICAgICAgIC5maWx0ZXIocGljayA9PiBwaWNrLmlzR3VpZGUgJiYgcGljay5vYmplY3QucHJvcGVydGllcy5ndWlkZVR5cGUgPT09ICdlZGl0SGFuZGxlJylcbiAgICAgICAgLm1hcChwaWNrID0+IHBpY2sub2JqZWN0KSkgfHxcbiAgICBbXTtcblxuICByZXR1cm4gaGFuZGxlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVkaXRIYW5kbGVzRm9yR2VvbWV0cnkoXG4gIGdlb21ldHJ5OiBHZW9tZXRyeSxcbiAgZmVhdHVyZUluZGV4OiBudW1iZXIsXG4gIGVkaXRIYW5kbGVUeXBlOiBFZGl0SGFuZGxlVHlwZSA9ICdleGlzdGluZydcbik6IEVkaXRIYW5kbGVGZWF0dXJlW10ge1xuICBsZXQgaGFuZGxlczogRWRpdEhhbmRsZUZlYXR1cmVbXSA9IFtdO1xuXG4gIHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xuICAgIGNhc2UgJ1BvaW50JzpcbiAgICAgIC8vIHBvc2l0aW9ucyBhcmUgbm90IG5lc3RlZFxuICAgICAgaGFuZGxlcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBndWlkZVR5cGU6ICdlZGl0SGFuZGxlJyxcbiAgICAgICAgICAgIGVkaXRIYW5kbGVUeXBlLFxuICAgICAgICAgICAgcG9zaXRpb25JbmRleGVzOiBbXSxcbiAgICAgICAgICAgIGZlYXR1cmVJbmRleFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICAgICAgICBjb29yZGluYXRlczogZ2VvbWV0cnkuY29vcmRpbmF0ZXNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgIC8vIHBvc2l0aW9ucyBhcmUgbmVzdGVkIDEgbGV2ZWxcbiAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLmNvbmNhdChcbiAgICAgICAgZ2V0RWRpdEhhbmRsZXNGb3JDb29yZGluYXRlcyhnZW9tZXRyeS5jb29yZGluYXRlcywgW10sIGZlYXR1cmVJbmRleCwgZWRpdEhhbmRsZVR5cGUpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUG9seWdvbic6XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgIC8vIHBvc2l0aW9ucyBhcmUgbmVzdGVkIDIgbGV2ZWxzXG4gICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLmNvbmNhdChcbiAgICAgICAgICBnZXRFZGl0SGFuZGxlc0ZvckNvb3JkaW5hdGVzKGdlb21ldHJ5LmNvb3JkaW5hdGVzW2FdLCBbYV0sIGZlYXR1cmVJbmRleCwgZWRpdEhhbmRsZVR5cGUpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgICAvLyBEb24ndCByZXBlYXQgdGhlIGZpcnN0L2xhc3QgaGFuZGxlIGZvciBQb2x5Z29uc1xuICAgICAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgIC8vIHBvc2l0aW9ucyBhcmUgbmVzdGVkIDMgbGV2ZWxzXG4gICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgZ2VvbWV0cnkuY29vcmRpbmF0ZXNbYV0ubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICBoYW5kbGVzID0gaGFuZGxlcy5jb25jYXQoXG4gICAgICAgICAgICBnZXRFZGl0SGFuZGxlc0ZvckNvb3JkaW5hdGVzKFxuICAgICAgICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlc1thXVtiXSxcbiAgICAgICAgICAgICAgW2EsIGJdLFxuICAgICAgICAgICAgICBmZWF0dXJlSW5kZXgsXG4gICAgICAgICAgICAgIGVkaXRIYW5kbGVUeXBlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICAvLyBEb24ndCByZXBlYXQgdGhlIGZpcnN0L2xhc3QgaGFuZGxlIGZvciBQb2x5Z29uc1xuICAgICAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IEVycm9yKGBVbmhhbmRsZWQgZ2VvbWV0cnkgdHlwZTogJHtnZW9tZXRyeS50eXBlfWApO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZXM7XG59XG5cbmZ1bmN0aW9uIGdldEVkaXRIYW5kbGVzRm9yQ29vcmRpbmF0ZXMoXG4gIGNvb3JkaW5hdGVzOiBhbnlbXSxcbiAgcG9zaXRpb25JbmRleFByZWZpeDogbnVtYmVyW10sXG4gIGZlYXR1cmVJbmRleDogbnVtYmVyLFxuICBlZGl0SGFuZGxlVHlwZTogRWRpdEhhbmRsZVR5cGUgPSAnZXhpc3RpbmcnXG4pOiBFZGl0SGFuZGxlRmVhdHVyZVtdIHtcbiAgY29uc3QgZWRpdEhhbmRsZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gY29vcmRpbmF0ZXNbaV07XG4gICAgZWRpdEhhbmRsZXMucHVzaCh7XG4gICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGd1aWRlVHlwZTogJ2VkaXRIYW5kbGUnLFxuICAgICAgICBwb3NpdGlvbkluZGV4ZXM6IFsuLi5wb3NpdGlvbkluZGV4UHJlZml4LCBpXSxcbiAgICAgICAgZmVhdHVyZUluZGV4LFxuICAgICAgICBlZGl0SGFuZGxlVHlwZVxuICAgICAgfSxcbiAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBwb3NpdGlvblxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBlZGl0SGFuZGxlcztcbn1cbiJdfQ==